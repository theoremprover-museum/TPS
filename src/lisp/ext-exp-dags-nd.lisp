;;; -*- Mode:LISP; Package:AUTO -*-
;;; ******************************************************************* ;;;
;;;         (c) Copyrighted 1988 by Carnegie Mellon University.         ;;;
;;;                        All rights reserved.                         ;;;
;;;         This code was written as part of the TPS project.           ;;;
;;;   If you want to use this code or any part of TPS, please contact   ;;;
;;;               Peter B. Andrews (Andrews@CS.CMU.EDU)                 ;;;
;;; ******************************************************************* ;;;

(in-package :AUTO)
(part-of EXT-DAGS)

;;;
;;; File: EXT-EXP-DAGS-ND  - cebrown - 4/03

(deffile ext-exp-dags-nd
    (part-of EXT-DAGS)
  (extension clisp)
  (mhelp "Translation from Extensional Expansion Dags to Natural Deduction"))

(context ext-exp-dags) ; fix this

; assumes there's a planned line with wff wffeq-ab to shallow of neg eepf node
(defun ext-exp-pf-to-nd (eepf line &optional supp-assoc edag-lemmas lemmas lemma-ftree-pfs)
  (let ((banned (ext-exp-dag-sel-vars eepf)))
    (setq supp-assoc
	  (append
	   (if ASSERT-LEMMAS
	       (edag-nat-assert-lemmas line (car lemma-ftree-pfs) edag-lemmas lemmas (cadr lemma-ftree-pfs))
	     (edag-nat-introduce-lemmas line (car lemma-ftree-pfs) edag-lemmas lemmas (cadr lemma-ftree-pfs)))
	   supp-assoc))
    (dolist (hl supp-assoc)
      (setq banned (append (ext-exp-dag-sel-vars (car hl))
			   banned)))
    (ext-exp-pf-to-nd-1 line (acons eepf '(CONC nil nil nil)
				    (mapcar #'(lambda (x)
						(list (car x) (cdr x) nil nil nil))
					    supp-assoc))
			(remove-duplicates banned))))

; unsponsor unnecessary lines; remove unnecessary kids from expansion, unnecessary mates from atoms
; and unnecessary eunifs from eqn+/eqngoal-'s
(defun ext-exp-pf-to-nd-1 (line eepfl-lines banned)
  (let ((eepfl-lines2 nil)
	(eepfl (mapcar #'car eepfl-lines))
	(eepfl2 nil))
    (dolist (el eepfl-lines)
      (setq eepfl (remove (car el) eepfl))
      (unless (ext-exp-dag-complete-l (append eepfl2 eepfl) banned)
	(let ((node (car el)))
	  (cond ((member (ext-exp-dag-kind node) '(EXP ATOM EQNGOAL EQN))
		 (let ((node2 (copy-eed node))
		       (arcs (ext-exp-dag-arcs node))
		       (arcs1 (ext-exp-dag-arcs node))
		       (arcs2 nil))
		   (dolist (arc arcs)
		     (setq arcs1 (remove arc arcs1))
		     (setf (ext-exp-dag-arcs node2) (append arcs1 arcs2))
		     (unless (ext-exp-dag-complete-l (cons node2 (append eepfl2 eepfl)) banned)
		       (push arc arcs2)))
		   (setf (ext-exp-dag-arcs node2) arcs2)
		   (push node2 eepfl2)
		   (push (cons node2 (cdr el)) eepfl-lines2)))
		(t
		 (push (car el) eepfl2)
		 (push el eepfl-lines2))))))
    (ext-exp-pf-to-nd-2 line eepfl-lines2 banned)))

; check if done, if not apply rulep if possible, otherwise apply next rule
(defun ext-exp-pf-to-nd-2 (line eepfl-lines banned)
  (let* ((acc (ext-exp-dag-accessible-kids (mapcar #'car eepfl-lines) banned))
	 (next-choices
	  (sort 
	   (remove-if #'null
		      (mapcar #'(lambda (a)
				  (ext-exp-dag-to-nd-choice line a eepfl-lines banned))
			      acc))
	   #'< :key #'car))
	 (best (if query-user
		   (ext-exp-dag-to-nd-choose next-choices)
		 (car next-choices))))
    (if best
	(if (eq (caaddr best) 'DONE)
	    (ext-exp-pf-to-nd-4 best line eepfl-lines banned)
	  (if (and USE-RULEP (ext-exp-dag-rulep (mapcar #'car eepfl-lines)))
	      (let ((ln (linealias line))
		    (supplinenums nil))
		(dolist (el eepfl-lines)
		  (unless (eq (cadr el) 'CONC)
		    (push (linealias (cadr el)) supplinenums)))
		(my-comdecode (list 'cl-user::rulep ln (list 'quote supplinenums))))
	    (ext-exp-pf-to-nd-4 best line eepfl-lines banned)))
      (throwfail "Translation to ND proof reached an impass."))))

(defun ext-exp-pf-to-nd-4 (best line eepfl-lines banned)
  (let* ((bestkind (cadr best))
	 (a (caddr best))
	 (node-a (nth 3 best))
	 (ln (linealias line))
	 (node (cadr a))
	 (node-line (cadr node-a))
	 (nln (unless (eq node-line 'CONC) (linealias node-line)))
	 (arcs (ext-exp-dag-arcs node))
	 (k (ext-exp-dag-kind node))
	 (pos (ext-exp-dag-positive node))
	 (eepfl-lines2 (remove node-a eepfl-lines :test #'equal)))
    (case bestkind
      (ITRUTH (my-comdecode (list 'cl-user::itruth ln '$)))
      (REFL-AB
       (let ((wff (line-assertion line)))
	 (if (wffeq (cdar wff) (cdr wff))
	     (my-comdecode (list 'cl-user::assert 'cl-user::refl= ln))
	   (progn
	     (introduce-gap line 1)
	     (my-comdecode (list 'cl-user::ab* ln (+ ln 1) '$
				 (list 'quote (acons (caar wff) (cdr wff) (cdr wff)))
				 '$ '$))
	     (my-comdecode (list 'cl-user::assert 'cl-user::refl= ln))))))
      (SAME-AB
       (let* ((supp-node (caddr a))
	      (supp-node-a (assoc supp-node eepfl-lines))
	      (supp-node-line (cadr supp-node-a))
	      (wff2 (line-assertion line))
	      (wff1 (line-assertion supp-node-line)))
	 (if (wffeq wff1 wff2)
	     (my-comdecode (list 'cl-user::same ln (linealias supp-node-line) '$ '$ '$))
	   (my-comdecode (list 'cl-user::ab* (linealias supp-node-line) ln '$ '$ '$ '$)))))
      (SYM-AB
       (let* ((supp-node (caddr a))
	      (supp-node-a (assoc supp-node eepfl-lines))
	      (supp-node-line (cadr supp-node-a))
	      (wff2 (line-assertion line))
	      (wff1 (line-assertion supp-node-line))
	      (lwff2 (cdar wff2))
	      (rwff2 (cdr wff2))
	      (lwff1 (cdar wff1))
	      (rwff1 (cdr wff1)))
	 (if (and (wffeq lwff1 rwff2) (wffeq rwff1 lwff2))
	     (my-comdecode (list 'cl-user::sym= ln (linealias supp-node-line) '$ '$ '$ '$))
	   (progn
	     (introduce-gap line 1)
	     (my-comdecode (list 'cl-user::ab* ln (+ ln 1) '$
				 (list 'quote (acons (caar wff1) rwff1 lwff1))
				 '$ '$))
	     (my-comdecode (list 'cl-user::sym= ln (linealias supp-node-line) '$ '$ '$ '$))))))
      (EGEN
       (let* ((exparc (caddr a))
	      (e (ext-exp-arc-exp-term exparc))
	      (expkid (ext-exp-arc-node exparc)))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::egen (+ ln 1) ln (list 'quote e)
			     '$ '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias ln)
			     (cons (list expkid 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (UGEN
       (let* ((selarc (caddr a))
	      (selvar (ext-exp-arc-sel-var selarc))
	      (selkid (ext-exp-arc-node selarc))
	      (wff (line-assertion line)))
	 (if (eq selvar (bindvar wff))
	     (progn
	       (introduce-gap line 1)
	       (my-comdecode (list 'cl-user::ugen (+ ln 1) ln '$ '$ '$ '$))
	       (ext-exp-pf-to-nd-1 (numalias ln) (cons (list selkid 'CONC nil nil nil) eepfl-lines2)
				   (remove selvar banned)))
	   (progn
	     (introduce-gap line 2)
	     (my-comdecode (list 'cl-user::ab* (+ ln 1) (+ ln 2) '$
				 (list 'quote (acons selvar (cdar wff)
						     (substitute-l-term-var selvar (bindvar wff) (cdr wff))))
				 '$ '$))
	     (my-comdecode (list 'cl-user::ugen (+ ln 1) ln '$ '$ '$ '$))
	     (ext-exp-pf-to-nd-1 (numalias ln) (cons (list selkid 'CONC nil nil nil) eepfl-lines2)
				 (remove selvar banned))))))
      (DEDUCT
       (introduce-gap line 2)
       (my-comdecode (list 'cl-user::deduct (+ ln 2) (+ ln 1) ln
			   '$ '$ '$ '$ '$))
       (let ((kid1 (ext-exp-arc-node (car arcs)))
	     (kid2 (ext-exp-arc-node (cadr arcs))))
	 (setf (get (numalias ln) 'ext-exp-dag) kid1)
	 (setf (get (numalias (+ ln 1)) 'ext-exp-dag) kid2)
	 (ext-exp-pf-to-nd-1
	  (numalias (+ ln 1))
	  (cons (list kid2 'CONC nil nil nil)
		(cons (list kid1 (numalias ln) nil nil nil) eepfl-lines2))
	  banned)))
      (IDISJ-LEFT
       (let* ((kid1 (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::idisj-left (+ ln 1) ln '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias ln)
			     (cons (list kid1 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (IDISJ-RIGHT
       (let* ((kid2 (ext-exp-arc-node (cadr arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::idisj-right (+ ln 1) ln '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias ln)
			     (cons (list kid2 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (INDIRECT
       (introduce-gap line 2)
       (my-comdecode (list 'cl-user::indirect (+ ln 2) (+ ln 1) ln '$ '$ '$ '$))
       (let ((line0 (numalias ln))
	     (eepfl-lines3 nil))
	 (if (and (or (member k '(ATOM EQNGOAL)) (and (eq k 'EQN) pos)) (cdr arcs)) ; separate node
	     (let* ((subnode (nth 3 a))
		    (node2 (copy-eed node))
		    (node3 (copy-eed node))
		    (arc1 (find-if #'(lambda (arc) (eq (ext-exp-arc-node arc) subnode)) arcs)))
	       (setf (ext-exp-dag-arcs node2) (remove arc1 arcs))
	       (setf (ext-exp-dag-arcs node3) (list arc1))
	       (dolist (x eepfl-lines)
		 (if (eq (car x) node)
		     (progn
		       (push (cons node2 (cons line0 (cddr x))) eepfl-lines3)
		       (push (cons node3 (cons line0 (cddr x))) eepfl-lines3))
		   (push x eepfl-lines3))))
	   (setq eepfl-lines3 (mapcar #'(lambda (x)
					  (if (eq (cadr x) 'CONC)
					      (cons (car x) (cons line0 (cddr x)))
					    x))
				      eepfl-lines)))
	 (ext-exp-pf-to-nd-1 (numalias (+ ln 1)) eepfl-lines3 banned)))
      (SWITCH-CONC
       (let ((wff (line-assertion line)))
	 (if (find-if #'(lambda (x) (eq (cadr x) 'CONC)) eepfl-lines)
	     (progn
	       (if (wffeq wff 'FALSEHOOD)
		   (progn
		     (introduce-gap line 2)
		     (my-comdecode (list 'cl-user::absurd (+ ln 2) (+ ln 1) '$ '$ '$))
		     (my-comdecode (list 'cl-user::eneg (+ ln 1) nln ln '$ '$ '$ '$))
		     (ext-exp-pf-to-nd-1 (numalias ln)
					 (mapcar #'(lambda (x)
						     (if (eq (car x) node) ; other nodes may remain assoc with line (nln)
							 (cons (car x) (cons 'CONC (cddr x)))
						       x))
						 (remove-if #'(lambda (x)
								(eq (cadr x) 'CONC))
							    eepfl-lines))
					 banned))
		 (progn
		   (introduce-gap line 3)
		   (my-comdecode (list 'cl-user::indirect (+ ln 3) (+ ln 2) ln '$ '$ '$ '$))
		   (my-comdecode (list 'cl-user::eneg (+ ln 2) nln (+ ln 1) '$ '$ '$ '$))
		   (let ((line0 (numalias ln)))
		     (ext-exp-pf-to-nd-1 (numalias (+ ln 1))
					 (mapcar #'(lambda (x)
						     (if (eq (car x) node) ; other nodes may remain assoc with line (nln)
							 (cons (car x) (cons 'CONC (cddr x)))
						       (if (eq (cadr x) 'CONC)
							   (cons (car x) (cons line0 (cddr x)))
							 x)))
						 eepfl-lines)
					 banned)))))
	   (progn
	     (if (wffeq wff 'FALSEHOOD)
		 (progn
		   (introduce-gap line 1)
		   (my-comdecode (list 'cl-user::eneg (+ ln 1) nln ln '$ '$ '$ '$)))
	       (progn
		 (introduce-gap line 2)
		 (my-comdecode (list 'cl-user::absurd (+ ln 2) (+ ln 1) '$ '$ '$))
		 (my-comdecode (list 'cl-user::eneg (+ ln 1) nln ln '$ '$ '$ '$))))
	     (ext-exp-pf-to-nd-1 (numalias ln)
				 (mapcar #'(lambda (x)
					     (if (eq (car x) node) ; other nodes may remain assoc with line (nln)
						 (cons (car x) (cons 'CONC (cddr x)))
					       x))
					 eepfl-lines)
				 banned)))))
      (DEEPEN
       (dolist (arc arcs)
	 (push (cons (ext-exp-arc-node arc) (cdr node-a)) eepfl-lines2))
       (ext-exp-pf-to-nd-1 line eepfl-lines2 banned))
      (LEXPD*
       (introduce-gap line 1)
       (my-comdecode (list 'cl-user::lexpd* (+ ln 1) ln '$ '$ '$ '$))
       (ext-exp-pf-to-nd-1 (numalias ln)
			   (cons (list (ext-exp-arc-node (car arcs)) 'CONC nil nil nil) eepfl-lines2)
			   banned))
      (EQUIVWFFS
       (let ((kid (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::equiv-wffs ln (+ ln 1) '$
			     (list 'quote (ext-exp-dag-shallow kid))
			     '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias ln)
			     (cons (list kid 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (FUNCEXT
       (let* ((kid (ext-exp-arc-node (car arcs)))
	      (wff (ext-exp-dag-shallow kid)))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::ext= (+ ln 1) ln
			     (list 'quote (bindvar wff))
			     '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias ln)
			     (cons (list kid 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (BOOLEXT
       (let ((kid (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::ext=0 (+ ln 1) ln '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias ln)
			     (cons (list kid 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      ((SFUNCEXT SBOOLEXT)
       (let* ((kid (ext-exp-arc-node (car arcs)))
	      (wff (ext-exp-dag-shallow kid)))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::equiv-eq nln ln
			     (list 'quote wff)
			     '$ '$ '$))
	 (ext-exp-pf-to-nd-1 line
			     (cons (list kid (numalias ln) nil nil nil) eepfl-lines2)
			     banned)))
      (IMPLICS-EQUIV
       (let ((kid (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::implics-equiv (+ ln 1) ln '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias ln)
			     (cons (list kid 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (CONJ-EQUIV
       (let ((kid (ext-exp-arc-node (car arcs)))
	     (wff (line-assertion line)))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::lemma (+ ln 1) ln
			     (list 'quote (acons 'OR
						 (acons 'AND (cdar wff) (cdr wff))
						 (acons 'AND (cons 'NOT (cdar wff)) (cons 'NOT (cdr wff)))))
			     '$ '$ '$))
	 (let ((newplan (numalias ln)))
	   (rulep-enter line (list newplan))
	   (setf (line-just-rule line) "EquivConj")
	   (ext-exp-pf-to-nd-1 newplan
			       (cons (list kid 'CONC nil nil nil) eepfl-lines2)
			       banned))))
      (INEG
       (let ((kid (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 2)
	 (my-comdecode (list 'cl-user::ineg (+ ln 2) (+ ln 1) ln '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 (numalias (+ ln 1))
			     (cons (list kid (numalias ln) nil nil nil) eepfl-lines2)
			     banned)))
      (ICONJ
       (let* ((kid1 (ext-exp-arc-node (car arcs)))
	      (kid2 (ext-exp-arc-node (cadr arcs))))
	 (introduce-gap line 2)
	 (my-comdecode (list 'cl-user::iconj (+ ln 2) (+ ln 1) ln '$ '$ '$ '$ '$))
	 (let ((line1 (numalias (+ ln 1))))
	   (ext-exp-pf-to-nd-1 (numalias ln) (cons (list kid1 'CONC nil nil nil) eepfl-lines2)
			       banned)
	   (ext-exp-pf-to-nd-1 line1 (cons (list kid2 'CONC nil nil nil) eepfl-lines2)
			       banned))))
      (REFL-EQS
       (let* ((wff (ext-exp-dag-shallow node))
	      (n (- (length (args (cdar wff))) 1))
	      (eqns nil))
	 (dolist (arc arcs)
	   (let* ((i (ext-exp-arc-dec-index arc))
		  (posn (append (make-list (- n i) :initial-element nil) '(t)))
		  (dnode (ext-exp-arc-node arc))
		  (dwff (ext-exp-dag-shallow dnode)))
	     (unless (wffeq-ab (cdar dwff) (cdr dwff))
	       (push (list dnode posn) eqns))))
	 (ext-exp-pf-to-nd-1 line 
			     (cons (list node 'CONC 'REFL-EQS nil eqns) eepfl-lines2)
			     banned)))
      (REFL-EQS-DEC
       (let* ((eqns (nth 4 node-a))
	      (eqnnode (caar eqns))
	      (node-posn (cadar eqns))
	      (arcs2 (ext-exp-dag-arcs eqnnode)))
	 (pop eqns)
	 (let* ((lwff (cdar (ext-exp-dag-shallow eqnnode)))
		(n (- (length (args lwff)) 1)))
	   (dolist (arc arcs2)
	     (let* ((i (ext-exp-arc-dec-index arc))
		    (posn (append node-posn (make-list (- n i) :initial-element nil) '(t)))
		    (dnode (ext-exp-arc-node arc))
		    (dwff (ext-exp-dag-shallow dnode)))
	       (unless (wffeq-ab (cdar dwff) (cdr dwff))
		 (push (list dnode posn) eqns))))
	   (ext-exp-pf-to-nd-1 line
			       (cons (list node 'CONC 'REFL-EQS nil eqns) eepfl-lines2)
			       banned))))
      (REFL-EQS-LEMMA
       (let* ((eqns (nth 4 node-a))
	      (eqnnode (caar eqns))
	      (node-posn (cadar eqns))
	      (new-eq-line nil)
	      (new-plan-line nil)
	      (eqwff (ext-exp-dag-shallow eqnnode))
	      (lwff (cdar eqwff))
	      (rwff (cdr eqwff))
	      (wff (line-assertion line)) ; an equation
	      (sublwff1 (get-wff-posn (cdar wff) node-posn))
	      (lwff2 (replace-wff-posn (cdar wff) node-posn rwff))
	      (rwff2 (cdr wff)))
	 (pop eqns)
	 (if (wffeq sublwff1 lwff)
	     (progn
	       (introduce-gap line 2)
	       (my-comdecode (list 'cl-user::subst= ln (+ ln 2) (+ ln 1)
				   (list 'quote (acons (caar wff) lwff2 rwff2))
				   '$
				   (list 'quote rwff)
				   (list 'quote lwff)
				   '$ '$ '$))
	       (setq new-eq-line (numalias ln))
	       (setq new-plan-line (numalias (+ ln 1))))
	   (if (wffeq-ab sublwff1 lwff)
	       (progn
		 (introduce-gap line 3)
		 (my-comdecode (list 'cl-user::subst= (+ ln 1) (+ ln 3) (+ ln 2)
				     (list 'quote (acons (caar wff) lwff2 rwff2))
				     '$
				     (list 'quote rwff)
				     (list 'quote sublwff1)
				     '$ '$ '$))
		 (my-comdecode (list 'cl-user::ab* ln (+ ln 1) '$
				     (list 'quote eqwff)
				     '$ '$))
		 (setq new-eq-line (numalias ln))
		 (setq new-plan-line (numalias (+ ln 2))))
	     (throwfail "Bad Subst= Attempt in Translation to ND proof")))
	 (if (wffeq lwff2 rwff2)
	     (my-comdecode (list 'cl-user::assert 'cl-user::refl= (linealias new-plan-line)))
	   (if (wffeq-ab lwff2 rwff2)
	       (let ((npln (linealias new-plan-line)))
		 (introduce-gap new-plan-line 1)
		 (my-comdecode (list 'cl-user::ab* npln (+ npln 1) '$
				     (list 'quote (acons (caar wff) rwff2 lwff2))))
		 (my-comdecode (list 'cl-user::assert 'cl-user::refl= (+ npln 1))))
	     (ext-exp-pf-to-nd-1 new-plan-line
				 (cons (list node 'CONC 'REFL-EQS nil eqns) eepfl-lines2)
				 banned)))
	 (ext-exp-pf-to-nd-1 new-eq-line
			     (cons (list eqnnode 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (REFL-EQS-KID
       (let* ((eqns (nth 4 node-a))
	      (eqnnode (caar eqns))
	      (node-posn (cadar eqns))
	      (arcs2 (ext-exp-dag-arcs eqnnode)))
	 (pop eqns)
	 (ext-exp-pf-to-nd-1 line (cons (list node 'CONC 'REFL-EQS nil
					      (cons (list (ext-exp-arc-node (car arcs2)) node-posn) eqns))
					eepfl-lines2)
			     banned)))
      (EUNIF
       (let* ((supp-node (caddr a))
	      (conjnode (nth 3 a))
	      (supp-node-a (assoc supp-node eepfl-lines))
	      (supp-node-line (cadr supp-node-a))
	      (wff2 (line-assertion line))
	      (lwff2 (cdar wff2))
	      (rwff2 (cdr wff2))
	      (wff1 (line-assertion supp-node-line))
	      (lwff1 (cdar wff1))
	      (rwff1 (cdr wff1))
	      (conjarcs (ext-exp-dag-arcs conjnode))
	      (eqnnode1 (ext-exp-arc-node (car conjarcs)))
	      (eqnnode2 (ext-exp-arc-node (cadr conjarcs)))
	      (q (caar wff2)))
	 (if (eq (nth 4 a) 'EUNIF1)
	     (cond ((wffeq rwff1 rwff2)
		    (introduce-gap line 1)
		    (my-comdecode (list 'cl-user::subst= ln (+ ln 1) (linealias supp-node-line) 
					'$ '$ (list 'quote lwff2) (list 'quote lwff1) '$ '$ '$))
		    (ext-exp-pf-to-nd-1 (numalias ln)
					(cons (list eqnnode1 'CONC nil nil nil) eepfl-lines2)
					banned))
		   ((wffeq-ab rwff1 rwff2)
		    (introduce-gap line 2)
		    (my-comdecode (list 'cl-user::ab* (+ ln 1) (+ ln 2) '$
					(list 'quote (acons q lwff2 rwff1)) '$ '$))
		    (my-comdecode (list 'cl-user::subst= ln (+ ln 1) (linealias supp-node-line) 
					'$ '$ (list 'quote lwff2) (list 'quote lwff1) '$ '$ '$))
		    (ext-exp-pf-to-nd-1 (numalias ln)
					(cons (list eqnnode1 'CONC nil nil nil) eepfl-lines2)
					banned))
		   ((wffeq lwff1 lwff2)
		    (introduce-gap line 1)
		    (my-comdecode (list 'cl-user::subst= ln (+ ln 1) (linealias supp-node-line) 
					'$ '$ (list 'quote rwff2) (list 'quote rwff1) '$ '$ '$))
		    (ext-exp-pf-to-nd-1 (numalias ln)
					(cons (list eqnnode2 'CONC nil nil nil) eepfl-lines2)
					banned))
		   ((wffeq-ab lwff1 lwff2)
		    (introduce-gap line 2)
		    (my-comdecode (list 'cl-user::ab* (+ ln 1) (+ ln 2) '$
					(list 'quote (acons q lwff1 rwff2)) '$ '$))
		    (my-comdecode (list 'cl-user::subst= ln (+ ln 1) (linealias supp-node-line) 
					'$ '$ (list 'quote rwff2) (list 'quote rwff1) '$ '$ '$))
		    (ext-exp-pf-to-nd-1 (numalias ln)
					(cons (list eqnnode2 'CONC nil nil nil) eepfl-lines2)
					banned))
		   (t
		    (introduce-gap line 3)
		    (my-comdecode (list 'cl-user::lemma (+ ln 3) ln
					(list 'quote (acons q lwff1 lwff2)) '$ '$ '$))
		    (my-comdecode (list 'cl-user::lemma (+ ln 3) (+ ln 1)
					(list 'quote (acons q rwff1 rwff2)) '$ '$ '$))
		    (my-comdecode (list 'cl-user::subst= ln (+ ln 2) (linealias supp-node-line) '$ 
					(list 'quote (acons q lwff2 rwff1))
					'$ '$ '$ '$ '$))
		    (my-comdecode (list 'cl-user::subst= (+ ln 1) (+ ln 3) (+ ln 2)
					'$ '$ '$ '$ '$ '$ '$))
		    (let ((line1 (numalias (+ ln 1))))
		      (ext-exp-pf-to-nd-1 (numalias ln)
					  (cons (list eqnnode1 'CONC nil nil nil) eepfl-lines2)
					  banned)
		      (ext-exp-pf-to-nd-1 line1
					  (cons (list eqnnode2 'CONC nil nil nil) eepfl-lines2)
					  banned))))
	   (cond ((wffeq rwff1 lwff2)
		  (introduce-gap line 1)
		  (my-comdecode (list 'cl-user::subst= (linealias supp-node-line) (+ ln 1) ln
				      (list 'quote (acons q lwff1 rwff2)) '$ '$ '$ '$ '$ '$))
		  (ext-exp-pf-to-nd-1 (numalias ln)
				      (cons (list eqnnode1 'CONC nil nil nil) eepfl-lines2)
				      banned))
		 ((wffeq-ab rwff1 lwff2)
		  (introduce-gap line 2)
		  (my-comdecode (list 'cl-user::ab* (+ ln 1) (+ ln 2) '$
				      (list 'quote (acons q rwff1 lwff2)) '$ '$))
		  (my-comdecode (list 'cl-user::subst= (linealias supp-node-line) (+ ln 1) ln
				      (list 'quote (acons q lwff1 rwff2)) '$ '$ '$ '$ '$ '$))
		  (ext-exp-pf-to-nd-1 (numalias ln)
				      (cons (list eqnnode1 'CONC nil nil nil) eepfl-lines2)
				      banned))
		 ((wffeq lwff1 rwff2)
		  (introduce-gap line 2)
		  (my-comdecode (list 'cl-user::sym= (+ ln 2) (+ ln 1) '$ '$ '$ '$))
		  (my-comdecode (list 'cl-user::subst= ln (+ ln 1) (linealias supp-node-line)
				      '$ '$ (list 'quote lwff2) (list 'quote rwff1) '$ '$ '$))
		  (ext-exp-pf-to-nd-1 (numalias ln)
				      (cons (list eqnnode2 'CONC nil nil nil) eepfl-lines2)
				      banned))
		 ((wffeq-ab lwff1 rwff2)
		  (introduce-gap line 3)
		  (my-comdecode (list 'cl-user::ab* (+ ln 2) (+ ln 3) '$
				      (list 'quote (acons q lwff2 lwff1)) '$ '$))
		  (my-comdecode (list 'cl-user::sym= (+ ln 2) (+ ln 1) '$ '$ '$ '$))
		  (my-comdecode (list 'cl-user::subst= ln (+ ln 1) (linealias supp-node-line)
				      '$ '$ (list 'quote lwff2) (list 'quote rwff1) '$ '$ '$))
		  (ext-exp-pf-to-nd-1 (numalias ln)
				      (cons (list eqnnode2 'CONC nil nil nil) eepfl-lines2)
				      banned))
		 (t
		  (introduce-gap line 3)
		  (my-comdecode (list 'cl-user::lemma (+ ln 3) ln
				      (list 'quote (acons q lwff1 rwff2)) '$ '$ '$))
		  (my-comdecode (list 'cl-user::lemma (+ ln 3) (+ ln 1)
				      (list 'quote (acons q rwff1 lwff2)) '$ '$ '$))
		  (my-comdecode (list 'cl-user::subst= (linealias supp-node-line) (+ ln 2) ln
				      '$
				      (list 'quote (acons q rwff1 rwff2))
				      '$ '$ '$ '$ '$))
		  (my-comdecode (list 'cl-user::subst= (+ ln 1) (+ ln 3) (+ ln 2)
				      '$ '$ '$ '$ '$ '$ '$))
		  (let ((line1 (numalias (+ ln 1))))
		    (ext-exp-pf-to-nd-1 (numalias ln)
					(cons (list eqnnode1 'CONC nil nil nil) eepfl-lines2)
					banned)
		    (ext-exp-pf-to-nd-1 line1
					(cons (list eqnnode2 'CONC nil nil nil) eepfl-lines2)
					banned)))))))
      (MATE-EQS-DEC
       (let* ((eqns (nth 4 node-a))
	      (eqnnode (caar eqns))
	      (node-posn (cadar eqns))
	      (supp-line (nth 3 node-a))
	      (arcs2 (ext-exp-dag-arcs eqnnode)))
	 (pop eqns)
	 (let* ((subwff (get-wff-posn (ext-exp-dag-shallow node) node-posn))
		(n (- (length (args subwff)) 1)))
	   (dolist (arc arcs2)
	     (let* ((i (ext-exp-arc-dec-index arc))
		    (posn (append node-posn (make-list (- n i) :initial-element nil) '(t)))
		    (dnode (ext-exp-arc-node arc))
		    (dwff (ext-exp-dag-shallow dnode)))
	       (unless (wffeq-ab (cdar dwff) (cdr dwff))
		 (push (list dnode posn) eqns))))
	   (ext-exp-pf-to-nd-1 line
			       (cons (list node 'CONC 'MATE-EQS supp-line eqns) eepfl-lines2)
			       banned))))
      (MATE-EQS-LEMMA
       (let* ((eqns (nth 4 node-a))
	      (eqnnode (caar eqns))
	      (node-posn (cadar eqns))
	      (supp-line (nth 3 node-a))
	      (sln (linealias supp-line))
	      (wff1 (line-assertion supp-line))
	      (new-eq-line nil)
	      (new-supp-line nil)
	      (subwff1 (get-wff-posn wff1 node-posn))
	      (eqwff (ext-exp-dag-shallow eqnnode))
	      (lwff (cdar eqwff))
	      (rwff (cdr eqwff))
	      (wff2 (replace-wff-posn wff1 node-posn lwff)))
	 (pop eqns)
	 (if eqns ; more equations to prove
	     (if (wffeq subwff1 rwff)
		 (progn
		   (introduce-gap line 2)
		   (my-comdecode (list 'cl-user::subst= ln (+ ln 1) sln '$
				       (list 'quote wff2)
				       (list 'quote rwff)
				       (list 'quote lwff)
				       '$ '$ '$))
		   (setq new-eq-line (numalias ln))
		   (setq new-supp-line (numalias (+ ln 1))))
	       (if (wffeq-ab subwff1 rwff)
		   (progn
		     (introduce-gap line 3)
		     (my-comdecode (list 'cl-user::ab* sln ln '$
					 (list 'quote (replace-wff-posn wff1 node-posn rwff))
					 '$ '$))
		     (my-comdecode (list 'cl-user::subst= (+ ln 1) (+ ln 2) ln '$
					 (list 'quote wff2)
					 (list 'quote rwff)
					 (list 'quote lwff)
					 '$ '$ '$))
		     (setq new-eq-line (numalias (+ ln 1)))
		     (setq new-supp-line (numalias (+ ln 2))))
		 (throwfail "Bad Subst= Attempt in Translation to ND proof")))
	   (let ((wff (line-assertion line)))
	     (if (wffeq subwff1 rwff)
		 (if (wffeq wff2 wff)
		     (progn
		       (introduce-gap line 1)
		       (my-comdecode (list 'cl-user::subst= ln (+ ln 1) sln '$
					   (list 'quote wff2)
					   (list 'quote rwff)
					   (list 'quote lwff)
					   '$ '$ '$))
		       (setq new-eq-line (numalias ln)))
		   (if (wffeq-ab wff2 wff)
		       (progn
			 (introduce-gap line 2)
			 (my-comdecode (list 'cl-user::subst= ln (+ ln 1) sln '$
					     (list 'quote wff2)
					     (list 'quote rwff)
					     (list 'quote lwff)
					     '$ '$ '$))
			 (my-comdecode (list 'cl-user::ab* (+ ln 1) (+ ln 2) '$ '$ '$ '$))
			 (setq new-eq-line (numalias ln)))
		     (throwfail "Bad Subst= Attempt in Translation to ND proof")))
	       (if (wffeq-ab subwff1 rwff)
		   (if (wffeq wff2 wff)
		       (progn
			 (introduce-gap line 2)
			 (my-comdecode (list 'cl-user::ab* sln ln '$
					     (list 'quote (replace-wff-posn wff1 node-posn rwff))
					     '$ '$))
			 (my-comdecode (list 'cl-user::subst= (+ ln 1) (+ ln 2) ln '$ '$
					     (list 'quote rwff)
					     (list 'quote lwff)
					     '$ '$ '$))
			 (setq new-eq-line (numalias (+ ln 1))))
		     (if (wffeq-ab wff2 wff)
			 (progn
			   (introduce-gap line 3)
			   (my-comdecode (list 'cl-user::ab* sln ln '$
					       (list 'quote (replace-wff-posn wff1 node-posn rwff))
					       '$ '$))
			   (my-comdecode (list 'cl-user::subst= (+ ln 1) (+ ln 2) ln '$
					       (list 'quote wff2)
					       (list 'quote rwff)
					       (list 'quote lwff)
					       '$ '$ '$))
			   (my-comdecode (list 'cl-user::ab* (+ ln 2) (+ ln 3) '$ '$ '$ '$))
			   (setq new-eq-line (numalias (+ ln 1))))
		       (throwfail "Bad Subst= Attempt in Translation to ND proof")))))))
	 (unless new-eq-line
	   (throwfail "Did not get new equation line."))
	 (when eqns
	   (ext-exp-pf-to-nd-1 line
			       (cons (list node 'CONC 'MATE-EQS new-supp-line eqns) eepfl-lines2)
			       banned))
	 (ext-exp-pf-to-nd-1 new-eq-line
			     (cons (list eqnnode 'CONC nil nil nil) eepfl-lines2)
			     banned)))
      (MATE-EQS-KID
       (let* ((eqns (nth 4 node-a))
	      (eqnnode (caar eqns))
	      (node-posn (cadar eqns))
	      (supp-line (nth 3 node-a))
	      (arcs2 (ext-exp-dag-arcs eqnnode)))
	 (pop eqns)
	 (ext-exp-pf-to-nd-1 line (cons (list node 'CONC 'MATE-EQS supp-line
					      (cons (list (ext-exp-arc-node (car arcs2)) node-posn) eqns))
					eepfl-lines2)
			     banned)))
      (MATE-EQS
       (let* ((supp-node (caddr a))
	      (supp-node-a (assoc supp-node eepfl-lines))
	      (supp-node-line (cadr supp-node-a))
	      (eqnnode (nth 3 a)))
	 (ext-exp-pf-to-nd-1 line
			     (cons (list node 'CONC 'MATE-EQS supp-node-line (list (list eqnnode nil))) eepfl-lines2)
			     banned)))
      (ABSURD (my-comdecode (list 'cl-user::absurd ln nln '$ '$ '$)))
      (UI
       (let* ((exparc (caddr a))
	      (e (ext-exp-arc-exp-term exparc))
	      (expkid (ext-exp-arc-node exparc))
	      (wff (ext-exp-dag-shallow node))
	      (neg1 (and (not pos) (not-p (cdr wff)))))
	 (when (cdr arcs)
	   (let ((node2 (copy-eed node)))
	     (setf (ext-exp-dag-arcs node2) (remove exparc arcs))
	     (push (cons node2 (cons node-line (cddr node-a))) eepfl-lines2)))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::ui nln ln (list 'quote e) '$ '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 line (cons (list expkid (numalias ln) (if neg1 'NEG nil) nil nil)
					eepfl-lines2)
			     banned)))
      (RULEC
       (let* ((selarc (caddr a))
	      (selvar (ext-exp-arc-sel-var selarc))
	      (selkid (ext-exp-arc-node selarc))
	      (wff (ext-exp-dag-shallow node))
	      (neg1 (and (not pos) (not-p (cdr wff)))))
	 (progn
	   (introduce-gap line 2)
	   (my-comdecode (list 'cl-user::rulec (+ ln 2) nln (+ ln 1) ln (list 'quote selvar)
			       '$ '$ '$ '$ '$ '$ '$ '$))
	   (ext-exp-pf-to-nd-1 (numalias (+ ln 1))
			       (cons (list selkid (numalias ln) (if neg1 'NEG nil) nil nil)
				     eepfl-lines2)
			       (remove selvar banned)))))
      (ECONJ
       (let* ((wff (ext-exp-dag-shallow node))
	      (neg1 (and (not pos) (or-p wff) (not-p (cdar wff))))
	      (neg2 (and (not pos) (not-p (cdr wff)))))
	 (introduce-gap line 2)
	 (my-comdecode (list 'cl-user::econj nln (+ ln 1) ln '$ '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 line
			     (cons (list (ext-exp-arc-node (car arcs)) (numalias ln) (if neg1 'NEG nil) nil nil)
				   (cons (list (ext-exp-arc-node (cadr arcs)) (numalias (+ ln 1)) (if neg2 'NEG nil) nil nil)
					 eepfl-lines2))
			     banned)))
      (LCONTR*
       (introduce-gap line 1)
       (my-comdecode (list 'cl-user::lcontr* nln ln '$ '$ '$ '$))
       (ext-exp-pf-to-nd-1 line
			   (cons (list (ext-exp-arc-node (car arcs)) (numalias ln) nil nil nil) eepfl-lines2)
			   banned))
      (SEQUIVWFFS
       (let ((kid (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::equiv-wffs nln ln
			     (list 'quote (ext-exp-dag-shallow kid))
			     '$ '$ '$))
	 (ext-exp-pf-to-nd-1 line
			     (cons (list kid (numalias ln) nil nil nil) eepfl-lines2)
			     banned)))
      (SNEQUIVWFFS
       (let ((kid (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::equiv-wffs nln ln
			     (list 'quote (cons 'NOT (ext-exp-dag-shallow kid)))
			     '$ '$ '$))
	 (ext-exp-pf-to-nd-1 line
			     (cons (list kid (numalias ln) nil nil nil) eepfl-lines2)
			     banned)))
      (EQUIV-IMPLICS
       (let ((kid (ext-exp-arc-node (car arcs))))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::equiv-implics nln ln '$ '$ '$ '$))
	 (ext-exp-pf-to-nd-1 line
			     (cons (list kid (numalias ln) nil nil nil) eepfl-lines2)
			     banned)))
      (EQUIV-CONJ
       (let ((kid (ext-exp-arc-node (car arcs)))
	     (wff (line-assertion node-line)))
	 (introduce-gap line 1)
	 (my-comdecode (list 'cl-user::lemma (+ ln 1) ln
			     (list 'quote (acons 'OR
						 (acons 'AND (cdar wff) (cdr wff))
						 (acons 'AND (cons 'NOT (cdar wff)) (cons 'NOT (cdr wff)))))
			     '$ '$ '$))
	 (let ((new-support (numalias ln)))
	   (rulep-enter new-support (list node-line))
	   (setf (line-just-rule new-support) "EquivConj")
	   (ext-exp-pf-to-nd-1 line
			       (cons (list kid new-support nil nil nil) eepfl-lines2)
			       banned))))
      (MP
       (let* ((kid1 (ext-exp-arc-node (car arcs)))
	      (kid2 (ext-exp-arc-node (cadr arcs)))
	      (eepfl-lines3 (remove-if #'(lambda (x) (eq (cadr x) 'CONC)) eepfl-lines2))
	      (hyps (mapcar #'(lambda (x) (linealias x)) (line-hypotheses line))))
	 (introduce-gap line 2)
	 (my-comdecode (list 'cl-user::mp nln (+ ln 1) ln '$ '$ '$ (list 'quote hyps) (list 'quote hyps)))
	 (let ((line0 (numalias ln)))
	   (ext-exp-pf-to-nd-1 line (cons (list kid2 (numalias (+ ln 1)) nil nil nil) eepfl-lines2)
			       banned)
	   (ext-exp-pf-to-nd-1 line0 (cons (list kid1 'CONC nil nil nil) eepfl-lines3)
			       banned))))
      (INDIRECT-MP
       (let* ((kid1 (ext-exp-arc-node (car arcs)))
	      (kid2 (ext-exp-arc-node (cadr arcs)))
	      (eepfl-lines3 (remove-if #'(lambda (x) (eq (cadr x) 'CONC)) eepfl-lines2))
	      (hyps (mapcar #'(lambda (x) (linealias x)) (line-hypotheses line)))
	      (hyps2 (append hyps (list ln))))
	 (introduce-gap line 4)
	 (my-comdecode (list 'cl-user::indirect (+ ln 4) (+ ln 3) ln '$ '$ '$ '$))
	 (my-comdecode (list 'cl-user::mp nln (+ ln 2) (+ ln 1) '$ '$ '$ (list 'quote hyps2) (list 'quote hyps2)))
	 (let* ((eepfl-lines4 (remove-if-not #'(lambda (x) (eq (cadr x) 'CONC)) eepfl-lines2))
		(hline (numalias ln))
		(line1 (numalias (+ ln 1)))
		(eepfl-lines5 (append eepfl-lines3
				      (mapcar #'(lambda (x) (cons (car x) (cons hline (cddr x))))
					      eepfl-lines4))))
	   (ext-exp-pf-to-nd-1 (numalias (+ ln 3))
			       (cons (list kid2 (numalias (+ ln 2)) nil nil nil) eepfl-lines5)
			       banned)
	   (ext-exp-pf-to-nd-1 line1 (cons (list kid1 'CONC nil nil nil) eepfl-lines5)
			       banned))))
      (CASES
       (let* ((kid1 (ext-exp-arc-node (car arcs)))
	      (kid2 (ext-exp-arc-node (cadr arcs)))
	      (wff (ext-exp-dag-shallow node))
	      (neg1 (and (not pos) (not-p (cdar wff))))
	      (neg2 (and (not pos) (not-p (cdr wff)))))
	 (introduce-gap line 4)
	 (my-comdecode (list 'cl-user::cases (+ ln 4) nln (+ ln 3) (+ ln 2) (+ ln 1) ln
			     '$ '$ '$ '$ '$ '$ '$ '$ '$))
	 (let ((line2 (numalias (+ ln 2)))
	       (line3 (numalias (+ ln 3))))
	   (ext-exp-pf-to-nd-1 (numalias (+ ln 1))
			       (cons (list kid1 (numalias ln) (if neg1 'NEG nil) nil nil) eepfl-lines2)
			       banned)
	   (ext-exp-pf-to-nd-1 line3
			       (cons (list kid2 line2 (if neg2 'NEG nil) nil nil) eepfl-lines2)
			       banned))))
      (PUSHNEG
       (introduce-gap line 1)
       (my-comdecode (list 'cl-user::pushneg nln ln '$ '$ '$ '$))
       (ext-exp-pf-to-nd-1 line
			   (cons (list node (numalias ln) 'NEG nil nil) eepfl-lines2)
			   banned)))))

(defun ext-exp-dag-to-nd-choose (choices)
  (if choices
      (if (< (caar choices) 0)
	  (car choices)
	(let ((done nil))
	  (do ((ch choices (cdr ch)))
	      ((or done (not ch)) done)
	    (when (query (nth 4 (car ch)) t)
	      (setq done (car ch))))))
    nil))

(defun ext-exp-dag-to-nd-choice (line a eepfl-lines banned)
  (let* ((ln (linealias line))
	 (node (cadr a))
	 (node-a (assoc node eepfl-lines))
	 (node-line (cadr node-a))
	 (node-type (caddr node-a))
	 (arcs (ext-exp-dag-arcs node))
	 (k (ext-exp-dag-kind node))
	 (pos (ext-exp-dag-positive node)))
    (if (eq node-line 'CONC)
	(if (eq (car a) 'DONE)
	    (case k
	      (TRUE (list -2 'ITRUTH a node-a))
	      ((EQN DEC)
	       (list -2 'REFL-AB a node-a))
	      (t nil))
	  (case k
	    (EXP
	     (if (cdr arcs)
		 (list 15 'INDIRECT a node-a (format nil "Apply Indirect to line ~d" ln))
	       (list 7 'EGEN a node-a (format nil "Apply EGen to line ~d" ln))))
	    (SEL
	     (if (cdr arcs)
		 nil
	       (list 6 'UGEN a node-a (format nil "Apply UGen to line ~d" ln))))
	    (IMP
	     (list 2 'DEDUCT a node-a (format nil "Apply Deduct to line ~d" ln)))
	    (DIS
	     (let* ((kid1 (ext-exp-arc-node (car arcs)))
		    (kid2 (ext-exp-arc-node (cadr arcs)))
		    (eepfl-lines2 (remove node-a eepfl-lines :test #'equal))
		    (others (mapcar #'car eepfl-lines2)))
	       (if (ext-exp-dag-complete-l (cons kid1 others) banned)
		   (list 9 'IDISJ-LEFT a node-a (format nil "Apply IDisj-Left to line ~d" ln))
		 (if (ext-exp-dag-complete-l (cons kid2 others) banned)
		     (list 9 'IDISJ-RIGHT a node-a (format nil "Apply IDisj-Right to line ~d" ln))
		   (list 20 'INDIRECT a node-a (format nil "Apply Indirect to line ~d" ln))))))
	    (EQN
	     (let ((eqndec-arc (find-if #'(lambda (arc)
					    (eq (ext-exp-arc-kind arc) 'EQNDEC)) arcs))
		   (eqngoal-arc (find-if #'(lambda (arc)
					     (eq (ext-exp-arc-kind arc) 'EQNGOAL)) arcs)))
	       (if (and eqndec-arc eqngoal-arc
			(ext-exp-dag-arcs (ext-exp-arc-node eqngoal-arc)))
		   (list 20 'INDIRECT a node-a (format nil "Apply Indirect to line ~d" ln))
		 (list -1 'DEEPEN a node-a))))
	    (REW
	     (case (ext-exp-dag-rew-just node)
	       (LAMBDA (list 1 'LEXPD* a node-a (format nil "Lambda expand line ~d" ln)))
	       (EQUIVWFFS (list 1 'EQUIVWFFS a node-a (format nil "Apply Equivwffs to line ~d" ln)))
	       (EXT= 
		(let* ((eqwff (line-assertion line))
		       (tp (unabbreviated-type (cdr eqwff))))
		  (cond ((wffeq-ab (cdar eqwff) (cdr eqwff))
			 (list -2 'REFL-AB a node-a))
			((consp tp)
			 (list 4 'FUNCEXT a node-a (format nil "Apply Functional Ext to line ~d" ln)))
			(t
			 (list 4 'BOOLEXT a node-a (format nil "Apply Boolean Ext to line ~d" ln))))))
	       (EQUIV-IMPLICS
		(list 4 'IMPLICS-EQUIV a node-a (format nil "Apply Implics-Equiv to line ~d" ln)))
	       (EQUIV-DISJS
		(list 4 'CONJ-EQUIV a node-a (format nil "Apply EquivConj to line ~d" ln)))
	       (t nil)))
	    (NEG (list 18 'INEG a node-a (format nil "Apply INeg to line ~d" ln)))
	    (CON (list 10 'ICONJ a node-a (format nil "Apply IConj to line ~d" ln)))
	    (DEC
	     (if (eq node-type 'REFL-EQS)
		 (let* ((eqns (nth 4 node-a))
			(eqnnode (caar eqns))
			(k2 (ext-exp-dag-kind eqnnode))
			(arcs2 (ext-exp-dag-arcs eqnnode)))
		   (cond ((eq k2 'DEC) (list -1 'REFL-EQS-DEC a node-a))
			 ((or (and (eq k2 'REW) (eq (ext-exp-dag-rew-just eqnnode) 'EXT=))
			      (and (eq k2 'EQN) (cdr arcs2))
			      (eq k2 'EQNGOAL))
			  (list 18 'REFL-EQS-LEMMA a node-a (format nil "Apply Subst= to line ~d" ln)))
			 ((eq k2 'EQN)
			  (list -1 'REFL-EQS-KID a node-a))
			 (t nil)))
	       (list -1 'REFL-EQS a node-a)))
	    (EQNGOAL
	     (if (eq node-type 'REFL-EQS)
		 (let* ((eqns (nth 4 node-a))
			(eqnnode (caar eqns))
			(k2 (ext-exp-dag-kind eqnnode))
			(arcs2 (ext-exp-dag-arcs eqnnode)))
		   (cond ((eq k2 'DEC) (list -1 'REFL-EQS-DEC a node-a))
			 ((or (and (eq k2 'REW) (eq (ext-exp-dag-rew-just eqnnode) 'EXT=))
			      (and (eq k2 'EQN) (cdr arcs2))
			      (eq k2 'EQNGOAL))
			  (list 18 'REFL-EQS-LEMMA a node-a (format nil "Apply Subst= to line ~d" ln)))
			 ((eq k2 'EQN)
			  (list -1 'REFL-EQS-KID a node-a))
			 (t nil)))
	       (let* ((supp-node (caddr a))
		      (supp-node-a (assoc supp-node eepfl-lines))
		      (supp-node-line (cadr supp-node-a))
		      (wff2 (line-assertion line))
		      (lwff2 (cdar wff2))
		      (rwff2 (cdr wff2))
		      (wff1 (line-assertion supp-node-line))
		      (lwff1 (cdar wff1))
		      (rwff1 (cdr wff1)))
		 (cond ((wffeq-ab wff1 wff2)
			(list -2 'SAME-AB a node-a))
		       ((and (wffeq-ab lwff1 rwff2) (wffeq-ab rwff1 lwff2))
			(list -2 'SYM-AB a node-a))
		       ((cdr arcs)
			(list 20 'INDIRECT a node-a (format nil "Apply Indirect to line ~d" ln)))
		       (t
			(list 20 'EUNIF a node-a (format nil "Apply Subst= to line ~d" ln)))))))
	    (ATOM
	     (if (eq node-type 'MATE-EQS)
		 (let* ((eqns (nth 4 node-a))
			(eqnnode (caar eqns))
			(supp-line (nth 3 node-a))
			(k2 (ext-exp-dag-kind eqnnode))
			(arcs2 (ext-exp-dag-arcs eqnnode)))
		   (cond ((eq k2 'DEC) (list -1 'MATE-EQS-DEC a node-a))
			 ((or (and (eq k2 'REW) (eq (ext-exp-dag-rew-just eqnnode) 'EXT=))
			      (and (eq k2 'EQN) (cdr arcs2))
			      (eq k2 'EQNGOAL))
			  (list 18 'MATE-EQS-LEMMA a node-a (format nil "Apply Subst= to line ~d" (linealias supp-line))))
			 ((eq k2 'EQN)
			  (list -1 'MATE-EQS-KID a node-a))
			 (t nil)))
	       (let* ((supp-node (caddr a))
		      (supp-node-a (assoc supp-node eepfl-lines))
		      (supp-node-line (cadr supp-node-a))
		      (wff2 (line-assertion line))
		      (wff1 (line-assertion supp-node-line)))
		 (cond ((wffeq-ab wff1 wff2)
			(list -2 'SAME-AB a node-a))
		       ((cdr arcs)
			(list 20 'INDIRECT a node-a
			      (format nil "Apply Indirect to line ~d" ln)))
		       (t
			(list 19 'MATE-EQS a node-a (format nil "Show lines ~d and ~d are the same up to equations"
							    (linealias supp-node-line) ln)))))))))
      (let ((nln (linealias node-line)))
	(if pos
	    (case k
	      (FALSE (list -2 'ABSURD a node-a))
	      (EXP (list 7 'UI a node-a (format nil "Apply UI to line ~d" nln)))
	      (SEL
	       (if (cdr arcs)
		   nil
		 (list 5 'RULEC a node-a (format nil "Apply RuleC to line ~d" nln))))
	      (CON
	       (list 12 'ECONJ a node-a (format nil "Apply EConj to line ~d" nln)))
	      (REW
	       (case (ext-exp-dag-rew-just node)
		 (LAMBDA (list 1 'LCONTR* a node-a (format nil "Lambda reduce line ~d" nln)))
		 (EQUIVWFFS (list 1 'SEQUIVWFFS a node-a (format nil "Apply Equivwffs to line ~d" nln)))
		 (EXT= 
		  (let* ((eqwff (line-assertion node-line))
			 (tp (unabbreviated-type (cdr eqwff))))
		    (cond ((wffeq-ab (cdar eqwff) (cdr eqwff))
			   (list -2 'SWITCH-CONC a node-a))
			  ((consp tp)
			   (list 4 'SFUNCEXT a node-a (format nil "Apply Functional Ext to line ~d" nln)))
			  (t
			   (list 4 'SBOOLEXT a node-a (format nil "Apply Boolean Ext to line ~d" nln))))))
		 (EQUIV-IMPLICS
		  (list 4 'EQUIV-IMPLICS a node-a (format nil "Apply Equiv-Implics to line ~d" nln)))
		 (EQUIV-DISJS
		  (list 4 'EQUIV-CONJ a node-a (format nil "Apply EquivConj to line ~d" nln)))
		 (t nil)))
	      (NEG (list -1 'DEEPEN a node-a))
	      (IMP
	       (let* ((kid1 (ext-exp-arc-node (car arcs)))
		      (eepfl-lines2 (remove node-a eepfl-lines :test #'equal))
		      (eepfl-lines3 (remove-if #'(lambda (x) (eq (cadr x) 'CONC)) eepfl-lines2)))
		 (if (ext-exp-dag-complete-l (cons kid1 (mapcar #'car eepfl-lines3)) banned)
		     (list 19 'MP a node-a (format nil "Apply MP to line ~d" nln))
		   (list 21 'INDIRECT-MP a node-a (format nil "Apply Indirect to line ~d followed by applying MP to line ~d" ln nln)))))
	      (DIS
	       (list 7 'CASES a node-a (format nil "Apply Cases to line ~d" nln)))
	      (t nil))
	  (if (or (eq node-type 'NEG) ; already did pushneg or don't need to
		  (not (member k '(TRUE FALSE NEG EXP SEL IMP DIS CON))))
	      (if (eq (car a) 'DONE)
		  (case k
		    (TRUE (list -2 'ABSURD a node-a))
		    ((EQN DEC)
		     (list -2 'SWITCH-CONC a node-a))
		    (t nil))
		(case k
		  (NEG (list -1 'DEEPEN a node-a))
		  (EXP (list 7 'UI a node-a (format nil "Apply UI to line ~d" nln)))
		  (SEL 
		   (if (cdr arcs)
		       nil
		     (list 5 'RULEC a node-a (format nil "Apply RuleC to line ~d" nln))))
		  ((DIS IMP)
		   (list 12 'ECONJ a node-a (format nil "Apply EConj to line ~d" nln)))
		  (CON (list 7 'CASES a node-a (format nil "Apply Cases to line ~d" nln)))
		  (REW
		   (case (ext-exp-dag-rew-just node)
		     (LAMBDA (list 1 'LCONTR* a node-a (format nil "Lambda reduce line ~d" nln)))
		     (EQUIVWFFS (list 1 'SNEQUIVWFFS a node-a (format nil "Apply Equivwffs to line ~d" nln)))
		     (t (list 16 'SWITCH-CONC a node-a (format nil "Apply Eneg to line ~d" nln)))))
		  (EQN (list -1 'DEEPEN a node-a))
		  ((DEC EQNGOAL ATOM) 
		   (let ((wght (if (find-if #'(lambda (x) (eq (cadr x) 'CONC)) eepfl-lines)
				   (if (cdr arcs) 23 21)
				 (if (cdr arcs) 22 16))))
		     (list wght 'SWITCH-CONC a node-a (format nil "Apply Eneg to line ~d" nln))))))
	    (list 15 'PUSHNEG a node-a (format nil "Apply PushNeg to line ~d" nln))))))))
		  
(defun edag-nat-introduce-lemmas (pline neglems poslems lemmas clist)
  (when lemmas
    (let ((ret nil))
      (when (eed-essential-p 
	     (if (cdr lemmas)
		 (car (etree-components poslems))
	       poslems))
	(if (numalias 1)
	    (introduce-gap (numalias 1) 2)
	  (if (numalias 2)
	      (introduce-gap (numalias 2) 1)))
	(let* ((poslem (if (cdr lemmas)
			   (ext-exp-arc-node (car (ext-exp-dag-arcs poslems)))
			 poslems))
	       (neglem (if (cdr lemmas)
			   (car (ftree-components neglems))
			 neglems))
	       (sh (ext-exp-dag-shallow poslem)))
	  (comdecode (list 'cl-user::lemma (linealias pline) 2 (list 'quote sh)
			   '$ '$ nil))
	  (comdecode (list 'cl-user::same 2 1 '$ '$ '$))
	  (let ((lpline (numalias 1))
		(lsline (numalias 2)))
	    (push (cons poslem lsline) ret)
	    (ftree-to-etree neglem)
	    (auto::start-new-mating)
	    (dolist (conn clist)
	      (let ((n1 (find-etree-node-name (car conn) current-topnode))
		    (n2 (find-etree-node-name (cdr conn) current-topnode)))
		(when (and n1 n2)
		  (push (cons n1 n2) (mating-clist active-mating)))))
	    (merge-tree)
	    (setf (line-mating lpline) clist)
	    (setf (line-node lpline) current-topnode)
	    (when (cdar lemmas)
	      (let ((lneglems (car (etree-components current-topnode)))
		    (lposlems (car (etree-components (cadr (etree-components current-topnode))))))
		(setf (line-node lpline)
		      (cadr (etree-components (cadr (etree-components current-topnode)))))
		(etr-nat-introduce-lemmas
		 lpline lneglems lposlems (cdar lemmas) 'ML::COMPLETE-TRANSFORM-TAC 'AUTO)))
	    (apply-tactic default-tactic :use 'etree-nat :mode 'AUTO :goal lpline))))
      (when (cdr lemmas)
	(setq ret (append ret
			  (edag-nat-introduce-lemmas pline
						     (cadr (ftree-components neglems))
						     (ext-exp-arc-node (cadr (ext-exp-dag-arcs poslems)))
						     (cdr lemmas) clist))))
      ret)))

(defun edag-nat-assert-lemmas (pline neglems poslems lemmas clist)
  (when lemmas
    (let ((ret nil)
	  (save-dproof dproof)
	  (poslem (if (cdr lemmas)
		      (ext-exp-arc-node (car (ext-exp-dag-arcs poslems)))
		    poslems)))
      (when (eed-essential-p poslem)
	(when (numalias 1)
	  (introduce-gap (numalias 1) 1))
	(let* ((neglem (if (cdr lemmas)
			   (car (ftree-components neglems))
			 neglems))
	       (sh (ext-exp-dag-shallow poslem))
	       (lpf (caar lemmas)) ; symbol giving the name of the lemma
	       (lline (gensym)))
	  (comdecode (list 'cl-user::lemma (linealias pline) 1 (list 'quote sh)
			   '$ '$ nil))
	  (setf (line-justification (numalias 1)) (list (format nil "Assert: ~d" lpf)
							nil nil))
	  (setf (proof-plans dproof) 
		(remove (list (numalias 1)) (proof-plans dproof) :test #'equal))
	  (push (cons poslem (numalias 1)) ret)
	  (setq dproof lpf)
	  (ftree-to-etree neglem)
	  (auto::start-new-mating)
	  (dolist (conn (append clist (line-mating pline)))
	    (let ((n1 (find-etree-node-name (car conn) current-topnode))
		  (n2 (find-etree-node-name (cdr conn) current-topnode)))
	      (when (and n1 n2)
		(push (cons n1 n2) (mating-clist active-mating)))))
	  (merge-tree)
	  (setf (proof-assertion dproof) sh)
	  (setf (proof-lines dproof) nil)
	  (setf (proof-linealiases dproof) nil)
	  (setf (proof-plans dproof) nil)
	  (setf (nextplan-no dproof) 1)
	  (push lpf core::*dproof-list*)
	  (setf (line-justification lline) (nextplan))
	  (setf (line-assertion lline) sh)
	  (setf (line-linenumber lline) 100)
	  (setf (line-node lline) current-topnode)
	  (setf (line-mating lline) (append clist (line-mating pline)))
	  (setf (proof-linealiases dproof) (acons 100 lline nil))
	  (setf (proof-lines dproof) (list lline))
	  (push (list lline) (proof-plans dproof))
	  (when (cdar lemmas) ; the lemma depends on other lemmas
	    (let ((lneglems (car (etree-components current-topnode)))
		  (lposlems (car (etree-components (cadr (etree-components current-topnode))))))
	      (setf (line-node lline)
		    (cadr (etree-components (cadr (etree-components current-topnode)))))
	      (etr-nat-assert-lemmas
	       lline lneglems lposlems (cdar lemmas) 'ML::COMPLETE-TRANSFORM-TAC 'AUTO)))
	  (find-all-gaps)
	  (apply-tactic default-tactic :use 'etree-nat :mode 'auto :goal lline)
	  (unless (proof-plans dproof)
	     ; cebrown 6/18/2002 - make-nice, but don't call PALL unless printlineflag is T
	    (cleanup) (remove-unnecessary-gaps)
	    (when printlineflag (pall)))
	  (setq dproof save-dproof)))
      (when (cdr lemmas)
	(setq ret (append ret
			  (edag-nat-assert-lemmas pline
						  (cadr (ftree-components neglems))
						  (ext-exp-arc-node (cadr (ext-exp-dag-arcs poslems)))
						  (cdr lemmas) clist))))
      ret)))



