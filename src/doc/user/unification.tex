\chapter{Unification}
There's a separate top-level for unification. In this
chapter we assume familiarity with Huet's paper on higher-order unification.
We'll follow the notation used in that paper.

The main data structure associated with the unification top-level is the
{\tt unification tree}. The set\footnote{Actually this should be a multiset as
no attempt is made to eliminate elements which are repeated. But for notational
convenience, we'll assume that we have a set. This does not affect the
unifiers, but just adds a certain amount of redundancy in the computation.}
of disagreement pairs at the root node of this
tree is the unification problem associated with the tree. A leaf node is a node
with no sons, while a terminal node is a node which is either a success node or
a failure node.

This top-level can be used for building unification trees in interactive mode,
automatic mode and combinations of these modes. It provides
facilities for moving through, building, and displaying the unification tree.
It also allows the user to specify substitutions at non terminal leaf nodes.
There are commands for building disagreement sets, and starting new
unification problems. The user is also allowed to add disagreement sets
at arbitrary leaf nodes. Although this modifies the initial unification
problem, it allows one to study the unification problems where new
constraints are added to the initial unification problem in an incremental
way.

One can enter this top-level by using the command
\indexmexpr{UNIFY}. However, if this top-level is entered from
mating-search, it is assumed that the user intends to look at the
unification problem associated with the active mating, and the unification
tree for this top-level is initialized to the unification tree associated with
the active mating. Note that any changes to this tree will affect the solution
to the unification problem for the active mating. Note also that the unification
top level is designed to work with unification trees generated by the MS88
procedures using depth bounds (see below); the path-focused procedures and the
\indexflag{MAX-SUBSTS} procedures (see below) use a slightly  different structure
for their unification trees.

\section{A Few Comments About Higher-Order Unification}
\begin{itemize}
\item In first-order unification substitutions are generated on the basis of the
disagreement set. In higher-order logic on the other hand,
the substitutions are formed in a generate and test fashion using very simple
substitutions.

\item Need to identify mgu's whenever possible.

\item Variables of type higher than type of any variable in the original problem are
introduced.

\item Types of elements in the disagreement pair rise during the process of
generating new disagreement pairs in the call to {\it simpl}. Some redundancy
is introduced by having elements in the binder which are not free in either
element of the disagreement pair.
\end{itemize}

\section{Bounds on Higher-Order Unification}
Since higher-order unification cannot be guaranteed to terminate, it is necessary
to have a way to decide when to abandon the search for a unifier. {\TPS} has two
basic methods for doing this: by the depth of the tree or by the complexity of
the substitutions that are being generated.

\subsection{Depth Bounds}
This method involves choosing a depth below which unification trees will not be
allowed to grow. This depth is governed by the flags \indexflag{MAX-SEARCH-DEPTH} and
\indexflag{MAX-UTREE-DEPTH}. If these depths are set too high (particularly if rigid path
checking is not in use; see the flag \indexflag{RIGID-PATH-CK} for details), then {\TPS} will
waste a lot of time running down useless branches of the unification tree. If they are set too low,
then {\TPS} will not find the unifier at all.

Complicating the depth-bound method (in MS88 only) is the flag \indexflag{MIN-QUICK-DEPTH}. As each
new potential connection is considered, {\TPS} first tries to check whether the connection
itself is unifiable, before adding it to the mating. This is called `quick unification'.
Attempting to unify a single connection all the way down to \indexflag{MAX-SEARCH-DEPTH}
can potentially waste a lot of time, and so the
unification tree is only generated until it branches at a depth below \indexflag{MIN-QUICK-DEPTH}.
(That is to say, it is generated to the depth \indexflag{MIN-QUICK-DEPTH}, if possible,
and then unification continues until the matching routine returns more than one substitution at a
given node, at which point that node is marked as `possibly unifiable' and not unified any further.)
Quick unification of a connection will mark that connection as acceptable if any of the leaves of
the resulting tree are either possibly or definitely unifiable.

The drawbacks of the depth-bound method are that small dpairsets are given as much time and space for
unification as large dpairsets, and that a single connection is very rarely rejected; it would have to
fail outright, or if \indexflag{MIN-QUICK-DEPTH} were equal to \indexflag{MAX-SEARCH-DEPTH} it could be
rejected if it contained no success nodes below \indexflag{MAX-SEARCH-DEPTH}. Of course, merely having a
success node down near \indexflag{MAX-SEARCH-DEPTH} isn't enough; we also need there to be enough space to
unify all the other dpairs of the eventual mating.

The advantages are that depth bounds are more precise than substitution bounds. In the case where a complete
mating has many dpairs, one requiring a large number of substitutions, and many others which can be unified to
arbitrary depth but in fact only need be unified to minimal depth for this problem, it is possible for
the unification tree generated by depth bounds to be much smaller than that generated by substitution bounds.
It seems that there are not many `naturally occurring' cases like this, however.

\subsection{Substitution Bounds}
This method involves setting a maximum number of matching substitutions which can be applied to
a given variable in the initial problem. This is governed by the flag \indexflag{MAX-SUBSTS-VAR}.
For example, if the variable {\it x} occurs in the initial problem, and we make a matching substitution
for it, we will introduce a number of {\it h}-variables {\it h1,...,hn} for which we may then make further substitutions.
We then consider Substs({\it x}), the number of substitutions made for {\it x} by the time we reach a particular
node with a given substitution stack, to be 0 if we never make such a substitution, and
otherwise 1 + Substs({\it h1}) + ... + Substs({\it hn}).

The flag \indexflag{MAX-SUBSTS-VAR} is the maximum value which Substs({\it x}) is allowed to take.
The flag \indexflag{MAX-SUBSTS-QUICK} is the maximum value which it may take during quick unification (see the
previous subsection). Nodes that are about to exceed \indexflag{MAX-SUBSTS-QUICK} but do not exceed
\indexflag{MAX-SUBSTS-VAR} are marked as `possibly unifiable' as above.

Notice that this gives us several advantages over the depth-bound method. Firstly, small dpairsets are given less
space and time than large dpairsets. Secondly, if \indexflag{MAX-SUBSTS-QUICK} equals \indexflag{MAX-SUBSTS-VAR}
then during quick unification we will never get a `possibly unifiable' node; all connections are known to be
either unifiable or not (taken by themselves, of course; a unifiable connection may still never be unifiable
in the context of a complete mating). This allows us to reject individual connections more often, without unifying them
all the way to a large maximum depth bound.

Furthermore, a slightly modified version of a theorem is likely to require the same settings for substitution bounds
as the original problem (on the assumption that the proof is likely to be similar), whereas it will very probably
require different unification bounds. Lastly, substitution bounds take a smaller possible range of values
than depth bounds (we have yet to find a {\TPS} theorem which requires a substitution depth of more than 6).

There are also flags \indexflag{MAX-SUBSTS-PROJ} and \indexflag{MAX-SUBSTS-PROJ-TOTAL}, which restrict the number
of projection substitutions allowed for each variable and the entire problem, respectively. It seems that these
flags have very little effect on the speed of the proof, and may as well remain NIL.

\subsection{Combining the Above}

Any of the flags above may be set to NIL. (Of course, enough of them should be non-NIL that there is no risk of
a unification problem never terminating.) In particular, you can opt to use just depth bounds, or just substitution
bounds; the commands \indexcommand{UNIF-DEPTHS} and \indexcommand{UNIF-NODEPTHS} set the flags for these two cases.
In general, substitution bounds are faster, although there are some examples where a depth bound is useful.

The only two flags above that cannot work together are \indexflag{MIN-QUICK-DEPTH} and \indexflag{MAX-SUBSTS-QUICK}.
In this case, \indexflag{MAX-SUBSTS-QUICK} overrides \indexflag{MIN-QUICK-DEPTH}. In fact,
\indexflag{MAX-SUBSTS-QUICK} overrides a number of the less effective unification flags: see the help message for
more details.

Notice that \indexflag{MAX-SUBSTS-QUICK} has an eccentric value, 0, which means `unify until either the tree
branches or we exceed \indexflag{MAX-SUBSTS-VAR}'. This is occasionally useful, and comparable to
\indexflag{MIN-QUICK-DEPTH} being 1, although it doesn't fit the general description of \indexflag{MAX-SUBSTS-QUICK}
given above.

MS88 unification using \indexflag{MAX-SUBSTS-QUICK} is significantly different to that without it, in
that it is quicker and uses less space, by neglecting to store all the irrelevant parts of the tree. (Unification
for the path-focused procedures does something similar.) The user
will not notice the difference unless he or she enters the Unification top level after an MS88, MS89 or MS91-6
search involving \indexflag{MAX-SUBSTS-QUICK}. To recover a usable unification tree under these circumstances,
enter the unification top level and type \indexcommand{EPROOF-UTREE} followed by MAX-SUBSTS-QUICK NIL and then
GO. A new unification tree will be generated.

\section{Support Facilities}

\subsection{Review}
The subject {\it unification} lists flags that affect the behavior of the
unification commands. See the chapter on {\tt review} commands for details on how
to modify these flags.

\subsection{Saving Disagreement sets}
Disagreement sets can be saved using the facilities provided by the
library top-level. The library object type {\it dpairset} represents set of
disagreement pairs. See chapter \ref{library} for details on how to
save and retrieve library objects.

\section{Unification Tree}
Each node in an MS88 unification tree has the following attributes\footnote{It has
certain other attributes which are convenient for implementation purposes.}:

\begin{description}
\item[dpairs]	 The set of disagreement pairs. Each element of these disagreement pairs
is in head normal form.

\item[print-name]	 A name given to the node for identification purposes.

\item[subst-stack]	 A stack of unit substitutions.

\item[free-vars]	 List of free variables in the disagreement pairs at this node.

\item[sons]	 List of descendents of this node.

\item[depth]	 The depth of this node in the tree. The root is at depth 1.

\item[measure]	 A measure associated with this node. This controls the search strategy
that is being used to find the next node in the unification tree that should
be considered.
\end{description}

In the unification procedures we are discussing, which are associated with MS88, the
entire tree is stored and the nodes of the tree have over 15 attributes, of which
those listed above are the most important.
By contrast, in the unification procedures for path-focused duplication,
the dpairs, sons, substitutions and depth are the only major attributes of a unification
node, and all that is stored is the root node and the currently active leaf nodes, which
are all considered the immediate sons of the root.

\subsection{Node Names}
The root node of this tree is named `0'. The sons of the node with name
`N' are named depending on the number m of sons.

\begin{itemize}
\item If m = 0, then the unique son is named `N-0'

\item else the m sons are named `N-1', ..., `N-m'
\end{itemize}

\subsection{Substitution Stack}
The substitution at any node is maintained as a stack of simpler
substitutions. The composition of the simpler substitutions of this stack
is the substitution associated with that node. Note that there are no
cycles in this stack. Although the user has the option of adding
more substitutions to a stack, the system will not let the user add
substitutions which make this stack cyclic. For example:

\begin{tpsexample}
Assume that the substitution stack has a single element $(x . y)$. The
user will not be allowed to add the substitution \(y \leftarrow x\).
\end{tpsexample}

\section{Simpl}
The command {\tt simpl} is a call to the function {\it simpl} in Huet's algorithm.
Some additions are:

\begin{enumerate}
\item In the presence of the ETA-RULE, we modify the binders and arguments of the
elements of rigid-rigid disagreement pairs so that the binders have the same
length. This way we obviate the necessity of finding eta head normal form,
keep the binder reduced to a certain extent, and do not form some disagreement
pairs which would have been immediately eliminated anyway.

\item As noted by Huet, if \(x \notin FV(e)\) then \(x \leftarrow e\) is a mgu
for this pair of terms, where \(x\) is a variable, \(e\) is a term
of the same type, and \(FV(e)\) denotes the set of variables that are free
in \(e\). We will find substitutions of this kind. We intend to
implement the rigid path check to identify non-unifiable disagreement sets here.

\item When {\it simpl} generates new disagreement pairs, we delete any element in the
binder that does not occur free in one of the elements of the disagreement
pair that is being formed. This allows us to reduce the types of the
disagreement pairs that are generated without any loss of unifiers.
\end{enumerate}


\section{Match}
As noted by Dale Miller, the substitutions generated by {\it match} in the presence
of eta-rule depend only on the {\bf rigid head} and {\bf type of flexible head}.
Hence, the same substitutions can be used at different nodes in the tree.
This may require some renaming of h-vars to assure that the h-vars in these
substitutions do not occur free in a substitution at any ancestor node of the
current node. We generalize this result slightly to handle the case where
eta-rule is not available.

Although our flexible-rigid pairs may not be in eta head normal form,
in the presence of eta-rule
the substitutions generated for these pairs will be exactly those that
would be generated if the pairs were in eta head normal form. This is possible
due to Miller's observation mentioned above.

\section{Comments}
The following modifications aid to identify certain substitutions:

\begin{enumerate}
\item The modifications in {\it simpl} and {\it match} mentioned above
obviate the need to compute eta head normal form, and it suffices to find
the head normal form of elements in the disagreement pairs.
For example, consider the disagreement pair:
$$ (f_{{ii}} , \lambda y_{{i}}  G_{{ii}}^{{n}}  y).$$ 
We can straight away
find the mgu for this dpair. If, however, we convert this to eta head normal
form, then we have to call the unification algorithm to find the unifiers.

\item Reducing the binder during generation of new disagreement pairs. For example,
consider the disagreement pair:
$$(\lambda x_{{i}} f_{{ii}}  , \lambda z_{{i}}\lambda y_{{i}}  G_{{ii}}^{{n}}  y).$$
This reduces to the following disagreement pair:
$$(f_{{ii}}  ,  \lambda y_{{i}}  G_{{ii}}^{{n}}  y)$$
\end{enumerate}

\section{A Session in Unification Top-Level}
\begin{alltt}
<0>{\tt unify}

<Unif0>{\tt ?}
Top Levels:    LEAVE
Unification:   0 APPLY-SUBST GO GOTO MATCH MATCH-PAIR NTH-SON P PALL
               PP SIMPLIFY SUBST-STACK UTREE \(\wedge\) \(\wedge\)\(\wedge\)
Dpairs:        ADD-DPAIR ADD-DPAIRS-TO-NODE ADD-DPAIRS-TO-UTREE
               RM-DPAIR SHOW-DPAIRSET UNIF-PROBLEM

<Unif1>{\tt add-dpairset}
NAME (SYMBOL): Name of set containing dpair [No Default]>{\tt foo}
ELT1 (GWFF): First element [No Default]>{\tt `f x'}
ELT2 (GWFF): Second Element [No Default]>{\tt `A'}

<Unif2>{\tt add-dpairset}
NAME (SYMBOL): Name of set containing dpair [FOO]>
ELT1 (GWFF): First element [No Default]>{\tt `f y'}
ELT2 (GWFF): Second Element [No Default]>{\tt `B'}

<Unif3>{\tt show-dpairset}
NAME (SYMBOL): Name of disagreement set. [FOO]>
f y  .  B
f x  .  A

<Unif4>{\tt unif-problem}
NAME (SYMBOL): Name of disagreement set [FOO]>
FREE-VARS (GVARLIST): List of free variables. [()]>{\tt `f(II)' `x' `y'}

<Unif5>{\tt go}
0  0-1  0-2
Substitution Stack:

\(f   ->    \lambda w^{{0}}  w^{{0}}\)
y   ->   B
x   ->   A

<Unif6> {\tt leave}
\end{alltt}
