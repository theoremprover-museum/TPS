;;; -*- Mode:LISP; Package:AUTO -*-
;;; ******************************************************************* ;;;
;;;         (c) Copyrighted 1988 by Carnegie Mellon University.         ;;;
;;;                        All rights reserved.                         ;;;
;;;         This code was written as part of the TPS project.           ;;;
;;;   If you want to use this code or any part of TPS, please contact   ;;;
;;;               Peter B. Andrews (Andrews@CS.CMU.EDU)                 ;;;
;;; ******************************************************************* ;;;

(in-package :auto)
(part-of etr-nat)

(context etr-nat)

(deffile hx-natree-rulep
  (extension lisp)
  (part-of etr-nat)
  (mhelp "Functions for handling RULEP when translating natural deduction
proofs to expansion proofs."))

(defun break-up-dup-info (etree dup-info)
  (declare (special rulep-table))
  (cond #+comment
	((rewrite-p dup-info)
	 (break-up-dup-info etree (first (etree-components dup-info))))
        ((empty-dup-info-p dup-info))
        ((or (leaf-p etree) (true-p etree) (false-p etree))
	 (setf (gethash (etree-name etree) rulep-table) dup-info))
	((negation-p etree)
	 (break-up-dup-info (first (etree-components etree))
			    (first (etree-components (update-dup-info dup-info)))))
	((rewrite-p etree)
	 (break-up-dup-info (first (etree-components etree)) dup-info))
	((or (econjunction-p etree)
	     (edisjunction-p etree)
	     (implication-p etree))
	 (let ((components (etree-components etree))
	       (new-dup-info (update-dup-info dup-info)))
	   (if (rewrite-p new-dup-info)
	       (break-up-dup-info etree (first (etree-components new-dup-info)))
	     (progn (break-up-dup-info (first components)
				       (first (etree-components new-dup-info)))
		    (break-up-dup-info (second components)
				       (second (etree-components new-dup-info)))))))
	(otherwise (describe dup-info)
		   (throwfail "Unexpected case occurred in break-up-dup-info!"))))

#+comment
(defun break-up-dup-info (etree dup-info)
  (declare (special rulep-table))
  (unless (empty-dup-info-p dup-info)
     (let ((new-dup-info (update-dup-info dup-info)))
       (cond ((and (rewrite-p new-dup-info)
		   (eq (rewrite-justification new-dup-info) 'equiv-implics))
	      (break-up-dup-info etree (first (etree-components new-dup-info))))
	     ((or (leaf-p etree) (true-p etree) (false-p etree))
	      (setf (gethash (etree-name etree) rulep-table) new-dup-info))
	     ((negation-p etree)
	      (break-up-dup-info (first (etree-components etree))
				 (first (etree-components new-dup-info))))
	     ((rewrite-p etree)
	      (break-up-dup-info (first (etree-components etree)) new-dup-info))
	     ((or (econjunction-p etree)
		  (edisjunction-p etree)
		  (implication-p etree))
	      (let ((components (etree-components etree)))
		(break-up-dup-info (first components)
				   (first (etree-components new-dup-info)))
		(break-up-dup-info (second components)
				   (second (etree-components new-dup-info)))))
	     (otherwise (describe new-dup-info)
			(throwfail "Unexpected case occurred in break-up-dup-info!"))))))

(defun put-together-dup-info (etree pos)
  (declare (special init-rulep-table))
  (let ((components (etree-components etree)))
    (cond ((or (leaf-p etree) (true-p etree) (false-p etree))
	   (or (gethash (etree-name etree) init-rulep-table)
	       (empty-dup-info-1 (get-shallow etree) pos)))
	  ((negation-p etree)
	   (let ((son (put-together-dup-info (first components) (not pos))))
	     (if (empty-dup-info-p son)
		 (empty-dup-info-1 (get-shallow etree) pos)
	       (negation-dup-info son pos))))
	  ((rewrite-p etree)
	   (put-together-dup-info (first components) pos))
	  ((econjunction-p etree)
	   (let ((lson (put-together-dup-info (first components) pos))
		 (rson (put-together-dup-info (second components) pos)))
	     (if (and (empty-dup-info-p lson) (empty-dup-info-p rson))
		 (empty-dup-info-1 (get-shallow etree) pos)
	       (econjunction-dup-info lson rson pos))))
	  ((edisjunction-p etree)
	   (let ((lson (put-together-dup-info (first components) pos))
		 (rson (put-together-dup-info (second components) pos)))
	     (if (and (empty-dup-info-p lson) (empty-dup-info-p rson))
		 (empty-dup-info-1 (get-shallow etree) pos)
	       (edisjunction-dup-info lson rson pos))))
	  ((implication-p etree)
	   (let ((lson (put-together-dup-info (first components) (not pos)))
		 (rson (put-together-dup-info (second components) pos)))
	     (if (and (empty-dup-info-p lson) (empty-dup-info-p rson))
		 (empty-dup-info-1 (get-shallow etree) pos)
	       (implication-dup-info lson rson pos))))
	  (otherwise (throwfail "Unexpected case occurred in put-together-dup-info!")))))

(defun outfox-rulep-warning (new-dup-info conn table)
  (unless new-dup-info
	  (msgf "Caught a warning!!!")
	  (msgf conn)
	  (maphash #'(lambda (key val) (msgf key "---->" val)) table)))

(defun rulep-attach-dup-info-to-natree (natree dup-info)
  (display-dup-info dup-info)
  (attach-dup-info-to-natree natree dup-info))

(defun outfox-rulep (natree with-dup-info)
  (let ((support (natree-support natree))
	(heterolist (natree-heterolist natree))
	(homolist (natree-homolist natree))
	(selflist (natree-selflist natree))
	(pos-rulep-table (make-hash-table :rehash-size 1.5 :size 64))
	(neg-rulep-table (make-hash-table :rehash-size 1.5 :size 64))
	rulep-table)
    (declare (special rulep-table))

    (setq rulep-table pos-rulep-table)
    (break-up-dup-info (natree-etree natree) with-dup-info)
    (dolist (sup support)
	    (break-up-dup-info (natree-etree sup) (initialize-dup-info (natree-assertion sup) T)))

;;;now rulep will always be neg-rulep-table
    (setq rulep-table neg-rulep-table)
    (let ((init-rulep-table (make-hash-table :rehash-size 1.5 :size 64)))
      (declare (special init-rulep-table))
      (dolist (conn homolist)
	      (setf (gethash (car conn) init-rulep-table)
		    (gethash (car conn) pos-rulep-table)))
;;;      (display-rulep-tables pos-rulep-table init-rulep-table)
      (dolist (sup support)
	      (rulep-attach-dup-info-to-natree sup (put-together-dup-info (natree-etree sup) T))
	      (break-up-dup-info (natree-etree sup) (natree-dup-info-neg sup))))

    (break-up-dup-info (natree-etree natree)
		       (initialize-dup-info (natree-assertion natree) nil))

    (let ((init-rulep-table (make-hash-table :rehash-size 1.5 :size 64)))
      (declare (special init-rulep-table))
      (dolist (conn homolist)
	      (let ((dup-info (gethash (cdr conn) init-rulep-table))
		    (new-dup-info (gethash (car conn) neg-rulep-table)))
;;;		(outfox-rulep-warning new-dup-info conn pos-rulep-table)
		(setf (gethash (cdr conn) init-rulep-table)
		      (merge-dup-info-lenient dup-info new-dup-info))))
      (dolist (conn heterolist)
	      (let ((dup-info (gethash (cdr conn) init-rulep-table))
		    (new-dup-info (gethash (car conn) pos-rulep-table)))
;;;		(outfox-rulep-warning new-dup-info conn pos-rulep-table)
		(setf (gethash (cdr conn) init-rulep-table)
		      (merge-dup-info-lenient dup-info new-dup-info))))
;;;      (display-rulep-tables neg-rulep-table init-rulep-table)
      (dolist (sup support)
	      (rulep-attach-dup-info-to-natree sup (put-together-dup-info (natree-etree sup) T))
	      (break-up-dup-info (natree-etree sup) (natree-dup-info-neg sup))))

    (let ((init-rulep-table (make-hash-table :rehash-size 1.5 :size 64)))
      (declare (special init-rulep-table))
      (dolist (conn homolist)
	      (let ((dup-info (gethash (car conn) init-rulep-table))
		    (new-dup-info (gethash (cdr conn) neg-rulep-table)))
;;;		(outfox-rulep-warning new-dup-info conn neg-rulep-table)
		(setf (gethash (car conn) init-rulep-table)
		      (merge-dup-info-lenient dup-info new-dup-info))))
      (dolist (sup support)
	      (upward-update-natree sup (put-together-dup-info (natree-etree sup) T))))

    (let ((init-rulep-table (make-hash-table :rehash-size 1.5 :size 64)))
      (declare (special init-rulep-table))
      (dolist (conn heterolist)
	      (let ((dup-info (gethash (car conn) init-rulep-table))
		    (new-dup-info (gethash (cdr conn) neg-rulep-table)))
;;;		(outfox-rulep-warning new-dup-info conn neg-rulep-table)
		(setf (gethash (car conn) init-rulep-table)
		      (merge-dup-info-lenient dup-info new-dup-info))))
      (dolist (conn selflist)
	      (let ((dup-info-a (gethash (car conn) init-rulep-table))
		    (new-dup-info-a (gethash (cdr conn) neg-rulep-table))
		    (dup-info-b (gethash (cdr conn) init-rulep-table))
		    (new-dup-info-b (gethash (car conn) neg-rulep-table)))
		(setf (gethash (car conn) init-rulep-table)
		      (merge-dup-info-lenient dup-info-a new-dup-info-a))
		(setf (gethash (cdr conn) init-rulep-table)
		      (merge-dup-info-lenient dup-info-b new-dup-info-b))))
      (display-rulep-tables neg-rulep-table init-rulep-table)
      (setf (natree-dup-info-neg natree)
	    (put-together-dup-info (natree-etree natree) nil)))))

(defun merge-dup-info-lenient (dup-info new-dup-info)
  (cond ((and (not dup-info) (not new-dup-info)) nil)
	((not dup-info) new-dup-info)
	((not new-dup-info) dup-info)
	(otherwise (merge-dup-info dup-info new-dup-info))))

      
(defun display-rulep-tables (table init-table)
  (msgf "----------------------------------------------------")
  (maphash #'(lambda (key val) (msgf key "---->" val)) table)
  (msgf "----------------------------------------------------")
  (maphash #'(lambda (key val) (msgf key "---->" val)) init-table)
  (msgf "----------------------------------------------------"))

