;;; -*- Mode:LISP; Package:AUTO -*-
;;; ******************************************************************* ;;;
;;;         (c) Copyrighted 1988 by Carnegie Mellon University.         ;;;
;;;                        All rights reserved.                         ;;;
;;;         This code was written as part of the TPS project.           ;;;
;;;   If you want to use this code or any part of TPS, please contact   ;;;
;;;               Peter B. Andrews (Andrews@CS.CMU.EDU)                 ;;;
;;; ******************************************************************* ;;;

(in-package :AUTO)
(part-of EXT-DAGS)

;;;
;;; File: EXT-SEQ-TOP  - cebrown - 5/29/03
;;; Top level for the extensional sequent calculi in Chad E. Brown's thesis.

(deffile ext-seq-top
    (part-of EXT-DAGS)
  (extension clisp)
  (mhelp "Top Level for Extensional Sequent Calculus.  See Chad E. Brown's thesis."))

(context subtoplevels)

(defun extseqcmd-mhelp (keyword category)
  (princ-mhelp keyword category)
  (unless short-help 
    (when *doing-html* (msg " fnord "))
    (msgf "The command format for " keyword " is:" -2 "<EXT-SEQ>" keyword)
    (print-tps-format* keyword " "
		       (+ 5 (length (format nil "~A" keyword)))
		       (get keyword 'extseq-argnames)
		       (get keyword 'extseq-argtypes)
		       nil)))

(defun ext-seq ()
  (let ((old-print-line-gen (get 'generic 'print-line))
	(old-print-line-xterm (get 'xterm 'print-line))
	(comma-infix (get '|,| 'infix)))
    (setf (get 'generic 'print-line) #'print-ext-seq-line-generic)
    (setf (get 'xterm 'print-line) #'print-ext-seq-line-generic)
    (setf (get '|,| 'infix) 4)
    (%catch% (extseqtop)
	     (exit-inferior-top
	      (progn
		(setf (get 'generic 'print-line) old-print-line-gen)
		(setf (get 'xterm 'print-line) old-print-line-xterm)
		(setf (get '|,| 'infix) comma-infix)
		core::expand-catch-throw)))))

(defun extseqtop () 
  (let ((top-prompt-fn #'ext-seq-top-prompt)
	(command-interpreter #'ext-seq-command-interpreter)
	(print-* #'ext-seq-print-*)
	(top-level 'ext-seq-top))
    (declare (special top-prompt-fn command-interpreter print-* top-level command-ctree))
    (secondary-top)))

;;;
;;; The following are the primary and secondary prompts.
;;;

(defun ext-seq-top-prompt (id) (format nil "<EXT-SEQ~A>" id))

(defun ext-seq-print-* (result) (fresh-line) (prin1 result))

(defun ext-seq-command-interpreter (cmd)
  (let ((carcmd (car cmd)))
    (setq core::*retrieve-stack* nil) ; just in case! (of something)
    (cond ((null cmd) nil)
	  ((and (null (cdr cmd)) (atom carcmd))
	   (cond 
	         ((integerp carcmd)
		  (throwfail "Unknown command."))
		 ((and (symbolp carcmd) (get carcmd 'extseqcmd))
		  `(ext-seq-opdecode (quote ,cmd)))
		 ((and (symbolp carcmd) (get carcmd 'mexpr))
		  (if (member carcmd *ext-seq-allowed-mexprs*)
		      `(comdecode (quote ,cmd))
		    (throwfail "Cannot apply " carcmd " in EXT-SEQ top level.")))
		 ((and (symbolp carcmd) (get carcmd 'reviewcmd))
		  `(comdecode (quote ,cmd)))
		 ((and (symbolp carcmd) (get carcmd 'flag))
		  `(comdecode '(setflag ,@cmd)))
		 ((null expertflag)
		  (throwfail "Unknown Command or Flag."))
		 ((and (symbolp carcmd) (boundp carcmd)) carcmd)
		 ((and (symbolp carcmd) (fboundp carcmd)) cmd)
		 ((or (get carcmd 'mhelp) (get carcmd 'mhelp-fn))
		  (msg "Cannot evaluate that... calling HELP " carcmd t t)
		  `(comdecode '(help ,carcmd)))
		 (t  (throwfail ";" carcmd " - Unbound variable."))))
	  ((and expertflag (null (cdr cmd))) carcmd)
	  ((and (symbolp carcmd) (get carcmd 'extseqcmd))
	   `(ext-seq-opdecode (quote ,cmd))) 
	  ((and (symbolp carcmd) (get carcmd 'mexpr))
	   (if (member carcmd *ext-seq-allowed-mexprs*)
	       `(comdecode (quote ,cmd))
	     (throwfail "Cannot apply " carcmd " in EXT-SEQ top level.")))
	  ((and (symbolp carcmd) (get carcmd 'reviewcmd))
	   `(comdecode (quote ,cmd)))
	  ((and (symbolp carcmd) (get carcmd 'flag))
	   `(comdecode '(set ,@cmd)))
	  ((null expertflag)
	   (throwfail "Unknown command."))
	  ((symbolp carcmd)
	   (if (fboundp carcmd) cmd
	       (throwfail ";" carcmd " - Undefined function.")))
	  (t cmd))))

(defun ext-seq-opdecode (command)
  (let ((keyword (car command))
	(dproof (get *current-seqder* 'ext-seq-der))
				  ; we need dproof to be the ext-seq-der associated with
				  ; *current-seqder* for functions like PALL, etc to work, BUT
	mainfn result)            ; we don't want to actually setq dproof to *current-seqder* since if we get thrown
    (declare (special dproof))    ; to the top level, TPS will think the sequent derivation pointed to by dproof is a ND proof.
    (multiple-value-bind
	(internal-arglist external-arglist)
	(prompt-values keyword
		       (copy (cdr command))
		       (get keyword 'extseq-argtypes)
		       (mapcar #'(lambda (x) (declare (ignore x)) nil)
			       (get keyword 'extseq-argtypes))
		       nil
		       (get keyword 'extseq-defaultfns)
		       nil
		       (get keyword 'extseq-argnames)
		       (get keyword 'extseq-arghelp))
      (declare (ignore external-arglist))
      (setq mainfn (or (get keyword 'extseq-mainfns) keyword))
      (%catch% (setq result (apply mainfn internal-arglist))
	       (fail (complain f "Error from " mainfn ".  " 
                               core::expand-catch-throw)
		     (throwfail "Operation aborted.")))
      result)))

(defmexpr ext-seq
  (mainfns ext-seq)
  (mhelp "Enter the EXT-SEQ top level for building and manipulating
extensional sequent derivations (see Chad E. Brown's thesis)."))

(context subtoplevels)

(defextseq leave
  (extseq-mainfns exit-ext-seq)
  (mhelp "Leave EXT-SEQ to the next enclosing top level."))

(defun exit-ext-seq () 
  (%throw% '|[Left EXT-SEQ.]| exit-inferior-top))

(context ext-seq-printing)

(defextseq PALL
  (extseq-mainfns extseq-pall)
  (mhelp "Print all the lines in the current extensional sequent derivation."))

(defun is-ext-seqder-p (a)
  (and a (atom a) (get a 'ext-seq-der) (atom (get a 'ext-seq-der))
       (ext-seq-p (get (get a 'ext-seq-der) 'ext-seq))))

(defun extseq-pall ()
  (if (is-ext-seqder-p *current-seqder*)
      (pall)
    (throwfail "There is no current extensional sequent derivation." t "Use PROVE to start one.")))

(defun print-ext-seq (d s k)
  (declare (ignore k))
  (let ((*standard-output* (make-string-output-stream)))
    (if ftree-seq-verbose
	(let ((g (gensym)))
	  (setf (get g 'ext-seq) d)
	  (pext-seq g))
      (progn
	(format t "~%" (ext-seq-kind d))
	(if (ext-seq-wffs d)
	    (progn
	      (pwff (car (ext-seq-wffs d)))
	      (dolist (wff (cdr (ext-seq-wffs d)))
		(format t " , ")
		(pwff wff)))
	  (format t " . "))))
    (let ((str (get-output-stream-string *standard-output*)))
      (write-string str s)
      (close *standard-output*))))

(defun pext-seq (g)
  (pext-seql g nil nil))

(defun pext-seql (prefix lbd ubd)
  (let ((lit-labels nil))
    (declare (special lit-labels))
    (unless (get prefix 'ext-seq)
      (throwfail prefix " is not the name of an extensional sequent calculus derivation"))
    (let* ((seqder (get prefix 'EXT-SEQ))
	   (seqnode-line-assoc nil)
	   (mainline (gensym))
	   (ext-seq-der (if pseq-use-labels
			    (or (get prefix 'ext-seqder-lab-fake-nd) (gensym))
			  (or (get prefix 'ext-seqder-fake-nd) (gensym))))
	   (*current-seqder* (gentemp))
	   (dproof ext-seq-der)
	   (old-print-line-gen (get 'generic 'print-line))
	   (old-print-line-xterm (get 'xterm 'print-line))
	   (comma-infix (get '|,| 'infix)))
      (declare (special dproof *current-seqder* seqnode-line-assoc mainline))
      (setf (get *current-seqder* 'ext-seq-der) ext-seq-der)
      (setf (nextplan-no ext-seq-der) 1)
      (unwind-protect
	  (progn
	    (setf (get 'generic 'print-line) #'print-ext-seq-line-generic)
	    (setf (get 'xterm 'print-line) #'print-ext-seq-line-generic)
	    (setf (get '|,| 'infix) 4)
	    (if pseq-use-labels
		(if (get prefix 'ext-seqder-lab-fake-nd)
		    (setq lit-labels (get prefix 'ext-seqder-labels))
		  (progn
		    (setf (proof-lines dproof) (list mainline))
		    (setf (get dproof 'linealiases) (list (cons 1 mainline)))
		    (setf (line-linenumber mainline) 1)
		    (setf (get mainline 'ext-seq) seqder)
		    (ext-seqder-to-fake-nd seqder t)
		    (setf (get prefix 'ext-seqder-lab-fake-nd) dproof)
		    (setf (get prefix 'ext-seqder-labels) lit-labels)))
	      (progn
		(unless (get prefix 'ext-seqder-fake-nd)
		  (setf (proof-lines dproof) (list mainline))
		  (setf (get dproof 'linealiases) (list (cons 1 mainline)))
		  (setf (line-linenumber mainline) 1)
		  (setf (get mainline 'ext-seq) seqder)
		  (ext-seqder-to-fake-nd seqder))
		(setf (get prefix 'ext-seqder-fake-nd) dproof)))
	    (if (and lbd ubd)
		(dolist (line (proof-lines dproof))
		  (when (and (>= (line-linenumber line) lbd)
			     (<= (line-linenumber line) ubd))
		    (%prtline line)))
	      (pall)))
	(progn
	  (setf (get 'generic 'print-line) old-print-line-gen)
	  (setf (get 'xterm 'print-line) old-print-line-xterm)
	  (setf (get '|,| 'infix) comma-infix))))
    (when pseq-use-labels
      (print-lit-legend lit-labels))))

; deletes the entire current proof and rebuilds using sequent derivation es from scratch -
; this may result in losing parts of the proof disconnected from es
(defun rebuild-fake-nd-ext-seqder (es)
  (if *current-seqder*
      (let ((seqnode-line-assoc nil)
	    (ext-seq-der (gensym))
	    (mainline (gensym)))
	(declare (special seqnode-line-assoc mainline))
	(setf (get *current-seqder* 'ext-seq-der) ext-seq-der)
	(setf (get ext-seq-der 'ext-seq) es)
	(setf (proof-assertion ext-seq-der) (ext-seq-wffs-to-fake-wff es))
	(setf (nextplan-no ext-seq-der) 1)
	(setf (proof-lines ext-seq-der) (list mainline))
	(setf (get ext-seq-der 'linealiases) (list (cons 1 mainline)))
	(setf (line-linenumber mainline) 1)
	(setf (get mainline 'ext-seq) es)
	(ext-seqder-to-fake-nd es))
    (throwfail "There is no current proof.")))

(defun ext-seq-change-fake-nd-line (line es)
  (let ((mainline line))
    (declare (special mainline))
    (setf (get mainline 'ext-seq) es)
    (ext-seqder-to-fake-nd es)))

; builds an ND style representation of an extensional derivation, using labels for wffs
; if use-labels is T
(defun ext-seqder-to-fake-nd (seqder &optional use-labels)
  (declare (special seqnode-line-assoc mainline))
  (let ((al (assoc seqder seqnode-line-assoc)))
    (if al
	(cdr al)
      (let ((pll (mapcar #'(lambda (es)
			     (ext-seqder-to-fake-nd es use-labels))
			 (ext-seq-prems seqder)))
	    (line nil))
	(if (eq (get mainline 'ext-seq) seqder)
	    (setq line mainline)
	  (let ((newline (gensym))
		(n (linealias mainline)))
	    (setq line newline)
	    (es-introduce-gap mainline 1)
	    (setf (get (get *current-seqder* 'ext-seq-der) 'lines)
		  (apply #'append (mapcar #'(lambda (line)
					      (if (eq line mainline)
						  (list newline mainline)
						(list line)))
					  (get (get *current-seqder* 'ext-seq-der) 'lines))))
	    (setf (get (get *current-seqder* 'ext-seq-der) 'linealiases)
		  (apply #'append (mapcar #'(lambda (num-line)
					      (if (eq (cdr num-line) mainline)
						  (list (cons n newline) num-line)
						(list num-line)))
				      (get (get *current-seqder* 'ext-seq-der) 'linealiases))))
	    (setf (get newline 'linenumber) n)
	    (setf (get newline 'ext-seq) seqder)
	    (push (cons seqder newline) seqnode-line-assoc)))
	(setf (line-assertion line) (ext-seq-wffs-to-fake-wff seqder use-labels))
	(set-extseq-line-justification-1 line seqder pll)
	line))))

(defun print-ext-seq-line-generic (line)
  (let ((hatomalist nil) (curpos 0) justificationlength)
    (declare (special hatomalist))
    (msg "(" (linealias line) ") ") 
    (if (eq turnstile-indent-auto 'compress) 
	(setq curpos (+ curpos 3 (length (princ-to-string (linealias line)))))
      (progn (spaces (- 3 (length (princ-to-string (linealias line)))))
	     (setq curpos 6)))
    (if (eq turnstile-indent-auto 'fix) 
	(progn (if (> curpos turnstile-indent) (progn (msg t) (setq curpos -1)))
	       (indentation turnstile-indent) (setq curpos (1- turnstile-indent)))
      (if (eq turnstile-indent-auto 'min) 
	  (progn (let ((point (1+ (core::figure-out-indent)))) (indentation point) (setq curpos (1- point))))))
    (if (eq turnstile-indent-auto 'compress) (setq curpos (1+ curpos)) (setq curpos (+ 2 curpos)))
    (cond ((not (fixp rightmargin))
	   (setq rightmargin (linewidth))))
    (if (eq turnstile-indent-auto 'compress)
	(setq hatomalist 
	      (prtwff (get line 'assertion)
		      (leftmargin (+ 1 curpos))))
      (setq hatomalist 
	    (prtwff (get line 'assertion)
		    (leftmargin (+ 2 curpos)))))
    (setq justificationlength (justlength (get line 'justification)))
    ;;Call this function after wff has been printed, because the
    ;;variable HATOMALIST is set when the wff is being printed. SI.
    (when (> (+ curpos justificationlength) rightmargin)
      (setq curpos 0)
      (terpri))
    (indentation (1+ (- rightmargin justificationlength)))
    (princjustification (get line 'justification))
    (setq curpos rightmargin)
    (when (and print-comments (get line 'comment) (listp (get line 'comment))) ;if it's a string, it's ""
	  (msg t "   ")
	  (eval (get line 'comment))
	  (msg t)
	  (setq curpos 0))))

(defextseq pstatus
  (extseq-mainfns prtstatus)
  (mhelp "Give the current status of the extensional sequent derivation."))

(defextseq pplan
  (extseq-argtypes pline)
  (extseq-argnames pline)
  (extseq-arghelp "Planned Line")
  (extseq-defaultfns
   (lambda (pline) (list (pline-default pline))))
  (extseq-mainfns pplan)
  (mhelp "Print a planned line"))

(defun esnumalias (num)
  (cdr (assoc num (proof-linealiases (get *current-seqder* 'ext-seq-der)))))

(defun es-nextplan ()
  (let ((dproof (get *current-seqder* 'ext-seq-der)))
    (declare (special dproof))
    (nextplan)))

(defun es-introduce-gap (line num)
  (let ((dproof (get *current-seqder* 'ext-seq-der)))
    (declare (special dproof))
    (introduce-gap line num)))

(context ext-seq-entering)
; finish cleanup

(defextseq prove
  (extseq-argtypes gwff0-or-label symbol line)
  (extseq-argnames wff prefix num)
  (extseq-arghelp "Prove Wff" "Name of Derivation" "Line Number for main sequent")
  (extseq-defaultfns
    (lambda (pgwff &rest rest)
      (cons pgwff
	    (mapcar #'(lambda (argdefault arg) (if (eq arg '$) argdefault arg))
		    (list (if (label-p pgwff) pgwff 
			    (if (and (boundp '*last-gwff-typed*) 
				     *last-gwff-typed* (symbolp *last-gwff-typed*)) *last-gwff-typed*
			      '$)) 100)
		    rest))))
  (extseq-mainfns extseq-prove)
  (mhelp "Start a sequent calculus derivation for a sequent with one wff.
Use WEAKEN to add more wffs to the main sequent."))

(defun extseq-prove (wff prefix num)
  (let ((es (make-ext-seq :wffs (list wff)))
	(ext-seq-der (gensym))
	(line (gentemp)))
    (setq *current-seqder* prefix)
    (setf (get prefix 'ext-seq-der) ext-seq-der)
    (setf (get ext-seq-der 'ext-seq) es)
    (setf (get line 'ext-seq) es)
    (setf (get ext-seq-der 'gwff-name) 
      (if (symbolp *last-gwff-typed*)
	  *last-gwff-typed*
	nil))
    (setq *extseqder-list* (adjoin prefix *extseqder-list*))
    (setf (proof-assertion ext-seq-der) wff)
    (setf (nextplan-no ext-seq-der) 1)
    (setf (proof-linealiases ext-seq-der) (list (cons num line)))
    (setf (proof-plans ext-seq-der) (list (list line)))
    (setf (proof-lines ext-seq-der) (list line))
    (setf (line-assertion line) wff)
    (setf (line-justification line) (es-nextplan))
    (setf (line-linenumber line) num)
    (es-find-all-gaps)
    (signal-event 'proof-action 'started)
    line))

(defun set-extseq-line-assertion (line es)
  (when (ext-seq-p es)
    (setf (line-assertion line) (ext-seq-wffs-to-fake-wff es))))

(defun ext-seq-wffs-to-fake-wff (seqder &optional use-labels)
  (let ((neg-labs (if (= (length (ext-seq-wffs seqder)) 1)
		      (ext-seq-wffs seqder)
		    (if use-labels
			(mapcar #'ftree-seq-label-wff
				(ext-seq-wffs seqder))
		      (ext-seq-wffs seqder)))))
    (if neg-labs
	(do ((neg-labs2 (cdr neg-labs) (cdr neg-labs2))
	     (w (car neg-labs) (acons '|,| w (car neg-labs2))))
	    ((null neg-labs2) w))
      '|.|)))

(defun update-extseq-proof-plans (oldplan newplans)
  (let ((supps (cdr (assoc oldplan (proof-plans (get *current-seqder* 'ext-seq-der))))))
    (setf (proof-plans (get *current-seqder* 'ext-seq-der))
	  (remove-if #'(lambda (x)
			 (eq (car x) oldplan))
		     (proof-plans (get *current-seqder* 'ext-seq-der))))
    (dolist (newplan (reverse newplans))
      (let ((es (get newplan 'ext-seq)))
	(when (ext-seq-p es)
	  (unless (or (ext-seq-kind es)
		      (assoc newplan (proof-plans (get *current-seqder* 'ext-seq-der))))
	    (push (cons newplan supps) (proof-plans (get *current-seqder*'ext-seq-der)))))))))

(defextseq weaken
  (extseq-argtypes gwff0-or-label)
  (extseq-argnames wff)
  (extseq-arghelp "Wff to add to Sequents")
  (extseq-defaultfns
    (lambda (pgwff)
      (list (if (eq pgwff '$)
		(if (label-p pgwff) pgwff 
		  (if (and (boundp '*last-gwff-typed*) 
			   *last-gwff-typed* (symbolp *last-gwff-typed*)) *last-gwff-typed*
		    '$))
	      pgwff))))
  (extseq-mainfns extseq-weaken)
  (mhelp "Weaken the sequent calculus derivation by adding a wff."))

(defun extseq-weaken (wff)
  (if (is-ext-seqder-p *current-seqder*)
      (dolist (line (proof-lines (get *current-seqder* 'ext-seq-der)))
	(let ((es (get line 'ext-seq)))
	  (when (ext-seq-p es)
	    (push wff (ext-seq-wffs es))
	    (set-extseq-line-assertion line es))))
    (throwfail "There is no current extensional sequent derivation." t "Use PROVE to start one.")))

(defextseq squeeze
  (extseq-mainfns remove-unnecessary-gaps)
  (mhelp "Removes unnecessary gaps from the sequent derivation."))

;(defextseq cleanup
;  (extseq-mainfns extseq-cleanup)
;  (mhelp "Lines that contain the same sequent are combined."))

(defun extseq-cleanup ()
  (if (is-ext-seqder-p *current-seqder*)
      (let ((complete-lines (extseq-complete-lines (proof-lines (get *current-seqder* 'ext-seq-der))
						   (mapcar #'car (proof-plans (get *current-seqder* 'ext-seq-der)))))
	    (line-assoc nil))
	(do ((lines (reverse (proof-lines (get *current-seqder* 'ext-seq-der))) (cdr lines)))
	    ((null lines))
	  (let* ((line (car lines))
		 (es (get line 'ext-seq))
		 (wffs (when (ext-seq-p es) (ext-seq-wffs es)))
		 (repl (when (ext-seq-p es)
			 (find-if #'(lambda (x)
				      (and (member x complete-lines)
					   (ext-seq-p (get x 'ext-seq))
					   (wffeq-ab-multiset wffs (ext-seq-wffs (get x 'ext-seq)))))
				  (cdr lines)))))
	    (when repl
	      (push (cons line repl) line-assoc))))
	; ???? fix this
	
	)
    (throwfail "There is no current extensional sequent derivation." t "Use PROVE to start one.")))

(defun extseq-complete-lines (lines plans)
  (let ((complete-lines nil))
    (dolist (line lines)
      (when (and (not (member line plans))
		 (not (find-if-not #'(lambda (prem)
				       (member prem complete-lines))
				   (caddr (line-justification line)))))
	(push line complete-lines)))
    complete-lines))

(defextseq introduce-gap
  (extseq-argtypes existing-line posinteger)
  (extseq-argnames line num)
  (extseq-arghelp "Line where gap is to be introduced" "Increment")
  (extseq-defaultfns 
   (lambda (&rest rest)
     (mapcar #'(lambda (argdefault arg) (if (eq arg '$) argdefault arg))
	     '($ 10) rest)))
  (extseq-mainfns es-introduce-gap)
  (mhelp "Introduce a gap in an existing derivation."))

(defextseq delete
  (extseq-argtypes existing-linelist)
  (extseq-argnames core::del-lines)
  (extseq-arghelp "delete lines")
  (extseq-mainfns dellines)
  (mhelp "Delete Lines in an existing derivation"))

(defextseq prooflist
  (extseq-mainfns extseq-prooflist)
  (mhelp "Print a list of all extensional sequent derivations or partial derivations currently in memory.
Also prints the final sequent of each proof."))

(defun extseq-prooflist ()
  (dolist (x *extseqder-list*)
    (msgf x " : " ((proof-assertion (get x 'ext-seq-der)) . gwff))))

(defextseq reconsider 
  (extseq-argtypes symbol)
  (extseq-argnames prefix)
  (extseq-arghelp "Name of Derivation")
  (extseq-defaultfns 
   (lambda (&rest rest)
     (mapcar #'(lambda (argdefault arg) (if (eq arg '$) argdefault arg))
	     '($) rest)))
  (extseq-mainfns extseq-reconsider)
  (mhelp ("Reconsider an extensional sequent derivation. The following proofs are in memory:" t
(l *extseqder-list*)
t "For more details, use the PROOFLIST command." t t)))

(defun extseq-reconsider (prefix)
  (declare (special *current-seqder*))
  (if (is-ext-seqder-p prefix)
      (setq *current-seqder* prefix)
    (throwfail "Please use PROVE to start a new extensional sequent derivation.")))

(context ext-seq-rules)

(defun extseq-defaultplan (fn)
  (declare (special *current-seqder*))
  (if (is-ext-seqder-p *current-seqder*)
      (do ((p (proof-plans (get *current-seqder* 'ext-seq-der)) (cdr p)))
	  ((or (null p)
	       (and (ext-seq-p (get (caar p) 'ext-seq))
		    (find-if fn (ext-seq-wffs (get (caar p) 'ext-seq)))))
	   (if p
	       (linealias (caar p))
	     '$)))
    '$))

(defun extseq-defaultplan-2 (fn1 fn2)
  (if (is-ext-seqder-p *current-seqder*)
      (do ((p (proof-plans (get *current-seqder* 'ext-seq-der)) (cdr p)))
	  ((or (null p)
	       (let ((es (get (caar p) 'ext-seq)))
		 (and (ext-seq-p es)
		      (let ((wffs (ext-seq-wffs es)))
			(find-if 
			 #'(lambda (x)
			     (and (funcall fn1 x)
				  (find-if #'(lambda (y) (funcall fn2 x y)) wffs)))
			 wffs)))))
	   (if p
	       (linealias (caar p))
	     '$)))
    '$))

(defun extseq-defaultnewplan (num)
  (if (numberp num)
      (do ((n (- num 1) (- n 1)))
	  ((or (< n 1) (not (esnumalias n)))
	   (if (< n 1) '$ n)))
    '$))

(defun extseq-defaultnewplans (num i)
  (if (and (numberp num) (> i 0))
      (let ((ln (esnumalias num))
	    (min nil))
	(dolist (gap (get (get *current-seqder* 'ext-seq-der) 'gaps))
	  (when (eq ln (get gap 'core::max-label))
	    (setq min (1+ (linealias (get gap 'core::min-label))))))
	(if min
	    (let* ((d1 (- num min))
		   (d2 (floor (/ d1 i)))
		   (newplans nil))
	      (if (>= d2 1)
		  (dotimes (j i newplans)
		    (push (- num (1+ (* j d2))) newplans))
		(make-list i :initial-element '$)))
	  (let ((newplans nil))
	    (do ((n (- num 1) (- n 1)))
		((or (< n 1) (= (length newplans) i))
		 (if (< n 1)
		     (append (make-list (- i (length newplans))
					:initial-element '$)
			     newplans)
		   newplans))
	      (unless (esnumalias n)
		(push n newplans))))))
    (make-list i :initial-element '$)))

(defun set-extseq-line-justification (line seqder)
  (if (ext-seq-kind seqder)
      (let ((prems (ext-seq-prems seqder))
	    (pll nil))
	(dolist (prem prems)
	  (let ((l (find-if #'(lambda (x)
				(eq (get x 'ext-seq) prem))
			    (proof-lines (get *current-seqder* 'ext-seq-der)))))
	    (if l
		(push l pll)
	      (throwfail "Missing Premiss for line " (esnumalias line)))))
	(set-extseq-line-justification-1 line seqder (reverse pll)))
    (setf (get line 'justification) (es-nextplan))))
	      
(defun set-extseq-line-justification-1 (line seqder pll)
  (setf (get line 'justification)
	(case (ext-seq-kind seqder)
	  (TRUE
	   (list "TRUE" nil nil))
	  (NEG
	   (list "NEG" nil pll))
	  (REW
	   (list (format nil "~d~d"
			 (ext-seq-rew-just seqder)
			 (if (ext-seq-pos-rule seqder) "+" "-"))
		 nil pll))
	  (DIS
	   (if (ext-seq-pos-rule seqder)
	       (list "OR+" nil pll)
	     (list "OR-" nil pll)))
	  (FORALL
	   (if (ext-seq-pos-rule seqder)
	       (list "ALL+" (list (ext-seq-sel-var seqder)) pll)
	     (list "ALL-" (list (ext-seq-exp-term seqder)) pll)))
	  (INTERNALIZE
	   (if (ext-seq-pos-rule seqder)
	       (list "INTERNALIZE+" nil pll)
	     (list "INTERNALIZE-" nil pll)))
	  (EQFUNC
	   (list "EQFUNC" (list (ext-seq-exp-term seqder)) pll))
	  (EXTFUNC
	   (list "EXTFUNC" (list (ext-seq-sel-var seqder)) pll))
	  ((INITEQ DEC EUNIF1 EUNIF2 EQO EXTO)
	   (list (format nil "~d" (ext-seq-kind seqder)) nil pll))
	  (t
	   (list (format nil "~d" (ext-seq-kind seqder)) nil pll))))
  (es-nextplan))

(defun new-extseq-line (num es)
  (let ((l (gentemp)))
    (setf (line-linenumber l) num)
    (setf (proof-lines (get *current-seqder* 'ext-seq-der))
	  (sort (cons l (proof-lines (get *current-seqder* 'ext-seq-der)))
		#'lineordering))
    (push (cons num l) (proof-linealiases (get *current-seqder* 'ext-seq-der)))
    (set-extseq-line-assertion l es)
    (unless (ext-seq-kind es)
      (setf (line-justification l) (es-nextplan)))
    (setf (get l 'ext-seq) es)
    (when (= num (apply #'max (mapcar #'car (proof-linealiases (get *current-seqder* 'ext-seq-der)))))
      (setf (proof-assertion (get *current-seqder* 'ext-seq-der)) (line-assertion l))
      (setf (get (get *current-seqder* 'ext-seq-der) 'ext-seq) es))
    l))

(defun extseq-choose-princ-wff (fn wffs &optional (m "Choose Principal Formula:"))
  (let ((princ-wff-choices (remove-duplicates (remove-if-not fn wffs) :test #'wffeq)))
    (if princ-wff-choices
	(if (cdr princ-wff-choices)
	    (let ((n (length princ-wff-choices)))
	      (msgf m)
	      (dotimes (i n)
		(msgf (1+ i) " : " ((nth i princ-wff-choices) . gwff)))
	      (nth (- (core::get-a-number n) 1) princ-wff-choices))
	  (car princ-wff-choices))
      (throwfail "No Possible Principal Formula for Rule"))))

(defun extseq-choose-prem-wff (fn wffs &optional (m "Choose Premiss Formula:"))
  (let ((wff-choices (remove-duplicates (remove-if-not fn wffs) :test #'wffeq)))
    (if wff-choices
	(if (cdr wff-choices)
	    (let ((n (length wff-choices)))
	      (msgf m)
	      (dotimes (i n)
		(msgf (1+ i) " : " ((nth i wff-choices) . gwff)))
	      (nth (- (core::get-a-number n) 1) wff-choices))
	  (car wff-choices))
      (throwfail "No Possible Premiss Formula for Rule"))))

(defextseq dneg
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with ~~A" "Line with A")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (not-p (cdr x)))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-dneg)
  (mhelp "Infer (p2) Gamma,~~A from (p1) Gamma,A"))

; one premiss, one premiss wff
(defun extseq-rule-1-1 (p2 p1 pwff princfn premfn princtopremfn premtoprincfn setkind)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq))))
    (if (ext-seq-p es2)
	(let* ((wffs (ext-seq-wffs es2))
	       (princ-wff (or pwff (extseq-choose-princ-wff princfn wffs)))
	       (gam (multiset-extract-wffs (ext-seq-wffs es2) princ-wff)))
	  (if (ext-seq-p es1)
	      (let ((wffs1 (ext-seq-wffs es1)))
		(unless (wffeq-ab-multiset gam (multiset-extract-wffs wffs1 (funcall princtopremfn princ-wff)))
		  (throwfail "Gammas do not match")))
	    (progn
	      (setq es1 (make-ext-seq :wffs (cons (funcall princtopremfn princ-wff) gam)))
	      (setq l1 (new-extseq-line p1 es1))))
	  (funcall setkind l2 l1 princ-wff)
	  (update-extseq-proof-plans l2 (list l1))
	  (es-find-all-gaps))
      (if (ext-seq-p es1)
	  (let* ((wffs (ext-seq-wffs es1))
		 (prem-wff (if pwff
			       (funcall princtopremfn pwff)
			     (extseq-choose-prem-wff premfn wffs)))
		 (princ-wff (or pwff (funcall premtoprincfn prem-wff)))
		 (es2 (make-ext-seq :wffs (cons princ-wff
						(multiset-extract-wffs wffs prem-wff))))
		 (l2 (new-extseq-line p2 es2)))
	    (funcall setkind l2 l1 princ-wff)
	    (es-find-all-gaps))
	(let ((princ-wff nil)
	      (gam nil)
	      (wff nil)
	      (gamlen nil))
	  (if pwff
	      (setq princ-wff pwff)
	    (prompt-read princ-wff nil
			 (msgf "Enter Principal Wff")
			 'gwff0 '$ ((? (msgf "Principal Formula of Rule"))
				    (?? (mhelp 'gwff0)))))
	  (unless (funcall princfn princ-wff)
	    (throwfail "Invalid Principal Formula for Rule"))
	  (prompt-read gamlen nil
		       (msgf "Enter the number of Wffs in Gamma")
		       'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				    (?? (mhelp 'integer+))))
	  (dotimes (i gamlen)
	    (prompt-read wff nil
		       (msgf "Enter a Side Wff")
		       'gwff0 '$ ((? (msgf "Side Wff"))
				  (?? (mhelp 'gwff0))))
	    (push wff gam))
	  (let* ((prem-wff (funcall princtopremfn princ-wff))
		 (es1 (make-ext-seq :wffs (cons prem-wff gam)))
		 (es2 (make-ext-seq :wffs (cons princ-wff gam)))
		 (l1 (new-extseq-line p1 es1))
		 (l2 (new-extseq-line p2 es2)))
	    (funcall setkind l2 l1 princ-wff)
	    (es-find-all-gaps))))))
  nil)

(defun extseq-dneg (p2 p1 &optional pwff)
  (extseq-rule-1-1 p2 p1 pwff
		   #'(lambda (x) (and (not-p x) (not-p (cdr x))))
		   #'(lambda (x) (declare (ignore x)) t)
		   #'(lambda (x) (cddr x))
		   #'(lambda (x) (cons 'NOT (cons 'NOT x)))
		   #'(lambda (l2 l1 princ-wff)
		       (let ((es1 (get l1 'ext-seq))
			     (es2 (get l2 'ext-seq)))
			 (setf (line-justification l2) (list "NEG" nil (list l1)))
			 (setf (ext-seq-kind es2) 'NEG)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-prems es2) (list es1))))))

(defextseq lam
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with Expanded Wff" "Line with Normal Wff")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (not (wffeq-ab (etanorm (lambda-norm x)) x))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-lam)
  (mhelp "Infer (p2) Gamma,A from (p1) Gamma,N where N is the lambda normal form of A"))

(defun extseq-lam (p2 p1 &optional pwff)
  (extseq-rule-1-1 p2 p1 pwff
		   #'(lambda (x) (not (wffeq-ab (etanorm (lambda-norm x)) x)))
		   #'(lambda (x) (declare (ignore x)) t)
		   #'(lambda (x) (etanorm (lambda-norm x)))
		   #'(lambda (x)
		       (let ((wff nil))
			 (prompt-read wff nil
				      (msgf "Lambda Expanded Wff")
				      'gwff0 '$ ((? (msgf "Lambda Expanded Wff"))
						 (?? (mhelp 'gwff0))))
			 (unless (wffeq-ab (etanorm (lambda-norm wff)) x)
			   (throwfail (wff . gwff) " does not lambda reduce to " (x . gwff)))
			 wff))
		   #'(lambda (l2 l1 princ-wff)
		       (let ((es1 (get l1 'ext-seq))
			     (es2 (get l2 'ext-seq)))
			 (setf (line-justification l2) (list "LAMBDA" nil (list l1)))
			 (setf (ext-seq-kind es2) 'LAMBDA)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-prems es2) (list es1))))))

(defextseq equivwffs+
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with Wff with Abbreviation" "Line with Expanded Definition")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (atom-head-abbrev-p x)))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-equivwffs+)
  (mhelp "Infer (p2) Gamma,A from (p1) Gamma,B where B is obtained from A by
expanding an abbreviation at the head of A if A is not an equation.
If A is an equation of base type other than O, the abbreviation must 
be at the head of the left or right side."))

(defextseq equivwffs-
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with Negated Wff with Abbreviation" "Line with Expanded Definition")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (atom-head-abbrev-p (cdr x)))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-equivwffs-)
  (mhelp "Infer (p2) Gamma,~A from (p1) Gamma,~B where B is obtained from A by
expanding an abbreviation at the head of A if A is not an equation.
If A is an equation of base type other than O, the abbreviation must 
be at the head of the left or right side."))

(defun extseq-equivwffs+ (p2 p1 &optional pwff)
  (extseq-rule-1-1 p2 p1 pwff
		   #'(lambda (x) (atom-head-abbrev-p x))
		   #'(lambda (x) (declare (ignore x)) t)
		   #'(lambda (x) (instantiate-head-abbrev x))
		   #'(lambda (x)
		       (let ((wff nil))
			 (prompt-read wff nil
				      (msgf "Wff with Abbrev")
				      'gwff0 '$ ((? (msgf "Wff before expansion of abbreviation"))
						 (?? (mhelp 'gwff0))))
			 (let ((ewff (instantiate-head-abbrev wff)))
			   (unless (wffeq-ab ewff x)
			     (throwfail (wff . gwff) " expands to " t
					(ewff . gwff) t
					" instead of " (x . gwff))))
			 wff))
		   #'(lambda (l2 l1 princ-wff)
		       (let ((es1 (get l1 'ext-seq))
			     (es2 (get l2 'ext-seq)))
			 (setf (line-justification l2) (list "EQUIVWFFS+" nil (list l1)))
			 (setf (ext-seq-kind es2) 'REW)
			 (setf (ext-seq-rew-just es2) 'EQUIVWFFS)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-pos-rule es2) t)
			 (setf (ext-seq-prems es2) (list es1))))))
		   
(defun extseq-equivwffs- (p2 p1 &optional pwff)
  (extseq-rule-1-1 p2 p1 pwff
		   #'(lambda (x)
		       (and (not-p x) (atom-head-abbrev-p (cdr x))))
		   #'(lambda (x) (not-p x))
		   #'(lambda (x)
		       (cons 'NOT (instantiate-head-abbrev (cdr x))))
		   #'(lambda (x)
		       (let ((wff nil))
			 (prompt-read wff nil
				      (msgf "Negated Wff with Abbrev at the Head")
				      'gwff0 '$ ((? (msgf "Wff before expansion of abbreviation"))
						 (?? (mhelp 'gwff0))))
			 (unless (not-p wff)
			   (throwfail (wff . gwff) " is not a negated wff"))
			 (let ((ewff (cons 'NOT (instantiate-head-abbrev (cdr wff)))))
			   (unless (wffeq-ab ewff x)
			     (throwfail (wff . gwff) " expands to " t
					(ewff . gwff) t
					" instead of " (x . gwff))))
			 wff))
		   #'(lambda (l2 l1 princ-wff)
		       (let ((es1 (get l1 'ext-seq))
			     (es2 (get l2 'ext-seq)))
			 (setf (line-justification l2) (list "EQUIVWFFS-" nil (list l1)))
			 (setf (ext-seq-kind es2) 'REW)
			 (setf (ext-seq-rew-just es2) 'EQUIVWFFS)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-pos-rule es2) nil)
			 (setf (ext-seq-prems es2) (list es1))))))

(defextseq internalize+
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with Internal Wff" "Line with External Wff")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (not (wffeq (externalize-wff1 x) x))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-internalize+)
  (mhelp "Infer (p2) Gamma,A from (p1) Gamma,#(A) where #(A) is the 'externalized' version of A.
This corresponds to the # rule in Chad E. Brown's thesis."))

(defextseq internalize-
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with Negated Internal Wff" "Line with External Wff")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x)
				       (and (not-p x)
					    (not (wffeq (externalize-wff1 (cdr x)) (cdr x))))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-internalize-)
  (mhelp "Infer (p2) Gamma,~A from (p1) Gamma,~#(A) where #(A) is the 'externalized' version of A.
This corresponds to the ~# rule in Chad E. Brown's thesis."))

; assumes x either has an abbrev at the head, or is an equation with an abbrev
; at the head of one side, or both sides.
(defun instantiate-head-abbrev (x)
  (if (equals-p x)
      (acons (caar x)
	     (if (head-abbrev-p (cdar x))
		 (instantiate-1 (cdar x))
	       (cdar x))
	     (if (head-abbrev-p (cdr x))
		 (instantiate-1 (cdr x))
	       (cdr x)))
    (instantiate-1 x)))

(defun head-abbrev-p (wff)
  (if (boundwff-p wff)
      (anyabbrev-q (binder wff))
    (and (not (or (not-p wff) (equiv-p wff)))
	 (anyabbrev-p (head wff)))))

(defun atom-head-abbrev-p (x)
  (if (equals-p x)
      (let ((tp (cdr (unabbreviated-type (caar x)))))
	(and (not (consp tp)) (not (eq tp 'O))
	     (or (head-abbrev-p (cdar x))
		 (head-abbrev-p (cdr x)))))
    (head-abbrev-p x)))

(defun lazy-abbrev-normalize (wff)
  (etanorm (lazy-abbrev-normalize-1 wff)))

(defun lazy-abbrev-normalize-1 (wff)
  (lazy-abbrev-normalize-2 (lambda-norm wff)))

(defun lazy-abbrev-normalize-2 (wff)
  (if (atom-head-abbrev-p wff)
      (lazy-abbrev-normalize-1 (instantiate-head-abbrev wff))
    wff))

(defun extseq-internalize+ (p2 p1 &optional pwff)
  (extseq-rule-1-1 p2 p1 pwff
		   #'(lambda (x) (not (wffeq (externalize-wff1 x) x)))
		   #'(lambda (x) (declare (ignore x)) t)
		   #'externalize-wff1
		   #'(lambda (x)
		       (let ((wff nil))
			 (prompt-read wff nil
				      (msgf "Internal Wff")
				      'gwff0 '$ ((? (msgf "Wff before written in terms of ~, or, forall"))
						 (?? (mhelp 'gwff0))))
			 (unless (wffeq-ab (externalize-wff1 wff) x)
			   (throwfail (wff . gwff) " does not externalize to " (x . gwff)))
			 wff))
		   #'(lambda (l2 l1 princ-wff)
		       (let ((es1 (get l1 'ext-seq))
			     (es2 (get l2 'ext-seq)))
			 (setf (line-justification l2) (list "INTERNALIZE+" nil (list l1)))
			 (setf (ext-seq-kind es2) 'INTERNALIZE)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-pos-rule es2) t)
			 (setf (ext-seq-prems es2) (list es1))))))
		   
(defun extseq-internalize- (p2 p1 &optional pwff)
  (extseq-rule-1-1 p2 p1 pwff
		   #'(lambda (x) (and (not-p x) (not (wffeq (externalize-wff1 (cdr x)) (cdr x)))))
		   #'(lambda (x) (not-p x))
		   #'(lambda (x)
		       (cons 'NOT (externalize-wff1 (cdr x))))
		   #'(lambda (x)
		       (let ((wff nil))
			 (prompt-read wff nil
				      (msgf "Internal Negated Wff")
				      'gwff0 '$ ((? (msgf "Wff before written in terms of ~, or, forall"))
						 (?? (mhelp 'gwff0))))
			 (unless (and (not-p wff) (wffeq-ab (externalize-wff1 (cdr wff)) (cdr x)))
			   (throwfail (wff . gwff) " does not externalize to " (x . gwff)))
			 wff))
		   #'(lambda (l2 l1 princ-wff)
		       (let ((es1 (get l1 'ext-seq))
			     (es2 (get l2 'ext-seq)))
			 (setf (line-justification l2) (list "INTERNALIZE-" nil (list l1)))
			 (setf (ext-seq-kind es2) 'INTERNALIZE)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-pos-rule es2) nil)
			 (setf (ext-seq-prems es2) (list es1))))))

(defextseq all+
  (extseq-argtypes line line gwff)
  (extseq-argnames p2 p1 y)
  (extseq-arghelp "Line with [FORALL x M]" "Line with [y/x]M" "Universal Variable y")
  (extseq-defaultfns
   (lambda (p2 p1 y)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x)
				       (a-bd-wff-p x)))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1)
	   (if (and (eq y '$) (numberp p2))
	       (let* ((l2 (esnumalias p2))
		      (es2 (when l2 (get l2 'ext-seq)))
		      (wffs2 (when (ext-seq-p es2) (ext-seq-wffs es2)))
		      (princ-wffs2 (remove-duplicates
				    (remove-if-not #'(lambda (x) (a-bd-wff-p x)) wffs2)
				    :test #'wffeq-ab)))
		 (if (and princ-wffs2 (not (cdr princ-wffs2)))
		     (bindvar (car princ-wffs2))
		   '$))
	     y))))
  (extseq-mainfns extseq-all+)
  (mhelp "Infer (p2) Gamma,[FORALL x M] from (p1) Gamma,[y/x]M."))

(defextseq all-
  (extseq-argtypes line line gwff)
  (extseq-argnames p2 p1 trm)
  (extseq-arghelp "Line with ~[FORALL x M]" "Line with [trm/x]M" "Instantiation trm")
  (extseq-defaultfns
   (lambda (p2 p1 trm)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x)
				       (and (not-p x)
					    (a-bd-wff-p (cdr x)))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1)
	   trm)))
  (extseq-mainfns extseq-all-)
  (mhelp "Infer (p2) Gamma,~[FORALL x M] from (p1) Gamma,~[trm/x]M."))

(defun extseq-all+ (p2 p1 y &optional pwff)
  (unless (and (symbolp y) (not (anyabbrev-p y)) (not (logconst-p y))
	       (not (binder-p y))
	       (not (equality-p y)))
    (throwfail y " is not a variable."))
  (let ((atp (unabbreviated-type y)))
    (extseq-rule-1-1 p2 p1 pwff
		     #'(lambda (x)
			 (and (a-bd-wff-p x)
			      (equal (unabbreviated-type (bindvar x)) atp)))
		     #'(lambda (x) (declare (ignore x)) t)
		     #'(lambda (x)
			 (substitute-l-term-var y (bindvar x) (cdr x)))
		     #'(lambda (x)
			 (let ((wff nil))
			   (prompt-read wff nil
					(msgf "Universally Quantified Wff")
					'gwff0 '$ ((? (msgf "Wff before instantiation"))
						   (?? (mhelp 'gwff0))))
			   (unless (and (a-bd-wff-p wff)
					(equal (unabbreviated-type (bindvar wff)) atp)
					(wffeq-ab (substitute-l-term-var y (bindvar wff) (cdr wff)) x))
			     (throwfail (wff . gwff) " does not instantiate to " (x . gwff)))
			   wff))
		   #'(lambda (l2 l1 princ-wff)
		       (let ((es1 (get l1 'ext-seq))
			     (es2 (get l2 'ext-seq)))
			 (setf (line-justification l2) (list "ALL+" (list y) (list l1)))
			 (setf (ext-seq-kind es2) 'FORALL)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-sel-var es2) y)
			 (setf (ext-seq-pos-rule es2) t)
			 (setf (ext-seq-prems es2) (list es1)))))
    (let* ((l2 (esnumalias p2))
	   (es2 (get l2 'ext-seq))
	   (wffs2 (when (ext-seq-p es2) (ext-seq-wffs es2))))
      (when (find-if #'(lambda (x) (free-in y x)) wffs2)
	(setf (ext-seq-prems es2) nil)
	(setf (ext-seq-kind es2) nil)
	(setf (line-justification l2) (es-nextplan))
	(push (list l2) (proof-plans (get *current-seqder* 'ext-seq-der)))
	(es-find-all-gaps)
	(throwfail y " is free in line " p2))
      nil)))

(defun extseq-all- (p2 p1 trm &optional pwff)
  (let ((atp (unabbreviated-type trm)))
    (extseq-rule-1-1 p2 p1 pwff
		     #'(lambda (x)
			 (and (not-p x)
			      (a-bd-wff-p (cdr x))
			      (equal (unabbreviated-type (bindvar (cdr x))) atp)))
		     #'(lambda (x) (not-p x))
		     #'(lambda (x)
			 (cons 'NOT (substitute-l-term-var trm (bindvar (cdr x)) (cddr x))))
		     #'(lambda (x)
			 (let ((wff nil))
			   (prompt-read wff nil
					(msgf "Negated Universally Quantified Wff")
					'gwff0 '$ ((? (msgf "Wff before instantiation"))
						   (?? (mhelp 'gwff0))))
			   (unless (and (not-p wff)
					(a-bd-wff-p (cdr wff))
					(equal (unabbreviated-type (bindvar (cdr wff))) atp)
					(wffeq-ab (substitute-l-term-var trm (bindvar (cdr wff)) (cddr wff)) (cdr x)))
			     (throwfail (wff . gwff) " does not instantiate to " (x . gwff)))
			   wff))
		     #'(lambda (l2 l1 princ-wff)
			 (let ((es1 (get l1 'ext-seq))
			       (es2 (get l2 'ext-seq)))
			   (setf (line-justification l2) (list "ALL-" (list trm) (list l1)))
			   (setf (ext-seq-kind es2) 'FORALL)
			   (setf (ext-seq-princ-wffs es2) (list princ-wff))
			   (setf (ext-seq-exp-term es2) trm)
			   (setf (ext-seq-pos-rule es2) nil)
			   (setf (ext-seq-prems es2) (list es1)))))))

(defextseq extfunc
  (extseq-argtypes line line gwff)
  (extseq-argnames p2 p1 y)
  (extseq-arghelp "Line with [f(AB) = g]" "Line with [f(AB) y = g y]" "Variable y")
  (extseq-defaultfns
   (lambda (p2 p1 y)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x)
				       (and (equals-p x)
					    (let ((btp (unabbreviated-type (cdr x))))
					      (consp btp)))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1)
	   (if (and (eq y '$) (numberp p2))
	       (let* ((l2 (esnumalias p2))
		      (es2 (when l2 (get l2 'ext-seq)))
		      (wffs2 (when (ext-seq-p es2) (ext-seq-wffs es2)))
		      (princ-wffs2 (remove-duplicates
				    (remove-if-not #'(lambda (x)
						       (and (equals-p x)
							    (let ((btp (unabbreviated-type (cdr x))))
							      (consp btp))))
						   wffs2)
				    :test #'wffeq-ab)))
		 (if (and princ-wffs2 (not (cdr princ-wffs2)))
		     (let ((btp (unabbreviated-type (cdar princ-wffs2))))
		       (fresh-var (cdr btp) 'y))
		   y))
	     y))))
  (extseq-mainfns extseq-extfunc)
  (mhelp "Infer (p2) Gamma,forall x M from (p1) Gamma,[a/x]M."))

(defextseq eqfunc
  (extseq-argtypes line line gwff)
  (extseq-argnames p2 p1 trm)
  (extseq-arghelp "Line with ~[f(AB) = g(AB)]" "Line with ~[f trm = g trm]" "Instantiation trm(B)")
  (extseq-defaultfns
   (lambda (p2 p1 trm)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x)
				       (and (not-p x)
					    (equals-p (cdr x))
					    (let ((btp (unabbreviated-type (cddr x))))
					      (consp btp)))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1)
	   trm)))
  (extseq-mainfns extseq-eqfunc)
  (mhelp "Infer (p2) Gamma,~forall x M from (p1) Gamma,~[trm/x]M."))

(defun extseq-extfunc (p2 p1 y &optional pwff)
  (let ((atp (unabbreviated-type y)))
    (extseq-rule-1-1 p2 p1 pwff
		     #'(lambda (x)
			 (and (equals-p x)
			      (let ((btp (unabbreviated-type (cdr x))))
				(and (consp btp)
				     (equal (cdr btp) atp)))))
		     #'(lambda (x) 
			 (and (equals-p x)
			      (consp (cdar x))
			      (consp (cdr x))
			      (eq (cddar x) y)
			      (eq (cddr x) y)))
		     #'(lambda (x)
			 (let* ((btp (unabbreviated-type (cdr x)))
				(q (inherit-abbrev '= (acons 'O (car btp) (car btp)) (list (car btp)))))
			   (acons q (cons (cdar x) y) (cons (cdr x) y))))
		     #'(lambda (x)
			 (let* ((ctp (unabbreviated-type (cdr x)))
				(tp (cons ctp atp))
				(q (inherit-abbrev '= (acons 'O tp tp) (list tp))))
			   (acons q (cadar x) (cadr x))))
		     #'(lambda (l2 l1 princ-wff)
			 (let ((es1 (get l1 'ext-seq))
			       (es2 (get l2 'ext-seq)))
			   (setf (line-justification l2) (list "EXTFUNC" (list y) (list l1)))
			   (setf (ext-seq-kind es2) 'EXTFUNC)
			   (setf (ext-seq-princ-wffs es2) (list princ-wff))
			   (setf (ext-seq-sel-var es2) y)
			   (setf (ext-seq-pos-rule es2) t)
			   (setf (ext-seq-prems es2) (list es1)))))
    (let* ((l2 (esnumalias p2))
	   (es2 (get l2 'ext-seq))
	   (wffs2 (when (ext-seq-p es2) (ext-seq-wffs es2))))
      (when (find-if #'(lambda (x) (free-in y x)) wffs2)
	(setf (ext-seq-prems es2) nil)
	(setf (ext-seq-kind es2) nil)
	(setf (line-justification l2) (es-nextplan))
	(push (list l2) (proof-plans (get *current-seqder* 'ext-seq-der)))
	(es-find-all-gaps)
	(throwfail y " is free in line " p2))
      nil)))

(defun extseq-eqfunc (p2 p1 trm &optional pwff)
  (let ((atp (unabbreviated-type trm)))
    (extseq-rule-1-1 p2 p1 pwff
		     #'(lambda (x)
			 (and (not-p x)
			      (equals-p (cdr x))
			      (let ((btp (unabbreviated-type (cddr x))))
				(and (consp btp)
				     (equal (cdr btp) atp)))))
		     #'(lambda (x)
			 (and (not-p x)
			      (equals-p (cdr x))
			      (consp (cdadr x))
			      (consp (cddr x))
			      (wffeq-ab (cddar (cdr x)) trm)
			      (wffeq-ab (cddr (cdr x)) trm)))
		     #'(lambda (x)
			 (let* ((btp (unabbreviated-type (cddr x)))
				(q (inherit-abbrev '= (acons 'O (car btp) (car btp)) (list (car btp)))))
			   (cons 'NOT (acons q (cons (cdadr x) trm) (cons (cddr x) trm)))))
		     #'(lambda (x)
			 (let* ((ctp (unabbreviated-type (cddr x)))
				(tp (cons ctp atp))
				(q (inherit-abbrev '= (acons 'O tp tp) (list tp))))
			   (cons 'NOT (acons q (cadar (cdr x)) (caddr x)))))
		     #'(lambda (l2 l1 princ-wff)
			 (let ((es1 (get l1 'ext-seq))
			       (es2 (get l2 'ext-seq)))
			   (setf (line-justification l2) (list "EQFUNC" (list trm) (list l1)))
			   (setf (ext-seq-kind es2) 'EQFUNC)
			   (setf (ext-seq-princ-wffs es2) (list princ-wff))
			   (setf (ext-seq-exp-term es2) trm)
			   (setf (ext-seq-pos-rule es2) nil)
			   (setf (ext-seq-prems es2) (list es1)))))))

(defextseq contr
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with Gamma, A" "Premiss Line with Gamma, A, A")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (declare (ignore x)) t))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-contr)
  (mhelp "Infer (p2) Gamma,A from (p1) Gamma,A,A."))

(defun extseq-contr (p2 p1 &optional pwff)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq)))
	 (princ-wff pwff)
	 (gam nil))
    (if (ext-seq-p es2)
	(let ((wffs2 (ext-seq-wffs es2)))
	  (if (ext-seq-p es1)
	      (let* ((wffs1 (ext-seq-wffs es1))
		     (gam0 (multiset-extract-wffs-1 wffs1 wffs2)))
		(unless (and gam0 (not (cdr gam0)))
		  (throwfail "Gammas Do Not Match"))
		(if princ-wff
		    (unless (wffeq-ab pwff princ-wff)
		      (throwfail "Invalid Application of CONTR"))
		  (setq princ-wff (car gam0)))
		(setq gam (multiset-extract-wffs gam0 princ-wff)))
	    (progn
	      (unless princ-wff
		(setq princ-wff (extseq-choose-princ-wff #'(lambda (x) (declare (ignore x)) t) wffs2)))
	      (setq gam (multiset-extract-wffs wffs2 princ-wff))
	      (setq es1 (make-ext-seq :wffs (cons princ-wff (cons princ-wff gam))))
	      (setq l1 (new-extseq-line p1 es1)))))
      (if (ext-seq-p es1)
	  (let ((wffs1 (ext-seq-wffs es1))
		(poss-princs nil))
	    (dolist (w wffs1)
	      (when (and (not (member w poss-princs :test #'wffeq-ab))
			 (> (count w wffs1 :test #'wffeq-ab) 1))
		(push w poss-princs)))
	    (if princ-wff
		(unless (member princ-wff poss-princs :test #'wffeq-ab)
		  (throwfail "Invalid Principal Formula for Contr"))
	      (setq princ-wff (extseq-choose-princ-wff #'(lambda (x) (declare (ignore x)) t) poss-princs)))
	    (setq gam (multiset-extract-wffs wffs1 princ-wff princ-wff))
	    (setq es2 (make-ext-seq :wffs (cons princ-wff gam)))
	    (setq l2 (new-extseq-line p2 es2)))
	(let ((gamlen nil)
	      (wff nil))
	  (unless princ-wff
	    (prompt-read princ-wff nil
			 (msgf "Enter Principal Formula of Contr")
			 'gwff0 '$
			 ((? (msgf "Formula to Contract"))
			  (?? (mhelp 'gwff0)))))
	  (prompt-read gamlen nil
		       (msgf "Enter the number of Wffs in Gamma")
		       'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				    (?? (mhelp 'integer+))))
	  (dotimes (i gamlen)
	    (prompt-read wff nil
		       (msgf "Enter a Side Wff")
		       'gwff0 '$ ((? (msgf "Side Wff"))
				  (?? (mhelp 'gwff0))))
	    (push wff gam))
	  (setq es1 (make-ext-seq :wffs (cons princ-wff (cons princ-wff gam))))
	  (setq es2 (make-ext-seq :wffs (cons princ-wff gam)))
	  (setq l1 (new-extseq-line p1 es1))
	  (setq l2 (new-extseq-line p2 es2)))))
    (setf (ext-seq-kind es2) 'CONTR)
    (setf (ext-seq-prems es2) (list es1))
    (setf (ext-seq-princ-wffs es2) (list princ-wff))
    (set-extseq-line-justification-1 l2 es2 (list l1))
    (update-extseq-proof-plans l2 (list l1))
    (es-find-all-gaps))
  nil)

(defextseq or+
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with [A OR B]" "Line with A,B")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (or-p x)))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-or+)
  (mhelp "From
(p1) Gamma, A, B
infer
(p3) Gamma, [A OR B]"))

(defun extseq-or+ (p2 p1 &optional pwff)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq))))
    (if (ext-seq-p es2)
	(let* ((wffs (ext-seq-wffs es2))
	       (princ-wff (or pwff (extseq-choose-princ-wff #'(lambda (x) (or-p x)) wffs)))
	       (gam (multiset-extract-wffs (ext-seq-wffs es2) princ-wff))
	       (wff1 (cdar princ-wff))
	       (wff2 (cdr princ-wff)))
	  (if (ext-seq-p es1)
	      (let ((wffs1 (ext-seq-wffs es1)))
		(unless (wffeq-ab-multiset gam (multiset-extract-wffs wffs1 wff1 wff2))
		  (throwfail "Gammas do not match")))
	    (progn
	      (setq es1 (make-ext-seq :wffs (cons wff1 (cons wff2 gam))))
	      (setq l1 (new-extseq-line p1 es1))))
	  (setf (ext-seq-kind es2) 'DIS)
	  (setf (ext-seq-pos-rule es2) t)
	  (setf (ext-seq-princ-wffs es2) (list princ-wff))
	  (setf (ext-seq-prems es2) (list es1))
	  (set-extseq-line-justification-1 l2 es2 (list l1))
	  (update-extseq-proof-plans l2 (list l1))
	  (es-find-all-gaps))
      (if (ext-seq-p es1)
	  (let* ((wffs (ext-seq-wffs es1))
		 (gam nil)
		 (es2 nil)
		 (princ-wff nil)
		 (wff1 nil)
		 (wff2 nil))
	    (if (and pwff (or-p pwff))
		(progn
		  (setq princ-wff pwff)
		  (setq wff1 (cdar pwff))
		  (setq wff2 (cdr pwff)))
	      (progn
		(setq wff1 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) wffs "Choose Left Disjunct:"))
		(setq wff2 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) (remove wff1 wffs :count 1)
						   "Choose Right Disjunct:"))
		(setq princ-wff (acons 'OR wff1 wff2))))
	    (setq gam (multiset-extract-wffs wffs wff1 wff2))
	    (setq es2 (make-ext-seq :wffs (cons princ-wff gam)))
	    (setq l2 (new-extseq-line p2 es2))
	    (setf (ext-seq-kind es2) 'DIS)
	    (setf (ext-seq-pos-rule es2) t)
	    (setf (ext-seq-princ-wffs es2) (list princ-wff))
	    (setf (ext-seq-prems es2) (list es1))
	    (set-extseq-line-justification-1 l2 es2 (list l1))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps))
	(let ((princ-wff nil)
	      (gam nil)
	      (wff nil)
	      (gamlen nil))
	  (if pwff
	      (setq princ-wff pwff)
	    (prompt-read princ-wff nil
			 (msgf "Enter Principal Wff")
			 'gwff0 '$ ((? (msgf "Principal Formula of Rule"))
				    (?? (mhelp 'gwff0)))))
	  (unless (or-p princ-wff)
	    (throwfail (princ-wff . gwff) " is not a disjunction."))
	  (prompt-read gamlen nil
		       (msgf "Enter the number of Wffs in Gamma")
		       'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				    (?? (mhelp 'integer+))))
	  (dotimes (i gamlen)
	    (prompt-read wff nil
			 (msgf "Enter a Side Wff")
			 'gwff0 '$ ((? (msgf "Side Wff"))
				    (?? (mhelp 'gwff0))))
	    (push wff gam))
	  (let* ((wff1 (cdar princ-wff))
		 (wff2 (cdr princ-wff))
		 (es1 (make-ext-seq :wffs (cons wff1 (cons wff2 gam))))
		 (es2 (make-ext-seq :wffs (cons princ-wff gam)))
		 (l1 (new-extseq-line p1 es1))
		 (l2 (new-extseq-line p2 es2)))
	    (setf (ext-seq-kind es2) 'DIS)
	    (setf (ext-seq-pos-rule es2) t)
	    (setf (ext-seq-princ-wffs es2) (list princ-wff))
	    (setf (ext-seq-prems es2) (list es1))
	    (set-extseq-line-justification-1 l2 es2 (list l1))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps))))))
  nil)

; no premisses
(defun extseq-rule-0 (p pwff princfn getprincfn setkind)
  (let* ((l (esnumalias p))
	 (es (when l (get l 'ext-seq))))
    (if (ext-seq-p es)
	(let* ((wffs (ext-seq-wffs es))
	       (princ-wff (or pwff (extseq-choose-princ-wff princfn wffs))))
	  (update-extseq-proof-plans l nil)
	  (funcall setkind l princ-wff)
	  (es-find-all-gaps))
      (let ((princ-wff (or pwff (funcall getprincfn)))
	    (gam nil)
	    (wff nil)
	    (gamlen nil))
	  (prompt-read gamlen nil
		       (msgf "Enter the number of Wffs in Gamma")
		       'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				    (?? (mhelp 'integer+))))
	  (dotimes (i gamlen)
	    (prompt-read wff nil
		       (msgf "Enter a Side Wff")
		       'gwff0 '$ ((? (msgf "Side Wff"))
				  (?? (mhelp 'gwff0))))
	    (push wff gam))
	  (let* ((es (make-ext-seq :wffs (cons princ-wff gam)))
		 (l (new-extseq-line p es)))
	    (funcall setkind l princ-wff)
	    (es-find-all-gaps)))))
  nil)

(defextseq true+
  (extseq-argtypes line)
  (extseq-argnames p)
  (extseq-arghelp "Line with TRUTH")
  (extseq-defaultfns
   (lambda (p)
     (list (if (eq p '$)
	       (extseq-defaultplan #'(lambda (x) (eq x 'TRUTH)))
	     p))))
  (extseq-mainfns extseq-true)
  (mhelp "Infer (p) Gamma, TRUTH"))

(defextseq init
  (extseq-argtypes line)
  (extseq-argnames p)
  (extseq-arghelp "Line with initial sequent")
  (extseq-defaultfns
   (lambda (p)
     (list (if (eq p '$)
	       (extseq-defaultplan-2
		#'(lambda (x) (not-p x))
		#'(lambda (nwff x) (wffeq-ab (cdr nwff) x)))
	     p))))
  (extseq-mainfns extseq-init)
  (mhelp "Infer (p) Gamma, ~A, A"))

(defextseq refl
  (extseq-argtypes line)
  (extseq-argnames p)
  (extseq-arghelp "Line with Reflexive Equation")
  (extseq-defaultfns
   (lambda (p)
     (list (if (eq p '$)
	       (extseq-defaultplan #'(lambda (x) (and (equals-p x) (wffeq-ab (cdar x) (cdr x)))))
	     p))))
  (extseq-mainfns extseq-refl)
  (mhelp "Infer (p) Gamma, t = t"))

(defun extseq-true (p)
  (extseq-rule-0 p 'TRUTH
		 #'(lambda (x) (eq x 'TRUTH))
		 #'(lambda () 'TRUTH)
		 #'(lambda (l princ-wff)
		     (declare (ignore princ-wff))
		     (let ((es (get l 'ext-seq)))
		       (setf (line-justification l) (list "TRUE+" nil nil))
		       (setf (ext-seq-kind es) 'TRUE)
		       (setf (ext-seq-princ-wffs es) (list 'TRUTH))
		       (setf (ext-seq-pos-rule es) t)))))
		 
(defun extseq-init (p &optional pwff)
  (let* ((l (esnumalias p))
	 (es (when l (get l 'ext-seq))))
    (if (ext-seq-p es)
	(let* ((wffs (ext-seq-wffs es))
	       (princ-wff 
		(or pwff
		    (extseq-choose-princ-wff
		     #'(lambda (x)
			 (member (cons 'NOT x) wffs :test #'wffeq-ab))
		     wffs))))
	  (update-extseq-proof-plans l nil)
	  (setf (ext-seq-kind es) 'INIT)
	  (setf (ext-seq-princ-wffs es) (list (cons 'NOT princ-wff) princ-wff))
	  (set-extseq-line-justification-1 l es nil)
	  (es-find-all-gaps))
      (let ((princ-wff nil)
	    (gam nil)
	    (wff nil)
	    (gamlen nil))
	  (prompt-read princ-wff nil
		       (msgf "Enter Principal Formula of Init (without Negation)")
		       'gwff0 '$
		       ((? (msgf "Formula of Init"))
			(?? (mhelp 'gwff0))))
	  (prompt-read gamlen nil
		       (msgf "Enter the number of Wffs in Gamma")
		       'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				    (?? (mhelp 'integer+))))
	  (dotimes (i gamlen)
	    (prompt-read wff nil
		       (msgf "Enter a Side Wff")
		       'gwff0 '$ ((? (msgf "Side Wff"))
				  (?? (mhelp 'gwff0))))
	    (push wff gam))
	  (let* ((es (make-ext-seq :wffs (cons (cons 'NOT princ-wff) (cons princ-wff gam))))
		 (l (new-extseq-line p es)))
	    (setf (ext-seq-kind es) 'INIT)
	    (setf (ext-seq-princ-wffs es) (list (cons 'NOT princ-wff) princ-wff))
	    (set-extseq-line-justification-1 l es nil)
	    (es-find-all-gaps)))))
  nil)
      
(defun extseq-refl (p &optional pwff)
  (extseq-rule-0 p pwff
		 #'(lambda (x) (and (equals-p x) (wffeq-ab (cdar x) (cdr x))))
		 #'(lambda ()
		     (let ((wff nil))
		       (prompt-read wff nil
				    (msgf "Enter term for Refl")
				    'gwff '$ ((? (msgf "Wff for use in Refl"))
					      (?? (mhelp 'gwff))))
		       (let* ((tp (unabbreviated-type wff))
			      (q (inherit-abbrev '= (acons 'O tp tp) (list tp))))
			 (acons q wff wff))))
		 #'(lambda (l princ-wff)
		     (let ((es (get l 'ext-seq)))
		       (setf (line-justification l) (list "REFL" nil nil))
		       (setf (ext-seq-kind es) 'REFL)
		       (setf (ext-seq-princ-wffs es) (list princ-wff))
		       (setf (ext-seq-pos-rule es) t)))))

; two premisses
(defun extseq-rule-2 (p3 p1 p2 pwff princfn premfns1 premfns2 princtopremfn premtoprincfn setkind)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq)))
	 (l3 (esnumalias p3))
	 (es3 (when l3 (get l3 'ext-seq))))
    (if (ext-seq-p es3)
	(let* ((wffs (ext-seq-wffs es3))
	       (princ-wff (or pwff (extseq-choose-princ-wff princfn wffs)))
	       (gam (multiset-extract-wffs (ext-seq-wffs es3) princ-wff))
	       (prem-wffs (funcall princtopremfn princ-wff))
	       (prem-wffs1 (car prem-wffs))
	       (prem-wffs2 (cdr prem-wffs)))
	  (if (ext-seq-p es1)
	      (let ((wffs1 (ext-seq-wffs es1)))
		(unless (wffeq-ab-multiset gam (multiset-extract-wffs-1 wffs1 prem-wffs1))
		  (throwfail "Gammas do not Match")))
	    (progn
	      (setq es1 (make-ext-seq :wffs (append prem-wffs1 gam)))
	      (setq l1 (new-extseq-line p1 es1))))
	  (if (ext-seq-p es2)
	      (let ((wffs2 (ext-seq-wffs es2)))
		(unless (wffeq-ab-multiset gam (multiset-extract-wffs-1 wffs2 prem-wffs2))
		  (throwfail "Gammas do not match")))
	    (progn
	      (setq es2 (make-ext-seq :wffs (append prem-wffs2 gam)))
	      (setq l2 (new-extseq-line p2 es2))))
	  (funcall setkind l3 l1 l2 princ-wff)
	  (update-extseq-proof-plans l3 (list l1 l2))
	  (es-find-all-gaps))
      (let ((prem-wffs1 nil)
	    (prem-wffs2 nil)
	    (princ-wff pwff)
	    (gam nil)
	    (gam-done nil))
	(unless (and (ext-seq-p es1) (ext-seq-p es2))
	  (unless princ-wff
	    (prompt-read princ-wff nil
			 (msgf "Enter Principal Wff ")
			 'gwff0 '$ ((? (msgf "Principal Formula of Rule"))
				    (?? (mhelp 'gwff0))))
	    (unless (funcall princfn princ-wff)
	      (throwfail "Not a valid Principal Formula")))
	  (let ((prem-wffs (funcall princtopremfn princ-wff)))
	    (setq prem-wffs1 (car prem-wffs))
	    (setq prem-wffs2 (cdr prem-wffs))))
	(when (ext-seq-p es1)
	  (unless princ-wff
	    (let ((wffs1 (ext-seq-wffs es1)))
	      (dotimes (i (length premfns1))
		(let ((prem-wff (extseq-choose-prem-wff (nth i premfns1) wffs1)))
		  (push prem-wff prem-wffs1)
		  (setq wffs1 (remove prem-wff wffs1 :count 1))))
	      (setq prem-wffs1 (reverse prem-wffs1))))
	  (setq gam (multiset-extract-wffs-1 (ext-seq-wffs es1) prem-wffs1))
	  (setq gam-done t))
	(when (ext-seq-p es2)
	  (unless princ-wff
	    (let ((wffs2 (ext-seq-wffs es2)))
	      (dotimes (i (length premfns2))
		(let ((prem-wff (extseq-choose-prem-wff (nth i premfns2) wffs2)))
		  (push prem-wff prem-wffs2)
		  (setq wffs2 (remove prem-wff wffs2 :count 1))))
	      (setq prem-wffs2 (reverse prem-wffs2))))
	  (if gam-done
	      (unless (wffeq-ab-multiset gam (multiset-extract-wffs-1 (ext-seq-wffs es2) prem-wffs2))
		(throwfail "Gammas do not Match"))
	    (progn
	      (setq gam (multiset-extract-wffs-1 (ext-seq-wffs es2) prem-wffs2))
	      (setq gam-done t))))
	(unless gam-done
	  (let ((gamlen nil)
		(wff nil))
	    (prompt-read gamlen nil
			 (msgf "Enter the number of wffs in Gamma")
			 'integer+ 0 ((? (msgf "Number of side wffs of sequent"))
				      (?? (mhelp 'integer+))))
	    (dotimes (i gamlen)
	      (prompt-read wff nil
			   (msgf "Enter a Side Wff")
			   'gwff0 '$ ((? (msgf "Side Wff"))
				      (?? (mhelp 'gwff0))))
	      (push wff gam))))
	(unless (ext-seq-p es1)
	  (setq es1 (make-ext-seq :wffs (append prem-wffs1 gam)))
	  (setq l1 (new-extseq-line p1 es1)))
	(unless (ext-seq-p es2)
	  (setq es2 (make-ext-seq :wffs (append prem-wffs2 gam)))
	  (setq l2 (new-extseq-line p2 es2)))
	(unless princ-wff
	  (setq princ-wff (funcall premtoprincfn prem-wffs1 prem-wffs2)))
	(setq es3 (make-ext-seq :wffs (cons princ-wff gam)))
	(setq l3 (new-extseq-line p3 es3))
	(funcall setkind l3 l1 l2 princ-wff)
	(es-find-all-gaps))))
  nil)

(defextseq or-
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Line with ~[A OR B]" "Line with ~A" "Line with ~B")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (or-p (cdr x)))))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-or-)
  (mhelp "From
(p1) Gamma, ~A
and
(p2) Gamma, ~B
infer
(p3) Gamma, ~[A OR B]"))

(defun extseq-or- (p3 p1 p2 &optional pwff)
  (extseq-rule-2 p3 p1 p2 pwff
		 #'(lambda (x)
		     (and (not-p x) (or-p (cdr x))))
		 (list #'(lambda (x) (not-p x)))
		 (list #'(lambda (x) (not-p x)))
		 #'(lambda (x)
		     (cons (list (cons 'NOT (cdadr x))) (list (cons 'NOT (cddr x)))))
		 #'(lambda (xl yl)
		     (cons 'NOT (acons 'OR (cdar xl) (cdar yl))))
		 #'(lambda (l3 l1 l2 princ-wff)
		     (let ((es1 (get l1 'ext-seq))
			   (es2 (get l2 'ext-seq))
			   (es3 (get l3 'ext-seq)))
		       (setf (line-justification l3) (list "OR-" nil (list l1 l2)))
		       (setf (ext-seq-kind es3) 'DIS)
		       (setf (ext-seq-pos-rule es3) nil)
		       (setf (ext-seq-princ-wffs es3) (list princ-wff))
		       (setf (ext-seq-prems es3) (list es1 es2))))))

(defextseq eqo
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Line with ~[A(O) = B(O)]" "Line with A,B" "Line with ~A,~B")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (equals-p (cdr x)))))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-eqo)
  (mhelp "From
(p1) Gamma, A, B
and
(p2) Gamma, ~A, ~B
infer
(p3) Gamma, ~[A = B]"))

(defextseq exto
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Line with [A(O) = B]" "Line with ~A,B" "Line with A,~B")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (and (equals-p x)
						      (eq (unabbreviated-type (cdr x)) 'O))))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-exto)
  (mhelp "From
(p1) Gamma, ~A, B
and
(p2) Gamma, A, ~B
infer
(p3) Gamma, [A = B]"))

(defun extseq-eqo (p3 p1 p2 &optional pwff)
  (extseq-rule-2 p3 p1 p2 pwff
		 #'(lambda (x)
		     (and (not-p x) (equals-p (cdr x))
			  (eq (unabbreviated-type (cddr x)) 'O)))
		 (list #'(lambda (x) (declare (ignore x)) t) #'(lambda (x) (declare (ignore x)) t))
		 (list #'(lambda (x) (not-p x)) #'(lambda (x) (not-p x)))
		 #'(lambda (x)
		     (let ((lft (cdadr x))
			   (rght (cddr x)))
		       (cons (list lft rght)
			     (list (cons 'NOT lft) (cons 'NOT rght)))))
		 #'(lambda (xl yl)
		     (unless (and (not-p (car yl)) (not-p (cadr yl))
				  (wffeq-ab (car xl) (cdar yl))
				  (wffeq-ab (cadr xl) (cdadr yl)))
		       (throwfail "Invalid Premisses for Rule"))
		     (let ((q (inherit-abbrev '= '((O . O) . O) '(O))))
		       (cons 'NOT (acons q (car xl) (cadr xl)))))
		 #'(lambda (l3 l1 l2 princ-wff)
		     (let ((es1 (get l1 'ext-seq))
			   (es2 (get l2 'ext-seq))
			   (es3 (get l3 'ext-seq)))
		       (setf (line-justification l3) (list "EQO" nil (list l1 l2)))
		       (setf (ext-seq-kind es3) 'EQO)
		       (setf (ext-seq-pos-rule es3) nil)
		       (setf (ext-seq-princ-wffs es3) (list princ-wff))
		       (setf (ext-seq-prems es3) (list es1 es2))))))

(defun extseq-exto (p3 p1 p2 &optional pwff)
  (extseq-rule-2 p3 p1 p2 pwff
		 #'(lambda (x)
		     (and (equals-p x)
			  (eq (unabbreviated-type (cdr x)) 'O)))
		 (list #'(lambda (x) (not-p x)) #'(lambda (x) (declare (ignore x)) t))
		 (list #'(lambda (x) (declare (ignore x)) t) #'(lambda (x) (not-p x)))
		 #'(lambda (x)
		     (let ((lft (cdar x))
			   (rght (cdr x)))
		       (cons (list (cons 'NOT lft) rght)
			     (list lft (cons 'NOT rght)))))
		 #'(lambda (xl yl)
		     (unless (and (not-p (car xl)) (not-p (cadr yl))
				  (wffeq-ab (cdar xl) (car yl))
				  (wffeq-ab (cadr xl) (cdadr yl)))
		       (throwfail "Invalid Premisses for Rule"))
		     (let ((q (inherit-abbrev '= '((O . O) . O) '(O))))
		       (acons q (car yl) (cadr xl))))
		 #'(lambda (l3 l1 l2 princ-wff)
		     (let ((es1 (get l1 'ext-seq))
			   (es2 (get l2 'ext-seq))
			   (es3 (get l3 'ext-seq)))
		       (setf (line-justification l3) (list "EXTO" nil (list l1 l2)))
		       (setf (ext-seq-kind es3) 'EXTO)
		       (setf (ext-seq-pos-rule es3) t)
		       (setf (ext-seq-princ-wffs es3) (list princ-wff))
		       (setf (ext-seq-prems es3) (list es1 es2))))))

(defextseq cut
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Main Line" "Line with Positive Cut Formula" "Line with Negative Cut Formula")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (declare (ignore x)) t))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-cut)
  (mhelp "From
(p1) Gamma, C
and
(p2) Gamma, ~C
infer
(p3) Gamma"))

(defun extseq-cut (p3 p1 p2)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq)))
	 (l3 (esnumalias p3))
	 (es3 (when l3 (get l3 'ext-seq)))
	 (gam nil)
	 (gam-done nil)
	 (cutwff nil))
    (when (ext-seq-p es3)
      (setq gam (ext-seq-wffs es3))
      (setq gam-done t))
    (when (and (ext-seq-p es1) (ext-seq-p es2) (not gam-done))
      (let ((wffs1 (ext-seq-wffs es1))
	    (wffs2 (ext-seq-wffs es2)))
	(do ((wffs01 wffs1 (cdr wffs01)))
	    ((null wffs01)
	     (when wffs2
	       (throwfail "Invalid Premisses for Cut Rule")))
	  (if (member (car wffs01) wffs2 :test #'wffeq-ab)
	      (progn
		(setq wffs2 (remove (car wffs01) wffs2 :test #'wffeq-ab :count 1))
		(push (car wffs01) gam))
	    (if (member (cons 'NOT (car wffs01)) wffs2 :test #'wffeq-ab)
		(progn
		  (setq cutwff (car wffs01))
		  (setq wffs2 (remove (cons 'NOT (car wffs01)) wffs2 :test #'wffeq-ab :count 1)))
	      (throwfail "Invalid Premisses for Cut Rule"))))
	(setq gam-done t)))
    (when (and (ext-seq-p es1) (not cutwff))
      (setq cutwff (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) (ext-seq-wffs es1) "Choose Cut Formula"))
      (setq gam (multiset-extract-wffs (ext-seq-wffs es1) cutwff))
      (setq gam-done t))
    (when (and (ext-seq-p es2) (not cutwff))
      (let ((ncutwff (extseq-choose-prem-wff #'(lambda (x) (not-p x)) (ext-seq-wffs es2) "Choose Negation of Cut Formula")))
	(setq cutwff (cdr ncutwff))
	(setq gam (multiset-extract-wffs (ext-seq-wffs es2) ncutwff))
	(setq gam-done t)))
    (unless cutwff
      (prompt-read cutwff nil
		   (msgf "Cut Formula")
		   'gwff0 '$ ((? (msgf "Cut Wff"))
			      (?? (mhelp 'gwff0)))))
    (unless gam-done
      (let ((gamlen nil)
	    (wff nil))
	(prompt-read gamlen nil
		     (msgf "Enter the number of Wffs in Gamma")
		     'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				  (?? (mhelp 'integer+))))
	(dotimes (i gamlen)
	  (prompt-read wff nil
		       (msgf "Enter a Side Wff")
		       'gwff0 '$ ((? (msgf "Side Wff"))
				  (?? (mhelp 'gwff0))))
	  (push wff gam))
	(setq gam-done t)))
    (unless (ext-seq-p es1)
      (setq es1 (make-ext-seq :wffs (cons cutwff gam)))
      (setq l1 (new-extseq-line p1 es1)))
    (unless (ext-seq-p es2)
      (setq es2 (make-ext-seq :wffs (cons (cons 'NOT cutwff) gam)))
      (setq l2 (new-extseq-line p2 es2)))
    (unless (ext-seq-p es3)
      (setq es3 (make-ext-seq :wffs gam))
      (setq l3 (new-extseq-line p3 es3)))
    (setf (ext-seq-kind es3) 'CUT)
    (setf (ext-seq-prems es3) (list es1 es2))
    (set-extseq-line-justification-1 l3 es3 (list l1 l2))
    (update-extseq-proof-plans l3 (list l1 l2))
    (es-find-all-gaps))
  nil)

(defextseq eunif1
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Main Line with Equation" "Line with First Equation" "Line with Second Equation")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan-2 
		#'(lambda (x) (and (not-p x) (equals-p (cdr x))
				   (let ((tp (unabbreviated-type (cddr x))))
				     (and (not (consp tp))
					  (not (eq tp 'O))))))
		#'(lambda (negeqn x)
		    (and (equals-p x)
			 (eq (unabbreviated-type (cddr negeqn))
			     (unabbreviated-type (cdr x))))))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-eunif1)
  (mhelp "From
(p1) Gamma, ~[a = b], [a = c]
and
(p2) Gamma, ~[a = b], [b = d]
infer
(p3) Gamma, ~[a = b], [c = d]"))

(defextseq eunif2
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Main Line with Equation" "Line with First Equation" "Line with Second Equation")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan-2 
		#'(lambda (x) (and (not-p x) (equals-p (cdr x))
				   (let ((tp (unabbreviated-type (cddr x))))
				     (and (not (consp tp))
					  (not (eq tp 'O))))))
		#'(lambda (negeqn x)
		    (and (equals-p x)
			 (eq (unabbreviated-type (cddr negeqn))
			     (unabbreviated-type (cdr x))))))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-eunif2)
  (mhelp "From
(p1) Gamma, ~[a = b], [a = d]
and
(p2) Gamma, ~[a = b], [b = c]
infer
(p3) Gamma, ~[a = b], [c = d]"))

(defun extseq-eunif (p3 p1 p2 rev &optional negwff poswff)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq)))
	 (l3 (esnumalias p3))
	 (es3 (when l3 (get l3 'ext-seq)))
	 (princ-negeqn negwff)
	 (princ-eqn poswff)
	 (prem-eqn1 nil)
	 (prem-eqn2 nil)
	 (tp nil)
	 (gam nil))
    (cond ((ext-seq-p es3)
	   (let* ((wffs (ext-seq-wffs es3))
		  (wffs-negeqns (remove-if-not #'(lambda (x)
						   (and (not-p x)
							(equals-p (cdr x))
							(let ((tp (unabbreviated-type (cddr x))))
							  (and (not (consp tp))
							       (not (eq tp 'O))))))
					       wffs))
		  (tpl (remove-duplicates (mapcar #'(lambda (x) (unabbreviated-type (cddr x)))
						  wffs-negeqns)))
		  (wffs-poseqns (remove-if-not #'(lambda (x)
						   (and (equals-p x)
							(member (unabbreviated-type (cdr x)) tpl)))
					       wffs))
		  (tpl2 (remove-duplicates (mapcar #'(lambda (x) (unabbreviated-type (cdr x)))
						   wffs-poseqns)))
		  (wffs-negeqns2 (remove-if-not #'(lambda (x) (member (unabbreviated-type (cddr x)) tpl2))
						wffs-negeqns)))
	     (unless (and wffs-poseqns wffs-negeqns2)
	       (throwfail "Invalid Conclusion Sequent for EUnif"))
	     (unless (cdr wffs-poseqns)
	       (if princ-eqn
		   (unless (wffeq-ab (car wffs-poseqns) princ-eqn)
		     (throwfail "Invalid Principal Positive Equation"))
		 (setq princ-eqn (car wffs-poseqns)))
	       (setq tp (unabbreviated-type (cdr princ-eqn)))
	       (setq wffs-negeqns2 (remove-if-not #'(lambda (x) (eq (unabbreviated-type (cddr x)) tp))
						  wffs-negeqns2)))
	     (if princ-negeqn
		 (unless (member princ-negeqn wffs-negeqns2 :test #'wffeq-ab)
		   (throwfail "Invalid Principal Negative Equation"))
	       (setq princ-negeqn (extseq-choose-princ-wff #'(lambda (x) (declare (ignore x)) t) wffs-negeqns2
							   "Choose Principal Negative Equation:")))
	     (unless tp
	       (setq tp (unabbreviated-type (cddr princ-negeqn))))
	     (unless princ-eqn
	       (setq wffs-poseqns (remove-if-not #'(lambda (x) (eq (unabbreviated-type (cdr x)) tp))
						 wffs-poseqns))
	       (setq princ-eqn (extseq-choose-princ-wff #'(lambda (x) (declare (ignore x)) t) wffs-poseqns
							"Choose Principal Positive Equation:")))
	     (let ((awff (cdadr princ-negeqn))
		   (bwff (cddr princ-negeqn))
		   (cwff (cdar princ-eqn))
		   (dwff (cdr princ-eqn)))
	       (if rev
		   (progn
		     (setq prem-eqn1 (acons (caar princ-eqn) awff dwff))
		     (setq prem-eqn2 (acons (caar princ-eqn) bwff cwff)))
		 (progn
		   (setq prem-eqn1 (acons (caar princ-eqn) awff cwff))
		   (setq prem-eqn2 (acons (caar princ-eqn) bwff dwff)))))
	     (setq gam (multiset-extract-wffs (ext-seq-wffs es3) princ-eqn princ-negeqn))
	     (when (ext-seq-p es1) ; sanity check
	       (unless (wffeq-ab-multiset (ext-seq-wffs es1) (cons princ-negeqn (cons prem-eqn1 gam)))
		 (throwfail "Line " p1 " is not a valid premiss for " p3)))
	     (when (ext-seq-p es2) ; sanity check
	       (unless (wffeq-ab-multiset (ext-seq-wffs es2) (cons princ-negeqn (cons prem-eqn2 gam)))
		 (throwfail "Line " p2 " is not a valid premiss for " p3)))))
	  ((and princ-eqn princ-negeqn)
	   (unless (equals-p princ-eqn)
	     (throwfail "Invalid Positive Principal Equation"))
	   (setq tp (unabbreviated-type (cdr princ-eqn)))
	   (unless (or (consp tp) (eq tp 'O))
	     (throwfail "Invalid Type For Positive Principal Equation"))
	   (unless (and (not-p princ-negeqn) (equals-p (cdr princ-negeqn))
			(equal tp (unabbreviated-type (cddr princ-negeqn))))
	     (throwfail "Invalid Negative Principal Equation"))
	   (let ((awff (cdadr princ-negeqn))
		 (bwff (cddr princ-negeqn))
		 (cwff (cdar princ-eqn))
		 (dwff (cdr princ-eqn)))
	     (if rev
		 (progn
		   (setq prem-eqn1 (acons (caar princ-eqn) awff dwff))
		   (setq prem-eqn2 (acons (caar princ-eqn) bwff cwff)))
	       (progn
		 (setq prem-eqn1 (acons (caar princ-eqn) awff cwff))
		 (setq prem-eqn2 (acons (caar princ-eqn) bwff dwff)))))
	   (if (ext-seq-p es1)
	       (setq gam (multiset-extract-wffs (ext-seq-wffs es1) prem-eqn1))
	     (if (ext-seq-p es2)
		 (setq gam (multiset-extract-wffs (ext-seq-wffs es2) prem-eqn2))
	       (let ((gamlen nil)
		     (wff nil))
		 (prompt-read gamlen nil
			      (msgf "Enter the number of Wffs in Gamma")
			      'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
					   (?? (mhelp 'integer+))))
		 (dotimes (i gamlen)
		   (prompt-read wff nil
				(msgf "Enter a Side Wff")
				'gwff0 '$ ((? (msgf "Side Wff"))
					   (?? (mhelp 'gwff0))))
		   (push wff gam))))))
	  ((ext-seq-p es1)
	   (let* ((wffs (ext-seq-wffs es1))
		  (wffs-poseqns (remove-if-not #'(lambda (x)
						   (and (equals-p x)
							(let ((tp (unabbreviated-type (cdr x))))
							  (and (not (consp tp))
							       (not (eq tp 'O))))))
					       wffs)))
	     (unless wffs-poseqns
	       (throwfail "Invalid Premiss " p1 " for EUnif"))
	     (setq prem-eqn1 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) wffs-poseqns
						     "Choose First Premiss Positive Equation:"))
	     (setq tp (unabbreviated-type (cdr prem-eqn1)))
	     (setq gam (multiset-extract-wffs (ext-seq-wffs es1) prem-eqn1))
	     (if (ext-seq-p es2)
		 (let* ((wffs (ext-seq-wffs es2))
			(wffs2 (multiset-extract-wffs-1 wffs gam)))
		   (unless (and wffs2 (not (cdr wffs2))
				(equals-p (car wffs2))
				(eq (unabbreviated-type (cdar wffs2)) tp))
		     (throwfail "Invalid Premiss " p2 " for EUnif"))
		   (setq prem-eqn2 (car wffs2)))
	       (progn
		 (prompt-read prem-eqn2 nil
			      (msgf "Positive Equation in Second Premiss")
			      'gwff0 '$ ((? (msgf "The second goal equation for EUnif"))
					 (?? (mhelp 'gwff0))))
		 (unless (and (equals-p prem-eqn2)
			      (eq (unabbreviated-type (cdr prem-eqn2)) tp))
		   (throwfail "Invalid Wff for Second Premiss of EUnif"))))
	     (let ((awff (cdar prem-eqn1))
		   (bwff (cdar prem-eqn2))
		   (cwff (if rev (cdr prem-eqn2) (cdr prem-eqn1)))
		   (dwff (if rev (cdr prem-eqn1) (cdr prem-eqn2))))
	       (setq princ-negeqn (cons 'NOT (acons (caar prem-eqn1) awff bwff)))
	       (setq princ-eqn (acons (caar prem-eqn1) cwff dwff)))))
	  ((ext-seq-p es2)
	   (let* ((wffs (ext-seq-wffs es2))
		  (wffs-poseqns (remove-if-not #'(lambda (x)
						   (and (equals-p x)
							(let ((tp (unabbreviated-type (cdr x))))
							  (and (not (consp tp))
							       (not (eq tp 'O))))))
					       wffs)))
	     (unless wffs-poseqns
	       (throwfail "Invalid Premiss " p2 " for EUnif"))
	     (setq prem-eqn2 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) wffs-poseqns
						     "Choose Second Premiss Positive Equation:"))
	     (setq tp (unabbreviated-type (cdr prem-eqn2)))
	     (setq gam (multiset-extract-wffs (ext-seq-wffs es2) prem-eqn2))
	     (prompt-read prem-eqn1 nil
			  (msgf "Positive Equation in First Premiss")
			  'gwff0 '$ ((? (msgf "The first goal equation for EUnif"))
				     (?? (mhelp 'gwff0))))
	     (unless (and (equals-p prem-eqn1)
			  (eq (unabbreviated-type (cdr prem-eqn1)) tp))
	       (throwfail "Invalid Wff for First Premiss of EUnif"))
	     (let ((awff (cdar prem-eqn1))
		   (bwff (cdar prem-eqn2))
		   (cwff (if rev (cdr prem-eqn2) (cdr prem-eqn1)))
		   (dwff (if rev (cdr prem-eqn1) (cdr prem-eqn2))))
	       (setq princ-negeqn (cons 'NOT (acons (caar prem-eqn1) awff bwff)))
	       (setq princ-eqn (acons (caar prem-eqn1) cwff dwff)))))
	  (t
	   (unless princ-negeqn
	     (prompt-read princ-negeqn nil
			  (msgf "Principal Negative Equation")
			  'gwff0 '$ ((? (msgf "Principal Negative Equation for EUnif"))
				     (?? (mhelp 'gwff0)))))
	   (unless (and (not-p princ-negeqn) (equals-p (cdr princ-negeqn)))
	     (throwfail "Invalid Principal Negative Equation for EUnif"))
	   (setq tp (unabbreviated-type (cddr princ-negeqn)))
	   (when (or (consp tp) (eq tp 'O))
	     (throwfail "Invalid Type for EUnif Negative Equation - must be a base type other than O"))
	   (unless princ-eqn
	     (prompt-read princ-eqn nil
			  (msgf "Principal Positive Equation")
			  'gwff0 '$ ((? (msgf "Principal Positive Equation for EUnif"))
				     (?? (mhelp 'gwff0)))))
	   (unless (and (equals-p princ-eqn) (eq (unabbreviated-type (cdr princ-eqn)) tp))
	     (throwfail "Invalid Principal Positive Equation for EUnif"))
	     (let ((awff (cdadr princ-negeqn))
		   (bwff (cddr princ-negeqn))
		   (cwff (cdar princ-eqn))
		   (dwff (cdr princ-eqn))
		   (gamlen nil)
		   (wff nil))
	       (if rev
		   (progn
		     (setq prem-eqn1 (acons (caar princ-eqn) awff dwff))
		     (setq prem-eqn2 (acons (caar princ-eqn) bwff cwff)))
		 (progn
		   (setq prem-eqn1 (acons (caar princ-eqn) awff cwff))
		   (setq prem-eqn2 (acons (caar princ-eqn) bwff dwff))))
	       (prompt-read gamlen nil
			    (msgf "Enter the number of Wffs in Gamma")
			    'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
					 (?? (mhelp 'integer+))))
	       (dotimes (i gamlen)
		 (prompt-read wff nil
			      (msgf "Enter a Side Wff")
			      'gwff0 '$ ((? (msgf "Side Wff"))
					 (?? (mhelp 'gwff0))))
		 (push wff gam)))))
    (unless (ext-seq-p es1)
      (setq es1 (make-ext-seq :wffs (cons prem-eqn1 gam)))
      (setq l1 (new-extseq-line p1 es1)))
    (unless (ext-seq-p es2)
      (setq es2 (make-ext-seq :wffs (cons prem-eqn2 gam)))
      (setq l2 (new-extseq-line p2 es2)))
    (unless (ext-seq-p es3)
      (setq es3 (make-ext-seq :wffs (cons princ-eqn (cons princ-negeqn gam))))
      (setq l3 (new-extseq-line p3 es3)))
    (setf (ext-seq-kind es3) (if rev 'EUNIF2 'EUNIF1))
    (setf (ext-seq-princ-wffs es3) (list princ-negeqn princ-eqn))
    (setf (ext-seq-prems es3) (list es1 es2))
    (set-extseq-line-justification-1 l3 es3 (list l1 l2))
    (update-extseq-proof-plans l3 (list l1 l2))
    (es-find-all-gaps))
  nil)

(defun extseq-eunif1 (p3 p1 p2 &optional negwff poswff)
  (extseq-eunif p3 p1 p2 nil negwff poswff))

(defun extseq-eunif2 (p3 p1 p2 &optional negwff poswff)
  (extseq-eunif p3 p1 p2 t negwff poswff))

(defextseq initeq
  (extseq-argtypes line linelist)
  (extseq-argnames p pl)
  (extseq-arghelp "Line with [P A1 . . . An], ~[P B1 . . . Bn]" "n Lines for premisses")
  (extseq-defaultfns
   (lambda (p pl)
     (list (if (eq p '$)
	       (extseq-defaultplan-2
		#'(lambda (x)
		    (and (not (or (not-p x) (boundwff-p x) (equals-p x)))
			 (let ((h (head x)))
			   (and (not (or (member h '(AND OR IMPLIES EQUIV))
					 (anyabbrev-p h)))))))
		#'(lambda (wff y)
		    (and (not-p y)
			 (not (or (not-p (cdr y)) (boundwff-p (cdr y)) (equals-p (cdr y))))
			 (eq (head (cdr y)) (head wff)))))
	     p)
	   (if (and (eq pl '$) (numberp p))
	       (let* ((l (esnumalias p))
		      (es (get l 'ext-seq)))
		 (if (ext-seq-p es)
		     (let* ((wffs (ext-seq-wffs es))
			    (wff (find-if #'(lambda (x)
					      (and (not (or (not-p x) (boundwff-p x) (equals-p x)))
						   (let ((h (head x)))
						     (and (not (or (member h '(AND OR IMPLIES EQUIV))
								   (anyabbrev-p h)))
							  (find-if #'(lambda (y)
								       (and (not-p y)
									    (not (or (not-p (cdr y))
										     (boundwff-p (cdr y))
										     (equals-p (cdr y))))
									    (eq (head (cdr y)) h)))
								   wffs)))))
					  wffs)))
		       (if wff
			   (extseq-defaultnewplans p (length (args wff)))
			 '$))
		   '$))
	     pl))))
  (extseq-mainfns extseq-initeq)
  (mhelp "From
(p1) Gamma, [A1 = B1]
. . .
(pn) Gamma, [An = Bn]
infer
(p) Gamma, [P A1 . . . An], ~[P B1 . . . Bn]"))
		       
(defextseq dec
  (extseq-argtypes line linelist)
  (extseq-argnames p pl)
  (extseq-arghelp "Line with [[H A1 . . . An] = [H B1 . . . Bn]]" "n Lines for premisses")
  (extseq-defaultfns
   (lambda (p pl)
     (list (if (eq p '$)
	       (extseq-defaultplan
		#'(lambda (x)
		    (when (equals-p x)
		      (let ((tp (unabbreviated-type (cdr x))))
			(when (and (not (consp tp))
				   (not (eq tp 'O)))
			  (let* ((lft (cdar x))
				 (rght (cdr x))
				 (h1 (head lft))
				 (h2 (head rght)))
			    (and (eq h1 h2) (not (anyabbrev-p h1)))))))))
	     p)
	   (if (and (eq pl '$) (numberp p))
	       (let* ((l (esnumalias p))
		      (es (get l 'ext-seq)))
		 (if (ext-seq-p es)
		     (let* ((wffs (ext-seq-wffs es))
			    (wff (find-if #'(lambda (x)
					      (when (equals-p x)
						(let ((tp (unabbreviated-type (cdr x))))
						  (when (and (not (consp tp))
							     (not (eq tp 'O)))
						    (let* ((lft (cdar x))
							   (rght (cdr x))
							   (h1 (head lft))
							   (h2 (head rght)))
						      (and (eq h1 h2) (not (anyabbrev-p h1))))))))
					  wffs)))
		       (if wff
			   (extseq-defaultnewplans p (length (args (cdr wff))))
			 '$))
		   '$))
	     pl))))
  (extseq-mainfns extseq-dec)
  (mhelp "From
(p1) Gamma, [A1 = B1]
. . .
(pn) Gamma, [An = Bn]
infer
(p) Gamma, [[H A1 . . . An] = [H B1 . . . Bn]]"))

(defun extseq-initeq (p pl &optional negwff poswff)
  (let* ((n (length pl))
	 (l (esnumalias p))
	 (es (when l (get l 'ext-seq)))
	 (ll nil)
	 (esa (make-array n))
	 (esl nil)
	 (es1 nil)
	 (i1 nil)
	 (princ-negwff negwff)
	 (princ-poswff poswff)
	 (princ-eqnl nil)
	 (h nil)
	 (gam nil))
    (dotimes (i n)
      (let ((li (esnumalias (nth i pl))))
	(when li
	  (let ((esi (get li 'ext-seq)))
	    (when (ext-seq-p esi)
	      (setq es1 esi)
	      (setq i1 i)
	      (setf (aref esa i) esi))))))
    (if (ext-seq-p es)
	(let* ((wffs (ext-seq-wffs es))
	       (wffs-neg (remove-if-not #'(lambda (x)
					    (and (not-p x)
						 (not (not-p (cdr x)))
						 (not (equals-p (cdr x)))
						 (not (boundwff-p (cdr x)))
						 (let ((h (head (cdr x))))
						   (and (not (member h '(OR AND IMPLIES EQUIV)))
							(not (anyabbrev-p h))))))
					wffs))
	       (hl (remove-duplicates (mapcar #'(lambda (x) (head (cdr x))) wffs-neg)))
	       (wffs-pos (remove-if-not #'(lambda (x)
					    (and (not (not-p x))
						 (not (equals-p x))
						 (not (boundwff-p x))
						 (member (head x) hl)))
					wffs))
	       (hl2 (remove-duplicates (mapcar #'(lambda (x) (head x)) wffs-pos)))
	       (wffs-neg2 (remove-if-not #'(lambda (x)
					     (member (head (cdr x)) hl2))
					 wffs-neg)))
	  (unless (and wffs-pos wffs-neg2)
	    (throwfail "Invalid conclusion " p " for InitEq"))
	  (if princ-poswff
	      (unless (member princ-poswff wffs-pos :test #'wffeq-ab)
		(throwfail "Bad Positive Principal Formula"))
	    (setq princ-poswff 
		  (extseq-choose-princ-wff #'(lambda (x) (declare (ignore x)) t) wffs-pos "Choose Principal Positive Atom:")))
	  (setq h (head princ-poswff))
	  (setq wffs-neg2 (remove-if-not #'(lambda (x) (eq (head (cdr x)) h)) wffs-neg2))
	  (if princ-negwff
	      (unless (member princ-negwff wffs-neg2 :test #'wffeq-ab)
		(throwfail "Bad Negative Principal Formula"))
	    (setq princ-negwff 
		  (extseq-choose-princ-wff #'(lambda (x) (declare (ignore x)) t) wffs-neg2 "Choose Principal Negative Atom:")))
	  (do ((wff1 princ-poswff (car wff1))
	       (wff2 (cdr princ-negwff) (car wff2)))
	      ((or (not (consp wff1))
		   (not (consp wff2))))
	    (let* ((tp (unabbreviated-type (cdr wff1)))
		   (q (inherit-abbrev '= (acons 'O tp tp) (list tp)))
		   (eqn (acons q (cdr wff1) (cdr wff2))))
	      (push eqn princ-eqnl)))
	  (unless (= (length princ-eqnl) n)
	    (throwfail "Number of arguments of " (h . gwff) " does not match the number of premisses " n))
	  (setq gam (multiset-extract-wffs wffs princ-poswff princ-negwff)))
      (progn
	(unless princ-poswff
	  (prompt-read princ-poswff nil
		       (msgf "Principal Positive Atom")
		       'gwff0 '$ ((? (msgf "Principal Positive Atom for InitEq"))
				  (?? (mhelp 'gwff0)))))
	(when (or (not-p princ-poswff) (equals-p princ-poswff)
		  (boundwff-p princ-poswff))
	  (throwfail "Invalid Principal Positive Atom for InitEq"))
	(setq h (head princ-poswff))
	(when (or (member h '(OR AND IMPLIES EQUIV))
		  (anyabbrev-p h))
	  (throwfail "Invalid Principal Positive Atom for InitEq"))
	(unless princ-negwff
	  (prompt-read princ-negwff nil
		       (msgf "Principal Negative Atom")
		       'gwff0 '$ ((? (msgf "Principal Negative Atom for InitEq"))
				  (?? (mhelp 'gwff0)))))
	(when (or (not (not-p princ-negwff))
		  (not-p (cdr princ-negwff)) (equals-p (cdr princ-negwff))
		  (boundwff-p (cdr princ-negwff))
		  (not (eq (head (cdr princ-negwff)) h)))
	  (throwfail "Invalid Principal Negative Atom for InitEq"))
	(do ((wff1 princ-poswff (car wff1))
	     (wff2 (cdr princ-negwff) (car wff2)))
	    ((or (not (consp wff1))
		 (not (consp wff2))))
	  (let* ((tp (unabbreviated-type (cdr wff1)))
		 (q (inherit-abbrev '= (acons 'O tp tp) (list tp)))
		 (eqn (acons q (cdr wff1) (cdr wff2))))
	    (push eqn princ-eqnl)))
	(unless (= (length princ-eqnl) n)
	  (throwfail "Number of arguments of " (h . gwff) " does not match the number of premisses " n))
	(if es1
	    (let ((eqni (nth i1 princ-eqnl)))
	      (setq gam (multiset-extract-wffs (ext-seq-wffs es1) eqni)))
	  (let ((wff nil)
		(gamlen nil))
	    (prompt-read gamlen nil
			 (msgf "Enter the number of Wffs in Gamma")
			 'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				      (?? (mhelp 'integer+))))
	    (dotimes (i gamlen)
	      (prompt-read wff nil
			   (msgf "Enter a Side Wff")
			   'gwff0 '$ ((? (msgf "Side Wff"))
				      (?? (mhelp 'gwff0))))
	      (push wff gam))))
	(setq es (make-ext-seq :wffs (cons princ-poswff (cons princ-negwff gam))))
	(setq l (new-extseq-line p es))))
    (dotimes (i n)
      (let ((esi (aref esa i))
	    (pi0 (nth i pl))
	    (eqni (nth i princ-eqnl)))
	(if (ext-seq-p esi)
	    (progn
	      (push esi esl)
	      (push (esnumalias pi0) ll)
	      (unless (wffeq-ab-multiset (ext-seq-wffs esi) (cons eqni gam))
		(throwfail "Problem with Premiss " (nth i pl))))
	  (progn
	    (setq esi (make-ext-seq :wffs (cons eqni gam)))
	    (setf (aref esa i) esi)
	    (push esi esl)
	    (push (new-extseq-line pi0 esi) ll)))))
    (setq esl (reverse esl))
    (setq ll (reverse ll))
    (setf (ext-seq-prems es) esl)
    (setf (ext-seq-kind es) 'INITEQ)
    (setf (ext-seq-princ-wffs es) (list princ-negwff princ-poswff))
    (set-extseq-line-justification-1 l es ll)
    (update-extseq-proof-plans l (mapcar #'(lambda (x) (esnumalias x)) pl))
    (es-find-all-gaps))
  nil)

(defun extseq-dec (p pl &optional pwff)
  (let* ((n (length pl))
	 (l (esnumalias p))
	 (es (when l (get l 'ext-seq)))
	 (ll nil)
	 (esa (make-array n))
	 (esl nil)
	 (es1 nil)
	 (i1 nil)
	 (princ-wff pwff)
	 (princ-eqnl nil)
	 (h nil)
	 (gam nil))
    (dotimes (i n)
      (let ((li (esnumalias (nth i pl))))
	(when li
	  (let ((esi (get li 'ext-seq)))
	    (when (ext-seq-p esi)
	      (setq es1 esi)
	      (setq i1 i)
	      (setf (aref esa i) esi))))))
    (if (ext-seq-p es)
	(let* ((wffs (ext-seq-wffs es))
	       (wffs-eq (remove-if-not #'(lambda (x)
					   (and (equals-p x)
						(let ((btp (unabbreviated-type (cdr x)))
						      (h1 (head (cdar x)))
						      (h2 (head (cdr x))))
						  (and (not (consp btp))
						       (not (eq btp 'O))
						       (eq h1 h2)))))
				       wffs)))
	  (unless (and wffs-eq)
	    (throwfail "Invalid conclusion " p " for Dec"))
	  (if princ-wff
	      (unless (member princ-wff wffs-eq :test #'wffeq-ab)
		(throwfail "Invalid Principal Formula for Dec"))
	    (setq princ-wff 
		  (extseq-choose-princ-wff #'(lambda (x) (declare (ignore x)) t) wffs-eq "Choose Principal Equation:")))
	  (setq h (head (cdr princ-wff)))
	  (do ((wff1 (cdar princ-wff) (car wff1))
	       (wff2 (cdr princ-wff) (car wff2)))
	      ((or (not (consp wff1))
		   (not (consp wff2))))
	    (let* ((tp (unabbreviated-type (cdr wff1)))
		   (q (inherit-abbrev '= (acons 'O tp tp) (list tp)))
		   (eqn (acons q (cdr wff1) (cdr wff2))))
	      (push eqn princ-eqnl)))
	  (unless (= (length princ-eqnl) n)
	    (throwfail "Number of arguments of " (h . gwff) " does not match the number of premisses " n))
	  (setq gam (multiset-extract-wffs wffs princ-wff)))
      (progn
	(unless princ-wff
	  (prompt-read princ-wff nil
		       (msgf "Principal Positive Equation")
		       'gwff0 '$ ((? (msgf "Principal Positive Equation for Dec"))
				  (?? (mhelp 'gwff0)))))
	(unless (and (equals-p princ-wff)
		     (let ((btp (unabbreviated-type (cdr princ-wff)))
			   (h1 (head (cdar princ-wff)))
			   (h2 (head (cdr princ-wff))))
		       (and (not (consp btp))
			    (not (eq btp 'O))
			    (eq h1 h2))))
	  (throwfail "Invalid Principal Formula for Dec"))
	(setq h (head (cdr princ-wff)))
	(do ((wff1 (cdar princ-wff) (car wff1))
	     (wff2 (cdr princ-wff) (car wff2)))
	    ((or (not (consp wff1))
		 (not (consp wff2))))
	  (let* ((tp (unabbreviated-type (cdr wff1)))
		 (q (inherit-abbrev '= (acons 'O tp tp) (list tp)))
		 (eqn (acons q (cdr wff1) (cdr wff2))))
	    (push eqn princ-eqnl)))
	(unless (= (length princ-eqnl) n)
	  (throwfail "Number of arguments of " (h . gwff) " does not match the number of premisses " n))
	(if es1
	    (let ((eqni (nth i1 princ-eqnl)))
	      (setq gam (multiset-extract-wffs (ext-seq-wffs es1) eqni)))
	  (let ((wff nil)
		(gamlen nil))
	    (prompt-read gamlen nil
			 (msgf "Enter the number of Wffs in Gamma")
			 'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				      (?? (mhelp 'integer+))))
	    (dotimes (i gamlen)
	      (prompt-read wff nil
			   (msgf "Enter a Side Wff")
			   'gwff0 '$ ((? (msgf "Side Wff"))
				      (?? (mhelp 'gwff0))))
	      (push wff gam))))
	(setq es (make-ext-seq :wffs (cons princ-wff gam)))
	(setq l (new-extseq-line p es))))
    (dotimes (i n)
      (let ((esi (aref esa i))
	    (pi0 (nth i pl))
	    (eqni (nth i princ-eqnl)))
	(if (ext-seq-p esi)
	    (progn
	      (push esi esl)
	      (push (esnumalias pi0) ll)
	      (unless (wffeq-ab-multiset (ext-seq-wffs esi) (cons eqni gam))
		(throwfail "Problem with Premiss " (nth i pl))))
	  (progn
	    (setq esi (make-ext-seq :wffs (cons eqni gam)))
	    (setf (aref esa i) esi)
	    (push esi esl)
	    (push (new-extseq-line pi0 esi) ll)))))
    (setq esl (reverse esl))
    (setq ll (reverse ll))
    (setf (ext-seq-prems es) esl)
    (setf (ext-seq-kind es) 'DEC)
    (setf (ext-seq-princ-wffs es) (list princ-wff))
    (set-extseq-line-justification-1 l es ll)
    (update-extseq-proof-plans l (mapcar #'(lambda (x) (esnumalias x)) pl))
    (es-find-all-gaps))
  nil)

(context ext-seq-derived-rules)

; false-, and-, and+, implies-, implies+, equiv-, equiv+, exists-, exists+
(defextseq false-
  (extseq-argtypes line)
  (extseq-argnames p)
  (extseq-arghelp "Line with ~FALSEHOOD")
  (extseq-defaultfns
   (lambda (p)
     (list (if (eq p '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (eq (cdr x) 'FALSEHOOD))))
	     p))))
  (extseq-mainfns extseq-false)
  (mhelp "Infer (p) Gamma, ~FALSEHOOD"))

(defextseq and-
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with ~[A AND B]" "Line with ~A,~B")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (and-p (cdr x)))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-and-)
  (mhelp "From
(p1) Gamma, ~A, ~B
infer
(p3) Gamma, ~[A AND B]"))

(defextseq and+
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Line with [A AND B]" "Line with A" "Line with B")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (and-p x)))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-and+)
  (mhelp "From
(p1) Gamma, A
and
(p2) Gamma, B
infer
(p3) Gamma, [A AND B]"))

(defextseq implies+
  (extseq-argtypes line line)
  (extseq-argnames p2 p1)
  (extseq-arghelp "Line with [A IMPLIES B]" "Line with ~A,B")
  (extseq-defaultfns
   (lambda (p2 p1)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (implies-p x)))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1))))
  (extseq-mainfns extseq-implies+)
  (mhelp "From
(p1) Gamma, ~A, B
infer
(p3) Gamma, [A IMPLIES B]"))

(defextseq implies-
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Line with ~[A IMPLIES B]" "Line with A" "Line with ~B")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (implies-p (cdr x)))))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-implies-)
  (mhelp "From
(p1) Gamma, A
and
(p2) Gamma, ~B
infer
(p3) Gamma, ~[A IMPLIES B]"))

(defextseq equiv+
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Line with [A(O) EQUIV B]" "Line with ~A,B" "Line with A,~B")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (equiv-p x)))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-equiv+)
  (mhelp "From
(p1) Gamma, ~A, B
and
(p2) Gamma, A, ~B
infer
(p3) Gamma, [A EQUIV B]"))

(defextseq equiv-
  (extseq-argtypes line line line)
  (extseq-argnames p3 p1 p2)
  (extseq-arghelp "Line with ~[A(O) EQUIV B(O)]" "Line with A,B" "Line with ~A,~B")
  (extseq-defaultfns
   (lambda (p3 p1 p2)
     (cons (if (eq p3 '$)
	       (extseq-defaultplan #'(lambda (x) (and (not-p x) (equiv-p (cdr x)))))
	     p3)
	   (if (numberp p3)
	       (if (eq p1 '$)
		   (if (eq p2 '$)
		       (extseq-defaultnewplans p3 2)
		     (list (extseq-defaultnewplan p3) p2))
		 (if (eq p2 '$)
		     (list p1 (extseq-defaultnewplan p3))
		   (list p1 p2)))
	     (list p1 p2)))))
  (extseq-mainfns extseq-equiv-)
  (mhelp "From
(p1) Gamma, A, B
and
(p2) Gamma, ~A, ~B
infer
(p3) Gamma, ~[A EQUIV B]"))

(defextseq exists-
  (extseq-argtypes line line gwff)
  (extseq-argnames p2 p1 y)
  (extseq-arghelp "Line with ~[EXISTS x M]" "Line with ~[y/x]M" "Choice Variable y")
  (extseq-defaultfns
   (lambda (p2 p1 y)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x)
				       (and (not-p x)
					    (e-bd-wff-p (cdr x)))))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1)
	   (if (and (eq y '$) (numberp p2))
	       (let* ((l2 (esnumalias p2))
		      (es2 (when l2 (get l2 'ext-seq)))
		      (wffs2 (when (ext-seq-p es2) (ext-seq-wffs es2)))
		      (princ-wffs2 (remove-duplicates
				    (remove-if-not #'(lambda (x) (and (not-p x) (e-bd-wff-p (cdr x)))) wffs2)
				    :test #'wffeq-ab)))
		 (if (and princ-wffs2 (not (cdr princ-wffs2)))
		     (bindvar (cdar princ-wffs2))
		   '$))
	     y))))
  (extseq-mainfns extseq-exists-)
  (mhelp "Infer (p2) Gamma,~[EXISTS x M] from (p1) Gamma,~[y/x]M."))

(defextseq exists+
  (extseq-argtypes line line gwff)
  (extseq-argnames p2 p1 trm)
  (extseq-arghelp "Line with [EXISTS x M]" "Line with [trm/x]M" "Instantiation trm")
  (extseq-defaultfns
   (lambda (p2 p1 trm)
     (list (if (eq p2 '$)
	       (extseq-defaultplan #'(lambda (x) (e-bd-wff-p x)))
	     p2)
	   (if (and (eq p1 '$) (numberp p2))
	       (extseq-defaultnewplan p2)
	     p1)
	   trm)))
  (extseq-mainfns extseq-exists+)
  (mhelp "Infer (p2) Gamma,[EXISTS x M] from (p1) Gamma,[trm/x]M."))

(defun extseq-false (p)
  (extseq-rule-0 p '(NOT . FALSEHOOD)
		 #'(lambda (x) (and (not-p x) (eq (cdr x) 'FALSEHOOD)))
		 #'(lambda () '(NOT . FALSEHOOD))
		 #'(lambda (l princ-wff)
		     (let* ((es (get l 'ext-seq))
			    (gam (multiset-extract-wffs (ext-seq-wffs es) princ-wff))
			    (nntr (cons 'NOT (cons 'NOT 'TRUTH)))
			    (es2 (make-ext-seq :wffs (cons 'TRUTH gam)
					       :princ-wffs (list 'TRUTH)
					       :kind 'TRUE
					       :pos-rule t))
			    (es3 (make-ext-seq :wffs (cons nntr gam)
					       :princ-wffs (list nntr)
					       :kind 'NEG
					       :pos-rule nil
					       :prems (list es2))))
		       (setf (line-justification l) (list "FALSE-" nil nil))
		       (setf (ext-seq-kind es) 'INTERNALIZE)
		       (setf (ext-seq-princ-wffs es) (list '(NOT . FALSEHOOD)))
		       (setf (ext-seq-pos-rule es) nil)
		       (setf (ext-seq-prems es) (list es3))))))

(defun extseq-and- (p2 p1 &optional pwff)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq))))
    (if (ext-seq-p es2)
	(let* ((wffs (ext-seq-wffs es2))
	       (princ-wff (or pwff
			      (extseq-choose-princ-wff #'(lambda (x) (and (not-p x) (and-p (cdr x))))
						       wffs)))
	       (gam (multiset-extract-wffs (ext-seq-wffs es2) princ-wff))
	       (wff1 (cdadr princ-wff))
	       (wff2 (cddr princ-wff))
	       (nwff1 (cons 'NOT wff1))
	       (nwff2 (cons 'NOT wff2)))
	  (if (ext-seq-p es1)
	      (let ((wffs1 (ext-seq-wffs es1)))
		(unless (wffeq-ab-multiset gam (multiset-extract-wffs wffs1 nwff1 nwff2))
		  (throwfail "Gammas do not match")))
	    (progn
	      (setq es1 (make-ext-seq :wffs (cons nwff1 (cons nwff2 gam))))
	      (setq l1 (new-extseq-line p1 es1))))
	  (let ((es3 (make-ext-seq-con-neg wff1 wff2 es1)))
	    (setf (ext-seq-kind es2) 'INTERNALIZE)
	    (setf (ext-seq-pos-rule es2) nil)
	    (setf (ext-seq-princ-wffs es2) (list princ-wff))
	    (setf (ext-seq-prems es2) (ext-seq-prems es3))
	    (setf (line-justification l2) (list "AND-" nil (list l1)))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps)))
      (if (ext-seq-p es1)
	  (let* ((wffs (ext-seq-wffs es1))
		 (nwffs (mapcar #'cdr (remove-if-not #'(lambda (x) (not-p x)) wffs)))
		 (es2 nil)
		 (princ-wff pwff)
		 (wff1 nil)
		 (wff2 nil))
	    (if (and princ-wff (and (not-p princ-wff) (and-p (cdr princ-wff))))
		(progn
		  (setq wff1 (cdadr princ-wff))
		  (setq wff2 (cddr princ-wff)))
	      (progn
		(setq wff1 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) nwffs "Choose Left Conjunct:"))
		(setq wff2 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) (remove wff1 nwffs :count 1)
						   "Choose Right Conjunct:"))
		(setq princ-wff (cons 'NOT (acons 'AND wff1 wff2)))))
	    (setq es2 (make-ext-seq-con-neg wff1 wff2 es1))
	    (setq l2 (new-extseq-line p2 es2))
	    (setf (line-justification l2) (list "AND-" nil (list l1)))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps))
	(let ((princ-wff nil)
	      (gam nil)
	      (wff nil)
	      (gamlen nil))
	  (if pwff
	      (setq princ-wff pwff)
	    (prompt-read princ-wff nil
			 (msgf "Enter Principal Wff")
			 'gwff0 '$ ((? (msgf "Principal Formula of Rule"))
				    (?? (mhelp 'gwff0)))))
	  (unless (and (not-p princ-wff) (and-p (cdr princ-wff)))
	    (throwfail (princ-wff . gwff) " is not a negation of a conjunction."))
	  (prompt-read gamlen nil
		       (msgf "Enter the number of Wffs in Gamma")
		       'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				    (?? (mhelp 'integer+))))
	  (dotimes (i gamlen)
	    (prompt-read wff nil
			 (msgf "Enter a Side Wff")
			 'gwff0 '$ ((? (msgf "Side Wff"))
				    (?? (mhelp 'gwff0))))
	    (push wff gam))
	  (let* ((wff1 (cdadr princ-wff))
		 (wff2 (cddr princ-wff))
		 (nwff1 (cons 'NOT wff1))
		 (nwff2 (cons 'NOT wff2))
		 (es1 (make-ext-seq :wffs (cons nwff1 (cons nwff2 gam))))
		 (es2 (make-ext-seq-con-neg wff1 wff2 es1))
		 (l1 (new-extseq-line p1 es1))
		 (l2 (new-extseq-line p2 es2)))
	    (setf (line-justification l2) (list "AND-" nil (list l1)))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps))))))
  nil)

(defun extseq-implies+ (p2 p1 &optional pwff)
  (let* ((l1 (esnumalias p1))
	 (es1 (when l1 (get l1 'ext-seq)))
	 (l2 (esnumalias p2))
	 (es2 (when l2 (get l2 'ext-seq))))
    (if (ext-seq-p es2)
	(let* ((wffs (ext-seq-wffs es2))
	       (princ-wff (or pwff (extseq-choose-princ-wff #'(lambda (x) (implies-p x)) wffs)))
	       (gam (multiset-extract-wffs (ext-seq-wffs es2) princ-wff))
	       (wff1 (cdar princ-wff))
	       (nwff1 (cons 'NOT wff1))
	       (wff2 (cdr princ-wff)))
	  (if (ext-seq-p es1)
	      (let ((wffs1 (ext-seq-wffs es1)))
		(unless (wffeq-ab-multiset gam (multiset-extract-wffs wffs1 nwff1 wff2))
		  (throwfail "Gammas do not match")))
	    (progn
	      (setq es1 (make-ext-seq :wffs (cons nwff1 (cons wff2 gam))))
	      (setq l1 (new-extseq-line p1 es1))))
	  (let ((es3 (make-ext-seq-imp-pos wff1 wff2 es1)))
	    (setf (ext-seq-kind es2) 'INTERNALIZE)
	    (setf (ext-seq-pos-rule es2) t)
	    (setf (ext-seq-princ-wffs es2) (list princ-wff))
	    (setf (ext-seq-prems es2) (ext-seq-prems es3))
	    (setf (line-justification l2) (list "IMPLIES+" nil (list l1)))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps)))
      (if (ext-seq-p es1)
	  (let* ((wffs (ext-seq-wffs es1))
		 (es2 nil)
		 (princ-wff pwff)
		 (wff1 nil)
		 (nwff1 nil)
		 (wff2 nil))
	    (if (and princ-wff (implies-p princ-wff))
		(progn
		  (setq wff1 (cdar princ-wff))
		  (setq wff2 (cdr princ-wff)))
	      (progn
		(setq wff1 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) 
						   (mapcar #'cdr (remove-if-not #'(lambda (x) (not-p x)) wffs))
						   "Choose Antecedent:"))
		(setq nwff1 (cons 'NOT wff1))
		(setq wff2 (extseq-choose-prem-wff #'(lambda (x) (declare (ignore x)) t) (remove nwff1 wffs :test #'wffeq-ab :count 1)
						   "Choose Conclusion:"))
		(setq princ-wff (acons 'IMPLIES wff1 wff2))))
	    (setq es2 (make-ext-seq-imp-pos wff1 wff2 es1))
	    (setq l2 (new-extseq-line p2 es2))
	    (setf (line-justification l2) (list "IMPLIES+" nil (list l1)))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps))
	(let ((princ-wff nil)
	      (gam nil)
	      (wff nil)
	      (gamlen nil))
	  (if pwff
	      (setq princ-wff pwff)
	    (prompt-read princ-wff nil
			 (msgf "Enter Principal Wff")
			 'gwff0 '$ ((? (msgf "Principal Formula of Rule"))
				    (?? (mhelp 'gwff0)))))
	  (unless (implies-p princ-wff)
	    (throwfail (princ-wff . gwff) " is not an implication."))
	  (prompt-read gamlen nil
		       (msgf "Enter the number of Wffs in Gamma")
		       'integer+ 0 ((? (msgf "Number of side wffs of sequents"))
				    (?? (mhelp 'integer+))))
	  (dotimes (i gamlen)
	    (prompt-read wff nil
			 (msgf "Enter a Side Wff")
			 'gwff0 '$ ((? (msgf "Side Wff"))
				    (?? (mhelp 'gwff0))))
	    (push wff gam))
	  (let* ((wff1 (cdar princ-wff))
		 (nwff1 (cons 'NOT wff1))
		 (wff2 (cdr princ-wff))
		 (es1 (make-ext-seq :wffs (cons nwff1 (cons wff2 gam))))
		 (es2 (make-ext-seq-imp-pos wff1 wff2 es1))
		 (l1 (new-extseq-line p1 es1))
		 (l2 (new-extseq-line p2 es2)))
	    (setf (line-justification l2) (list "IMPLIES+" nil (list l1)))
	    (update-extseq-proof-plans l2 (list l1))
	    (es-find-all-gaps))))))
  nil)

(defun extseq-and+ (p3 p1 p2 &optional pwff)
  (extseq-rule-2 p3 p1 p2 pwff
		 #'(lambda (x) (and-p x))
		 (list #'(lambda (x) (declare (ignore x)) t))
		 (list #'(lambda (x) (declare (ignore x)) t))
		 #'(lambda (x)
		     (cons (list (cdar x)) (list (cdr x))))
		 #'(lambda (xl yl)
		     (acons 'AND (car xl) (car yl)))
		 #'(lambda (l3 l1 l2 princ-wff)
		     (let* ((es1 (get l1 'ext-seq))
			    (es2 (get l2 'ext-seq))
			    (es3 (get l3 'ext-seq))
			    (gam (multiset-extract-wffs (ext-seq-wffs es3) princ-wff))
			    (nlft (cons 'NOT (cdar princ-wff)))
			    (nrght (cons 'NOT (cdr princ-wff)))
			    (nnlft (cons 'NOT nlft))
			    (nnrght (cons 'NOT nrght))
			    (ndisn (cons 'NOT (acons 'OR nlft nrght)))
			    (es4 (make-ext-seq :wffs (cons nnlft gam) :princ-wffs (list nnlft)
					       :kind 'NEG :pos-rule nil :prems (list es1)))
			    (es5 (make-ext-seq :wffs (cons nnrght gam) :princ-wffs (list nnrght)
					       :kind 'NEG :pos-rule nil :prems (list es2)))
			    (es6 (make-ext-seq :wffs (cons ndisn gam)
					       :princ-wffs (list ndisn)
					       :kind 'DIS
					       :pos-rule nil
					       :prems (list es4 es5))))
		       (setf (line-justification l3) (list "AND+" nil (list l1 l2)))
		       (setf (ext-seq-kind es3) 'INTERNALIZE)
		       (setf (ext-seq-pos-rule es3) t)
		       (setf (ext-seq-princ-wffs es3) (list princ-wff))
		       (setf (ext-seq-prems es3) (list es6))))))

(defun extseq-implies- (p3 p1 p2 &optional pwff)
  (extseq-rule-2 p3 p1 p2 pwff
		 #'(lambda (x) (and (not-p x) (implies-p (cdr x))))
		 (list #'(lambda (x) (declare (ignore x)) t))
		 (list #'(lambda (x) (not-p x)))
		 #'(lambda (x)
		     (cons (list (cdadr x)) (list (cons 'NOT (cddr x)))))
		 #'(lambda (xl yl)
		     (cons 'NOT (acons 'IMPLIES (car xl) (cdar yl))))
		 #'(lambda (l3 l1 l2 princ-wff)
		     (let* ((es1 (get l1 'ext-seq))
			    (es2 (get l2 'ext-seq))
			    (es3 (get l3 'ext-seq))
			    (gam (multiset-extract-wffs (ext-seq-wffs es3) princ-wff))
			    (lft (cdadr princ-wff))
			    (nlft (cons 'NOT lft))
			    (nnlft (cons 'NOT nlft))
			    (rght (cddr princ-wff))
			    (ndis (cons 'NOT (acons 'OR nlft rght)))
			    (es4 (make-ext-seq :wffs (cons nnlft gam) :princ-wffs (list nnlft)
					       :kind 'NEG :pos-rule nil :prems (list es1)))
			    (es5 (make-ext-seq :wffs (cons ndis gam)
					       :princ-wffs (list ndis)
					       :kind 'DIS
					       :pos-rule nil
					       :prems (list es4 es2))))
		       (setf (line-justification l3) (list "IMPLIES-" nil (list l1 l2)))
		       (setf (ext-seq-kind es3) 'INTERNALIZE)
		       (setf (ext-seq-pos-rule es3) nil)
		       (setf (ext-seq-princ-wffs es3) (list princ-wff))
		       (setf (ext-seq-prems es3) (list es5))))))

(defun extseq-equiv- (p3 p1 p2 &optional pwff)
  (extseq-rule-2 p3 p1 p2 pwff
		 #'(lambda (x)
		     (and (not-p x) (equiv-p (cdr x))))
		 (list #'(lambda (x) (declare (ignore x)) t) #'(lambda (x) (declare (ignore x)) t))
		 (list #'(lambda (x) (not-p x)) #'(lambda (x) (not-p x)))
		 #'(lambda (x)
		     (let ((lft (cdadr x))
			   (rght (cddr x)))
		       (cons (list lft rght)
			     (list (cons 'NOT lft) (cons 'NOT rght)))))
		 #'(lambda (xl yl)
		     (unless (and (not-p (car yl)) (not-p (cadr yl))
				  (wffeq-ab (car xl) (cdar yl))
				  (wffeq-ab (cadr xl) (cdadr yl)))
		       (throwfail "Invalid Premisses for Equiv-"))
		     (cons 'NOT (acons 'EQUIV (car xl) (cadr xl))))
		 #'(lambda (l3 l1 l2 princ-wff)
		     (let* ((es1 (get l1 'ext-seq))
			    (es2 (get l2 'ext-seq))
			    (es3 (get l3 'ext-seq))
			    (lft (cdadr princ-wff))
			    (rght (cddr princ-wff))
			    (es4 (make-ext-seq-equiv-neg lft rght es2 es1)))
		       (setf (line-justification l3) (list "EQUIV-" nil (list l1 l2)))
		       (setf (ext-seq-kind es3) 'INTERNALIZE)
		       (setf (ext-seq-pos-rule es3) nil)
		       (setf (ext-seq-princ-wffs es3) (list princ-wff))
		       (setf (ext-seq-prems es3) (ext-seq-prems es4))))))

(defun extseq-equiv+ (p3 p1 p2 &optional pwff)
  (extseq-rule-2 p3 p1 p2 pwff
		 #'(lambda (x) (equiv-p x))
		 (list #'(lambda (x) (not-p x)) #'(lambda (x) (declare (ignore x)) t))
		 (list #'(lambda (x) (declare (ignore x)) t) #'(lambda (x) (not-p x)))
		 #'(lambda (x)
		     (let ((lft (cdar x))
			   (rght (cdr x)))
		       (cons (list (cons 'NOT lft) rght)
			     (list lft (cons 'NOT rght)))))
		 #'(lambda (xl yl)
		     (unless (and (not-p (car xl)) (not-p (cadr yl))
				  (wffeq-ab (cdar xl) (car yl))
				  (wffeq-ab (cadr xl) (cdadr yl)))
		       (throwfail "Invalid Premisses for Rule"))
		     (acons 'EQUIV (car yl) (cadr xl)))
		 #'(lambda (l3 l1 l2 princ-wff)
		     (let* ((es1 (get l1 'ext-seq))
			    (es2 (get l2 'ext-seq))
			    (es3 (get l3 'ext-seq))
			    (lft (cdar princ-wff))
			    (rght (cdr princ-wff))
			    (es4 (make-ext-seq-equiv-pos lft rght es1 es2)))
		       (setf (line-justification l3) (list "EQUIV+" nil (list l1 l2)))
		       (setf (ext-seq-kind es3) 'INTERNALIZE)
		       (setf (ext-seq-pos-rule es3) t)
		       (setf (ext-seq-princ-wffs es3) (list princ-wff))
		       (setf (ext-seq-prems es3) (ext-seq-prems es4))))))

(defun extseq-exists- (p2 p1 y &optional pwff)
  (unless (and (symbolp y) (not (anyabbrev-p y)) (not (logconst-p y))
	       (not (binder-p y))
	       (not (equality-p y)))
    (throwfail y " is not a variable."))
  (let ((atp (unabbreviated-type y)))
    (extseq-rule-1-1 p2 p1 pwff
		     #'(lambda (x)
			 (and (not-p x)
			      (e-bd-wff-p (cdr x))
			      (equal (unabbreviated-type (bindvar (cdr x))) atp)))
		     #'(lambda (x) (declare (ignore x)) t)
		     #'(lambda (x)
			 (cons 'NOT (substitute-l-term-var y (bindvar (cdr x)) (cddr x))))
		     #'(lambda (x)
			 (let ((wff nil))
			   (prompt-read wff nil
					(msgf "Negated Existentially Quantified Wff")
					'gwff0 '$ ((? (msgf "Wff before instantiation"))
						   (?? (mhelp 'gwff0))))
			   (unless (and (not-p wff)
					(e-bd-wff-p (cdr wff))
					(equal (unabbreviated-type (bindvar (cdr wff))) atp)
					(wffeq-ab (substitute-l-term-var y (bindvar (cdr wff)) (cddr wff)) (cdr x)))
			     (throwfail (wff . gwff) " does not instantiate to " (x . gwff)))
			   wff))
		   #'(lambda (l2 l1 princ-wff)
		       (let* ((es1 (get l1 'ext-seq))
			      (es2 (get l2 'ext-seq))
			      (es3 (make-ext-seq-exists-neg (cdr princ-wff) y es1)))
			 (setf (line-justification l2) (list "EXISTS-" (list y) (list l1)))
			 (setf (ext-seq-kind es2) 'INTERNALIZE)
			 (setf (ext-seq-princ-wffs es2) (list princ-wff))
			 (setf (ext-seq-sel-var es2) y)
			 (setf (ext-seq-pos-rule es2) nil)
			 (setf (ext-seq-prems es2) (ext-seq-prems es3)))))
    (let* ((l2 (esnumalias p2))
	   (es2 (get l2 'ext-seq))
	   (wffs2 (when (ext-seq-p es2) (ext-seq-wffs es2))))
      (when (find-if #'(lambda (x) (free-in y x)) wffs2)
	(setf (ext-seq-prems es2) nil)
	(setf (ext-seq-kind es2) nil)
	(setf (line-justification l2) (es-nextplan))
	(push (list l2) (proof-plans (get *current-seqder* 'ext-seq-der)))
	(es-find-all-gaps)
	(throwfail y " is free in line " p2))
      nil)))

(defun extseq-exists+ (p2 p1 trm &optional pwff)
  (let ((atp (unabbreviated-type trm)))
    (extseq-rule-1-1 p2 p1 pwff
		     #'(lambda (x)
			 (and (e-bd-wff-p x)
			      (equal (unabbreviated-type (bindvar x)) atp)))
		     #'(lambda (x) (not-p x))
		     #'(lambda (x)
			 (substitute-l-term-var trm (bindvar x) (cdr x)))
		     #'(lambda (x)
			 (let ((wff nil))
			   (prompt-read wff nil
					(msgf "Existentially Quantified Wff")
					'gwff0 '$ ((? (msgf "Wff before instantiation"))
						   (?? (mhelp 'gwff0))))
			   (unless (and (e-bd-wff-p wff)
					(equal (unabbreviated-type (bindvar wff)) atp)
					(wffeq-ab (substitute-l-term-var trm (bindvar wff) (cdr wff)) x))
			     (throwfail (wff . gwff) " does not instantiate to " (x . gwff)))
			   wff))
		     #'(lambda (l2 l1 princ-wff)
			 (let* ((es1 (get l1 'ext-seq))
				(es2 (get l2 'ext-seq))
				(es3 (make-ext-seq-exists-pos princ-wff trm es1)))
			   (setf (line-justification l2) (list "EXISTS+" (list trm) (list l1)))
			   (setf (ext-seq-kind es2) 'INTERNALIZE)
			   (setf (ext-seq-princ-wffs es2) (list princ-wff))
			   (setf (ext-seq-exp-term es2) trm)
			   (setf (ext-seq-pos-rule es2) t)
			   (setf (ext-seq-prems es2) (ext-seq-prems es3)))))))

(context ext-seq-entering)

(defextseq expand-all-derived-rules
  (extseq-mainfns extseq-expand-all-derived-rules)
  (mhelp "Remove all applications of derived rules in terms of basic rules.
The derived rules include: false-, and-, and+, implies-, implies+,
equiv-, equiv+, exists-, exists+"))

(defun extseq-expand-all-derived-rules ()
  (let ((expand-lines nil)
	(ok-justs '("TRUE+" "NEG" "EQUIVWFFS+" "EQUIVWFFS-" "LAMBDA"
		    "OR+" "OR-" "ALL+" "ALL-"
		    "INTERNALIZE+" "INTERNALIZE-" "EQFUNC" "EXTFUNC"
		    "INITEQ" "DEC" "EUNIF1" "EUNIF2" "EQO" "EXTO" "INIT" "REFL"))
	(seqnode-line-assoc nil))
    (declare (special seqnode-line-assoc))
    (dolist (line (proof-lines (get *current-seqder* 'ext-seq-der)))
      (when (ext-seq-p (get line 'ext-seq))
	(unless (or (assoc line (proof-plans (get *current-seqder* 'ext-seq-der)))
		    (member (car (line-justification line))
			    ok-justs
			    :test #'string=))
	  (push (cons line seqnode-line-assoc) expand-lines))
	(push (cons (get line 'ext-seq) line) seqnode-line-assoc)))
    (dolist (line-prev expand-lines)
      (setq seqnode-line-assoc (cdr line-prev))
      (ext-seq-change-fake-nd-line (car line-prev) (get (car line-prev) 'ext-seq)))))

(defextseq expand-all-inits-and-refls
  (extseq-mainfns extseq-expand-all-inits-and-refls)
  (mhelp "Remove all applications of Inits and Refls in terms of basic rules."))

(defun extseq-expand-all-inits-and-refls ()
  (let ((rlines nil)
	(ilines nil))
    (dolist (line (proof-lines (get *current-seqder* 'ext-seq-der)))
      (let ((es1 (get line 'ext-seq)))
	(when (ext-seq-p es1)
	  (if (eq (ext-seq-kind es1) 'INIT)
	      (push line ilines)
	    (when (eq (ext-seq-kind es1) 'REFL)
	      (push line rlines))))))
    (dolist (line ilines)
      (let* ((es1 (get line 'ext-seq))
	     (es2 (ext-seq-expand-init-refl es1))
	     (seqnode-line-assoc nil))
	(declare (special seqnode-line-assoc))
	(ext-seq-change-fake-nd-line line es2)))
    (dolist (line rlines)
      (let* ((es1 (get line 'ext-seq))
	     (es2 (ext-seq-expand-init-refl es1))
	     (seqnode-line-assoc nil))
	(declare (special seqnode-line-assoc))
	(ext-seq-change-fake-nd-line line es2)))))

(context ext-seq-files)

(defextseq saveproof
  (extseq-argtypes filespec)
  (extseq-argnames savefile)
  (extseq-arghelp "File in which to save proof")
  (extseq-defaultfns (lambda (savefile)
		(list (if (eq savefile '$)
			  (namestring
			   (make-pathname% :name (string-downcase
						   (string *current-seqder*)) :type "prf"
					   :version :newest))
			savefile))))
  (extseq-mainfns extseq-saveproof)
  (mhelp "Saves the current natural deduction proof to the specified file in
a form in which it can be restored.  Use RESTOREPROOF to restore the proof.
Overwrites the file if it already exists."))

(defun extseq-saveproof (savefile)
  (when (pathnamep savefile) (setq savefile (namestring savefile)))
  (unless (is-ext-seqder-p *current-seqder*)
    (throwfail "There is no current extensional sequent derivation." t "Use PROVE to start one."))
  (setq savefile
	(merge-pathnames savefile
			 (make-pathname% :name (string *current-seqder*)
					 :type "prf"
					 :version :newest)))
  (with-open-file (*standard-output* savefile
				     :direction :output
				     :if-exists :supersede
				     :if-does-not-exist :create)
    (write-saved-extseq *current-seqder*))
  (format t "File ~A written." (namestring savefile)))

(defun write-saved-extseq (proof &optional (name proof))
  (unless (is-ext-seqder-p proof)
    (throwfail proof " is not an extensional sequent derivation."))
  (in-mode re-read
    (let* ((proof2 (get proof 'ext-seq-der))
	   (lines (proof-lines proof2))
	   (plans (proof-plans proof2))
	   (comment (core::comment-to-string (get proof2 'comment)))
	   (locked (mapcar #'linealias 
			   (remove-if-not #'(lambda (x) (get x 'locked)) lines)))
	   (plan-list (mapcar #'(lambda (x)
				  (mapcar #'linealias x))
			      plans))
	   (es (get proof2 'ext-seq))
	   (wffs (when (ext-seq-p es) (ext-seq-wffs es)))
	   (gwff-name (get proof2 'gwff-name)) ;  cebrown 4/12/01
	   (num (nextplan-no proof2))
	   (date (status-date))
	   (abbrev-done nil)
	   (constl-done nil)
	   (abbrev nil)
	   (constl nil)
	   (outstring "")
	   (obj nil)
	   (code 0))
      (declare (special abbrev-done constl-done))
      (if expertflag
	  (progn
	    (msgf "(defsavedextseq " name t "  " date  t 
		  "  (assertion (")
	    (dolist (x wffs)
	      (setq abbrev (abbr-list x))
	      (msg (x . gwff)))
	    (msg "))" t "  (nextplan-no " num ")" t "  (plans ")
	    (princ plan-list)
	    (msg ")" t "  (lines " t)
	    (dolist (line lines)
	      (let ((es1 (get line 'ext-seq)))
		(when (ext-seq-p es1)
		  (msg  "    (") 
		  (msg  (line-linenumber line) " (")
		  (dolist (x (ext-seq-wffs es1))
		    (msg " " (x . gwff) " ")
		    (setq abbrev (append (abbr-list x) abbrev))
		    (setq constl (append (const-list x) constl)))
		  (msg " ) ")
		  (prin1 (line-just-rule line))
		  (msg " (")
		  (dolist (term (line-just-terms line))
		    (msg " " (term . gwff)))
		  (msg ") ")
		  (princ (mapcar #'linealias (line-just-lines line)))
		  (msg " ( ")
		  (dolist (x (ext-seq-princ-wffs es1))
		    (msg " " (x . gwff) " "))
		  (msg " ) ")
		  (when (get line 'comment) 
		    (msg "  \"" (core::comment-to-string (get line 'comment)) "\"" ))
		  (msg ")" t))))
	    (msg ") 0" t)
	    (when (or abbrev constl)
	      (msg "  ( " t)
	      (write-saved-extseq-defs abbrev constl)
	      (msg ")" t))
	    (when (not (or abbrev constl)) (msg "( )" t))
	    (msg "  (comment \"" comment "\")" 
		 t "  (locked " locked ")" t
		 "  " gwff-name " " t) ; cebrown 4/12/01
	    (msg ")" t))
	(progn
	  (setq outstring
	    (with-output-to-string (*standard-output*)
	      (msgf "(defsavedextseq " proof t "  " date  t 
		    "  (assertion (")
	      (dolist (x wffs)
		(msg (x . gwff)))
	      (msg "))" t "  (nextplan-no " num ")" t "  (plans ")
	      (princ plan-list)
	      (msg ")" t 
		   "  (lines " t)
	      (dolist (line lines)
		(let ((es1 (get line 'ext-seq)))
		  (msg  "    (") 
		  (msg  (line-linenumber line) " (")
		  (dolist (x (ext-seq-wffs es1))
		    (msg " " (x . gwff) " "))
		  (msg " ) ")
		  (prin1 (line-just-rule line))
		  (msg " (")
		  (dolist (term (line-just-terms line))
		    (msg " " (term . gwff)))
		  (msg ") ")
		  (princ (mapcar #'linealias (line-just-lines line)))
		  (msg " ( ")
		  (dolist (x (ext-seq-princ-wffs es1))
		    (msg " " (x . gwff) " "))
		  (msg " )) " t)))
	      (msg "))")))
					;(msg ")" t "()" t " (comment \"" comment "\"))")))
	  (with-input-from-string (in outstring) (setq obj (read in)))
	  (setq code 
	    (rem 
	     (core::easy-code-list 
	      (list proof (status-userid) date
		    (cadr (fourth obj)) num
		    plan-list (cdr (seventh obj))))
	     *modulo*))
	  (write-string outstring *standard-output* :end (1- (length outstring)))
	  (format t " ~D ~%" code)
	  (msg "( ) (comment \"" comment "\")" t 
	       "  (locked " locked ")" t "  " gwff-name ")" t))))))

(defun write-saved-extseq-defs (abbrev constl)
  (declare (special abbrev-done constl-done))
  (if constl
      (progn
	(write-saved-extseq-defs abbrev (cdr constl))
	(let* ((d (car constl))
	       (c (or (get d 'core::stands-for) d)))
	  (unless (member c constl-done)
	    (push c constl-done)
	    (if (get c 'typelist)
		(msg "    (def-pmpropsym " c t)
	      (msg "    (def-logconst " c t))
	    (when (get c 'type) (msg "      (type \"") 
		  (type-to-lib-stream (get c 'type) *standard-output*) (msg "\")" t))
	    (when (get c 'typelist) (msg "      (typelist ") 
		  (prin1 (mapcar #'princ-to-string (get c 'typelist))) (msg ")" t))
	    (when (get c 'printnotype) (msg "      (printnotype t)" t))
	    (when (get c 'fo-single-symbol) (msg "      (fo-single-symbol t)" t))
	    (when (get c 'face) (msg "      (face ")
		  (prinlc (get c 'face)) (msg ")" t))
	    (when (get c 'infix) (msg "      (infix ") (prin1 (get c 'infix)) (msg ")" t))
	    (msg "      )" t))))
    (if abbrev
	(progn
	  (write-saved-extseq-defs (cdr abbrev) nil)
	  (let* ((abbr0 (car abbrev))
		 (abbr (or (get abbr0 'core::stands-for) abbr0))
		 (def (get abbr 'defn)))
	    (unless (member abbr abbrev-done)
	      (push abbr abbrev-done)
	      (when def (write-saved-extseq-defs (abbr-list def) (const-list def)))
	      (msg "    (def-abbrev " abbr t)
	      (when (get abbr 'type) (msg "      (type \"") 
		    (type-to-lib-stream (get abbr 'type) *standard-output*) (msg "\")" t))
	      (when (get abbr 'typelist) (msg "      (typelist ") 
		    (prin1 (mapcar #'princ-to-string (get abbr 'typelist))) (msg ")" t))
	      (when (get abbr 'printnotype) (msg "      (printnotype t)" t))
	      (when (get abbr 'fo-single-symbol) (msg "      (fo-single-symbol t)" t))
	      (when (get abbr 'face) (msg "      (face ")
		    (prinlc (get abbr 'face)) (msg ")" t))
	      (when (get abbr 'infix) (msg "      (infix ") (prin1 (get abbr 'infix)) (msg ")" t))
					;(when (get abbr 'thm-type) (msg "      (thm-type ") (prin1 (get abbr 'thm-type)) (msg ")" t))
	      (when def (msg "      (defn " (def . gwff) ")" t))
	      (when (get abbr 'defn-fun) (msg "      (defn-fun ") (prin1 (get abbr 'defn-fun)) (msg ")" t))
	      (msg "      )" t)))))))

(defextseq texproof
  (extseq-argtypes filespec yesno)
  (extseq-argnames filename timing)
  (extseq-arghelp "filename" "Recording time?")
  (extseq-defaultfns (lambda (filename timing)
		       (list
			(if (eq filename '$)
			    (namestring
			     (make-pathname%
			      :name (string-downcase (symbol-name *current-seqder*))
			      :type "tex"))
			  filename)
			(if (eq timing '$) nil timing))))
  (extseq-mainfns texproof)
  (mhelp "Print the current proof into a tex file.
After leaving tps, run this .tex file through tex and print the resulting
file.

Many flags affect the output of texproof.
See: USE-INTERNAL-PRINT-MODE, TURNSTILE-INDENT-AUTO, TURNSTILE-INDENT,
LATEX-EMULATION, TEX-MIMIC-SCRIBE, PPWFFLAG, DISPLAYWFF, INFIX-NOTATION,
PAGELENGTH, PAGEWIDTH, TEX-BREAK-BEFORE-SYMBOLS, LOCALLEFTFLAG, SCOPE,
ALLSCOPEFLAG, USE-DOT, FIRST-ORDER-PRINT-MODE, FILLINEFLAG, ATOMVALFLAG."))

(defextseq scribeproof
  (extseq-argtypes filespec yesno)
  (extseq-argnames filename timing)
  (extseq-arghelp "Filename" "Recording time?")
  (extseq-defaultfns (lambda (filename timing)
		       (list
			(if (eq filename '$)
			    (namestring
			     (make-pathname%
			      :name (string-downcase (symbol-name *current-seqder*))
			      :type "mss"))
			  filename)
			(if (eq timing '$) nil timing))))
  (extseq-mainfns scribeproof)
  (mhelp "Print the current proof into a MSS file.
After leaving TPS, run this .MSS file through Scribe and print the resulting
file."))

(defextseq restoreproof
  (extseq-argtypes filespec)
  (extseq-argnames savefile)
  (extseq-arghelp "File in which extensional sequent derivation resides")
  (extseq-defaultfns (lambda (savefile)
		(list (if (eq savefile '$)
			  (namestring
			   (make-pathname% :name (string-downcase
						   (string *current-seqder*)) :type "prf"
					   :version :newest))
			  savefile))))
  (extseq-mainfns extseq-restoreproof)
  (mhelp "Reads an extensional sequent derivation from a file created
by SAVEPROOF in the EXT-SEQ top level and makes it the current
derivation.  A security feature prevents the restoration of saved
proofs which have been altered in any way.  Retrieve any definitions
which are used in the proof and stored in the library before restoring
the proof. If you don't specify a directory, it will first try your
home directory and then all the directories listed in SOURCE-PATH."))

(defun extseq-restoreproof (savefile)
  (extseq-restoreproof-real savefile (cons nil source-path)))

(defun extseq-restoreproof-real (sav source-path)
  (let ((exp nil)
	(savefile nil))
    (setq savefile
	  (merge-pathnames sav
			   (make-pathname% :directory (car source-path)
					   :name (string *current-seqder*) 
					   :type "prf"
					   :version :newest)))
    (if (probe-file savefile)
	(progn 
	  (with-open-file (in savefile :direction :input
			      :if-does-not-exist :error)
			  (setq exp (read in)))
	  (if (eq (car exp) 'defsavedextseq) 
	      (eval exp)
	    (throwfail "File does not contain a saved derivation.")))
      (if (cdr source-path) 
	  (extseq-restoreproof-real sav (cdr source-path))
	(throwfail "File " sav " does not exist; check SOURCE-PATH.")))))

(defun build-line-ext-seq (line princ-wffs assertions)
  (let* ((rule (line-just-rule line))
	 (premlines (line-just-lines line))
	 (esl (mapcar #'(lambda (l) (get l 'ext-seq)) premlines)))
    (cond ((string-equal rule "INIT")
	   (let* ((wff1 (car princ-wffs))
		  (wff2 (cadr princ-wffs))
		  (gam (multiset-extract-wffs assertions wff1 wff2)))
	     (cond ((and (not-p wff1) (wffeq-ab (cdr wff1) wff2))
		    (make-ext-seq-init-ab (cdr wff1) wff2 gam))
		   ((and (not-p wff2) (wffeq-ab (cdr wff2) wff1))
		    (make-ext-seq-init-ab (cdr wff2) wff1 gam))
		   (t (throwfail "Ill-Formed INIT rule")))))
	  ((string-equal rule "REFL")
	   (make-ext-seq-refl-ab (car princ-wffs) (multiset-extract-wffs assertions (car princ-wffs))))
	  ((string-equal rule "TRUE+")
	   (make-ext-seq-true (multiset-extract-wffs assertions 'TRUTH)))
	  ((string-equal rule "FALSE-")
	   (make-ext-seq-false (multiset-extract-wffs assertions (car princ-wffs))))
	  ((string-equal rule "CONTR")
	   (make-ext-seq-contr (car princ-wffs) (car esl)))
	  ((string-equal rule "NEG")
	   (if (and (not-p (car princ-wffs)) (not-p (cdar princ-wffs)))
	       (make-ext-seq-neg (cddar princ-wffs) (car esl))
	     (throwfail "Ill-Formed NEG rule")))
	  ((string-equal rule "INTERNALIZE+")
	   (make-ext-seq-internalize (car princ-wffs) (car esl) t))
	  ((string-equal rule "INTERNALIZE-")
	   (make-ext-seq-internalize (gdr (car princ-wffs)) (car esl) nil))
	  ((string-equal rule "EQUIVWFFS+")
	   (let* ((wff1 (car princ-wffs))
		  (gam (multiset-extract-wffs assertions wff1))
		  (es2 (car esl)))
	     (unless (ext-seq-p es2)
	       (throwfail "Ill-Formed Derivation"))
	     (let* ((wffs2 (ext-seq-wffs es2))
		    (wffs3 (multiset-extract-wffs-1 wffs2 gam)))
	       (unless (and wffs3 (not (cdr wffs3)))
		 (throwfail "Ill-Formed Derivation"))
	       (make-ext-seq-rew wff1 (car wffs3) 'EQUIVWFFS t (car esl)))))
	  ((string-equal rule "EQUIVWFFS-")
	   (let* ((wff1 (car princ-wffs))
		  (gam (multiset-extract-wffs assertions wff1))
		  (es2 (car esl)))
	     (unless (and (not-p wff1) (ext-seq-p es2))
	       (throwfail "Ill-Formed Derivation"))
	     (let* ((wffs2 (ext-seq-wffs es2))
		    (wffs3 (multiset-extract-wffs-1 wffs2 gam)))
	       (unless (and wffs3 (not (cdr wffs3)) (not-p (car wffs3)))
		 (throwfail "Ill-Formed Derivation"))
	       (make-ext-seq-rew (cdr wff1) (cdar wffs3) 'EQUIVWFFS nil (car esl)))))
	  ((string-equal rule "LAMBDA")
	   (make-ext-seq-lambda (car princ-wffs) (car esl)))
	  ((string-equal rule "OR+")
	   (let ((pwff (car princ-wffs)))
	     (make-ext-seq-dis-pos (gdr (gar pwff)) (gdr pwff) (car esl))))
	  ((string-equal rule "OR-")
	   (let ((pwff (gdr (car princ-wffs))))
	     (make-ext-seq-dis-neg (gdr (gar pwff)) (gdr pwff) (car esl) (cadr esl))))
	  ((string-equal rule "AND+")
	   (let ((pwff (car princ-wffs)))
	     (make-ext-seq-con-pos (gdr (gar pwff)) (gdr pwff) (car esl) (cadr esl))))
	  ((string-equal rule "AND-")
	   (let ((pwff (gdr (car princ-wffs))))
	     (make-ext-seq-con-neg (gdr (gar pwff)) (gdr pwff) (car esl))))
	  ((string-equal rule "IMPLIES+")
	   (let ((pwff (car princ-wffs)))
	     (make-ext-seq-imp-pos (gdr (gar pwff)) (gdr pwff) (car esl))))
	  ((string-equal rule "IMPLIES-")
	   (let ((pwff (gdr (car princ-wffs))))
	     (make-ext-seq-imp-neg (gdr (gar pwff)) (gdr pwff) (car esl) (cadr esl))))
	  ((string-equal rule "EQUIV+")
	   (let ((pwff (car princ-wffs)))
	     (make-ext-seq-equiv-pos (gdr (gar pwff)) (gdr pwff) (car esl) (cadr esl))))
	  ((string-equal rule "EQUIV-")
	   (let ((pwff (gdr (car princ-wffs))))
	     (make-ext-seq-equiv-neg (gdr (gar pwff)) (gdr pwff) (car esl) (cadr esl))))
	  ((string-equal rule "ALL+")
	   (let ((pwff (car princ-wffs))
		 (trm (car (line-just-terms line))))
	     (make-ext-seq-forall-pos pwff trm (car esl))))
	  ((string-equal rule "ALL-")
	   (let ((pwff (gdr (car princ-wffs)))
		 (trm (car (line-just-terms line))))
	     (make-ext-seq-forall-neg pwff trm (car esl))))
	  ((string-equal rule "EXISTS+")
	   (let ((pwff (car princ-wffs))
		 (trm (car (line-just-terms line))))
	     (make-ext-seq-exists-pos pwff trm (car esl))))
	  ((string-equal rule "EXISTS-")
	   (let ((pwff (gdr (car princ-wffs)))
		 (trm (car (line-just-terms line))))
	     (make-ext-seq-exists-neg pwff trm (car esl))))
	  ((string-equal rule "EXTFUNC")
	   (let ((pwff (car princ-wffs))
		 (trm (car (line-just-terms line))))
	     (make-ext-seq-extfunc pwff trm (car esl))))
	  ((string-equal rule "EQFUNC")
	   (let ((pwff (gdr (car princ-wffs)))
		 (trm (car (line-just-terms line))))
	     (make-ext-seq-eqfunc pwff trm (car esl))))
	  ((string-equal rule "EXTO")
	   (let ((pwff (car princ-wffs)))
	     (make-ext-seq-exto pwff (car esl) (cadr esl))))
	  ((string-equal rule "EQO")
	   (let ((pwff (gdr (car princ-wffs))))
	     (make-ext-seq-eqo pwff (car esl) (cadr esl))))
	  ((string-equal rule "DEC")
	   (let* ((pwff (car princ-wffs))
		  (gam (multiset-extract-wffs assertions pwff)))
	     (apply #'make-ext-seq-dec (cons pwff (cons gam esl)))))
	  ((string-equal rule "INITEQ")
	   (let* ((wff1 (car princ-wffs))
		  (wff2 (cadr princ-wffs))
		  (wff3 (if (not-p wff1) (cdr wff1)
			  (if (not-p wff2) (cdr wff2)
			    (throwfail "Ill-Formed InitEq"))))
		  (wff4 (if (not-p wff1) wff2 wff1))
		  (gam (multiset-extract-wffs assertions wff1 wff2)))
	     (apply #'make-ext-seq-init-eq (cons wff3 (cons wff4 (cons gam esl))))))
	  ((string-equal rule "EUNIF1")
	   (let* ((wff1 (car princ-wffs))
		  (wff2 (cadr princ-wffs))
		  (wff3 (if (not-p wff1) (cdr wff1)
			  (if (not-p wff2) (cdr wff2)
			    (throwfail "Ill-Formed EUnif1"))))
		  (wff4 (if (not-p wff1) wff2 wff1)))
	     (make-ext-seq-eunif1 wff3 wff4 (car esl) (cadr esl))))
	  ((string-equal rule "EUNIF2")
	   (let* ((wff1 (car princ-wffs))
		  (wff2 (cadr princ-wffs))
		  (wff3 (if (not-p wff1) (cdr wff1)
			  (if (not-p wff2) (cdr wff2)
			    (throwfail "Ill-Formed EUnif2"))))
		  (wff4 (if (not-p wff1) wff2 wff1)))
	     (make-ext-seq-eunif2 wff3 wff4 (car esl) (cadr esl))))
	  (t (make-ext-seq :wffs assertions)))))

(context etr-nat)

(defextseq cutfree-to-edag
  (extseq-argtypes line)
  (extseq-argnames conc)
  (extseq-arghelp "Conclusion Line")
  (extseq-defaultfns
   (lambda (conc)
     (list (if (eq conc '$)
	       (let* ((lines (reverse (proof-lines dproof)))
		      (l (find-if #'(lambda (l)
				      (let ((es (get l 'ext-seq)))
					(and (ext-seq-p es)
					     (= (length (ext-seq-wffs es)) 1))))
				  lines)))
		 (or (linealias l) conc))
	     conc))))
  (extseq-mainfns cutfree-to-edag)
  (mhelp "Translate a complete, cut-free extensional sequent derivation
to an extensional expansion dag proof.  The conclusion of the
derivation must be a sequent with a single formula."))

(defun cutfree-to-edag (conc)
  (let* ((l (numalias conc))
	 (es (get l 'ext-seq)))
    (unless (and (ext-seq-p es)
		 (= (length (ext-seq-wffs es)) 1))
      (throwfail "Cannot translate line " conc))
    (let ((edags (cutfree-ext-seq-to-ext-exp-dags es)))
      (setq *current-edag* (eed-to-eeod (cdar edags)))
      (setf (get *current-seqder* 'ext-exp-open-dag)
	    *current-edag*)
      (msgf "Extensional Expansion Dag is named " *current-seqder*)
      (msgf "Enter the EXT-MATE top level to manipulate it.")
      (push *current-seqder* *eeod-list*)
      nil)))
