;;; -*- Mode:LISP; Package:auto -*-
;;; ******************************************************************* ;;;
;;;         (c) Copyrighted 1988 by Carnegie Mellon University.         ;;;
;;;                        All rights reserved.                         ;;;
;;;         This code was written as part of the TPS project.           ;;;
;;;   If you want to use this code or any part of TPS, please contact   ;;;
;;;               Peter B. Andrews (Andrews@CS.CMU.EDU)                 ;;;
;;; ******************************************************************* ;;;

(in-package :CORE)
(context lib-bugs)

(deffile lib-bug
  (part-of library)
  (extension lisp)
  (mhelp "Defines BUG-SAVE and BUG-RESTORE."))

(defflag default-bug-dir
  (flagtype dirspec)
  (default "")
  (subjects library)
  (pre-change-fn (lambda (flag value old-value) ; cebrown 3/30/02
		   (declare (ignore flag))
		   (unless (equal value old-value)
		     (when (and *running-remotely* (not *expert-running-remotely*))
		       (throwfail "Sorry.  You are not allowed to change this flag when running remotely.")))))
  (mhelp "If USE-DEFAULT-BUG-DIR is T, this is the default value
for the directory where bugs generated by BUG-SAVE will be stored,
and the first directory that will be searched by BUG-RESTORE.
If USE-DEFAULT-BUG-DIR is NIL, this flag is ignored, and bugs
will be saved like normal library objects, in the directories
listed in DEFAULT-LIB-DIR."))

(defflag use-default-bug-dir
  (flagtype boolean)
  (default T)
  (subjects library)
  (mhelp "Determines whether or not to use the directory given
by DEFAULT-BUG-DIR for saving. If T, bugs are saved to and 
restored from DEFAULT-BUG-DIR, otherwise they aren't.
See DEFAULT-BUG-DIR."))

(defmexpr bug-save
  (argnames name comment)
  (argtypes symbol string)
  (defaultfns (lambda (z w)
		(list (if (eq z '$) dproof z)
		      (if (eq w '$) "" w))))
  (arghelp "Name for bug" "Your choice")
  (mainfns bug-record)
  (mhelp "Records details of a bug. Saves the current flag settings, the output
of the HISTORY command, all currently loaded library objects, the 
current proof, the date and time and any comments (the best idea 
is to copy any error messages in to the \"comments\" prompt). 
This setup can then be retrieved with BUG-RESTORE.
The details are saved as a MODE1, under the name that the user provides
(in a file of the same name) with the assertion and library objects in
other-attributes and other-remarks respectively, and the context set
to BUG. The file will be saved in an appropriate directory (see
USE-DEFAULT-BUG-DIR)."))

(defmexpr bug-restore
  (argnames name)
  (argtypes symbol)
  (arghelp "Name of bug")
  (mainfns retrieve-bug)
  (mhelp "Restore a bug from the library (see USE-DEFAULT-BUG-DIR). 
This must have been a bug which was saved with BUG-SAVE; 
this command will reload all the necessary library objects, 
reset all the flags and reload the proof.
This does NOT create a new mode; it just resets the flags."))

(defmexpr bug-delete
  (argnames name)
  (argtypes symbol)
  (arghelp "Name of bug")
  (mainfns bug-delete)
  (mhelp "Delete a bug record. Exactly the same as the library
DELETE command, but will use the DEFAULT-BUG-DIR if 
USE-DEFAULT-BUG-DIR is T."))

(defmexpr bug-list
  (mainfns bug-list)
  (mhelp "Show all the saved bugs in the appropriate directory.
See USE-DEFAULT-BUG-DIR."))

(defun bug-list ()
  (if use-default-bug-dir
      (if (probe-file default-bug-dir)
	  (progn (let* ((default-lib-dir (list default-bug-dir))
			(backup-lib-dir NIL)
			(add-subdirectories NIL))
		   (restore-lib-hashtable t)
		   (msgf "Bugs in the directory " DEFAULT-BUG-DIR " are:" t)
		   (list-of-libobjects 'mode1 nil))
		 (restore-lib-hashtable t))
	(complain t "You need to set DEFAULT-BUG-DIR correctly." t))
    (progn (msgf "Saved bugs are:" t)
	   (lib-search 'mode1 '(":Context \"BUG\"") t))))

(defmexpr bug-help
  (argnames name)
  (argtypes symbol)
  (arghelp "Name of bug")
  (mainfns bug-help)
  (mhelp "Show the help message of a bug record."))

(defun bug-help (name)
  (if use-default-bug-dir
      (if (probe-file default-bug-dir)
	  (progn (let* ((default-lib-dir (list default-bug-dir))
			(backup-lib-dir NIL)
			(add-subdirectories NIL))
		   (restore-lib-hashtable t)
		   (show-libobject-help name 'mode1))
		 (restore-lib-hashtable t))
	(complain t "You need to set DEFAULT-BUG-DIR correctly." t))
    (show-libobject-help name 'mode1)))

(defun bug-record (name comment)
  (if use-default-bug-dir
      (if (probe-file default-bug-dir)
	  (progn (let* ((default-lib-dir (list default-bug-dir))
			(add-subdirectories NIL)
			(backup-lib-dir NIL))
		   (restore-lib-hashtable t)
		   (bug-record-real name comment))
		 (restore-lib-hashtable t))
	(complain t "You need to set DEFAULT-BUG-DIR correctly." t))
    (bug-record-real name comment)))

(defun bug-delete (name)
  (if use-default-bug-dir 
      (if (probe-file default-bug-dir)
	  (when (query "This is in the global bugs directory. Are you sure you want to delete it?" nil)
		(let* ((default-lib-dir (list default-bug-dir))
		       (add-subdirectories NIL)
		       (backup-lib-dir NIL))
		  (restore-lib-hashtable t)
		  (delete-libobject name 'mode1))
		(restore-lib-hashtable t))
	(complain t "You need to set DEFAULT-BUG-DIR correctly." t))
    (delete-libobject name 'mode1)))

(defun bug-record-real (name comment)
    (let* ((found (locate-item name :type 'mode1 :writeable t))
	   (count 0)
	   (allowable-dirlist (mapcar 'directory-namestring default-lib-dir))
	   (banned-dirlist (mapcar 'directory-namestring (mapcar 'cdr found)))
	   (allowable-dirlist (remove-if #'(lambda (x) (member x banned-dirlist :test 'string=)) allowable-dirlist))
	   (fname (concatenate 'string (namestring (pathname-name (princ-to-string name))) "." 
			       default-libfile-type))
	   (help (concatenate 'string "Automatically generated bug report on " (stringdt nil) "
Working on " (princ-to-string dproof) "
Timing info:
" (with-output-to-string (*standard-output*)
			 (auto::display-time-in-daterec)
			 (when (memq auto::default-ms '(ms88 ms89))
			       (auto::show-mating-stats)))
"

History :
" (string-history) "

" comment 
))
	   (needed-objects (remove-if #'(lambda (x) (or (not (symbolp x)) (neq (get x 'thm-type) 'library)))
				      global-theoremlist))
	   write-flags description)
      (when (null allowable-dirlist) (throwfail t "You need to set " (if use-default-bug-dir "DEFAULT-BUG-DIR"
								       "DEFAULT-LIB-DIR")))
      (dolist (elt found)
	      (setq allowable-dirlist (delete (directory-namestring (cdr elt)) allowable-dirlist :test 'string=)))
      (setq allowable-dirlist 
	    (mapcar #'(lambda (x) (concatenate 'string x fname)) allowable-dirlist))
      (unless allowable-dirlist 
	      (throwfail t "All writeable directories already contain such an object." t "Try a different name."))
      (when (and (eq style 'istyle) (not *simple-interface-prompts*)) (start-prompt-options))
      (when allowable-dirlist
	    (dolist (elt allowable-dirlist)
		    (incf count)
		    (complain count ") INSERT into " (if (probe-file elt) "old" "new") " file " elt)))
      (incf count) 
      (complain count ") DO NOTHING.")
      (setq count (1- (get-a-number count)))
      (setq fname (nth count allowable-dirlist))
      (when fname
	    (dolist (flag global-flaglist)
		    (when (and (symbolp flag) (not (get flag 'synonym)))
			  (pushnew flag write-flags)))
	    (setq description (flagsort write-flags))
	    (let ((item (make-libitem
			 :name name :type 'mode1 :description description
			 :mhelp help :context "BUG"
			 :provability nil
			 :proof-date nil
			 :other-remarks needed-objects
			 :other-attributes (proof-string dproof) ;(get (maxline dproof) 'assertion)
			 :needed-objects nil
			 :file fname))
		  (style 'write-to-file))
	      (store-item item)
	      (msg t "Created file " (namestring fname) t)))))

(defun proof-string (proof)
  (when (proof-lines proof)
	(let* ((lines (proof-lines proof))
	       (assertion (proof-assertion proof))
	       (plans (proof-plans proof))
	       (plan-list (mapcar #'(lambda (x)
				      (mapcar #'linealias x))
				  plans))
	       (num (nextplan-no proof))
	       (date (status-date))
	       (outstring "")
	       (style 'generic))
	  (when (stringp assertion) (setq assertion (gettype 'gwff assertion)))	  
	  (setq outstring
	    (with-output-to-string (*standard-output*)
	      (msgf "(defsavedproof " proof t "  " date  t 
		    "  (assertion \"" (assertion . gwff) "\")" t
		    "  (nextplan-no " num ")" t
		    "  (plans ")
	      (princ plan-list)
	      (msg ")" t 
		   "  (lines " t)
	      (dolist (line lines)
		(msg  "    (") 
		(msg  (line-linenumber line) " ")
		(princ (mapcar #'linealias (line-hypotheses line)))
		(msg " \"" ((line-assertion line) . gwff) "\" ")
		(prin1 (line-just-rule line))
		(msg " (")
		(dolist (term (line-just-terms line))
		  (msg " \"" (term . gwff) "\""))
		(msg ") ")
		(princ (mapcar #'linealias (line-just-lines line)))
		(msg ")" t))
	      (msg ") 0)")))
	  outstring)))

(defun string-history ()
  (let ((str ""))
    (dolist (hist *command-history*)
	    (when (car hist)
		  (setq str (concatenate 'string  str (princ-to-string (car hist)) "   "
					 (princ-to-string  
					  (mapcar #'(lambda (str) (string-right-trim (list
										      escape-char)
										     str))
						  (cdr hist))) "
"))))
    str))

(defun retrieve-bug (name)
  (declare (special backup-lib-dir default-lib-dir default-bug-dir))
  (if use-default-bug-dir
      (if (probe-file default-bug-dir)
	  (progn (let* ((real-dld default-lib-dir)
			(default-lib-dir nil)
			(add-subdirectories NIL)
			(backup-lib-dir (append (list default-bug-dir) real-dld backup-lib-dir)))
		   (restore-lib-hashtable t)
		   (retrieve-bug-real name))
		 (restore-lib-hashtable t))
	(complain t "You need to set DEFAULT-BUG-DIR correctly." t))
    (retrieve-bug-real name)))

(defun retrieve-bug-real (name)
  (let ((found (locate-item name :type 'mode1))
	(reroute-close-message nil)
	(junkfile1 (concatenate 'string "/tmp/directory" (princ-to-string (gensym))))
	(count 0))
    (when (null (car found)) (throwfail "I can't locate this bug." t))
    (when (cdr found)
          (when (and (eq style 'istyle) (not *simple-interface-prompts*)) (start-prompt-msg))
	  (complain (length found) " items called " name " found. They are as follows:" t)
	  (when (and (eq style 'istyle) (not *simple-interface-prompts*)) (start-prompt-options))
	  (dolist (elt found)
		  (incf count) 
		  (complain count ") " (car elt) " in file " (namestring (cdr elt))))
	  (unless show-all-libobjects
		  (throwfail t "Please either specify the type of the item or set SHOW-ALL-LIBOBJECTS to NIL."))
	  (incf count) 
	  (complain count ") None of these.")
	  (setq found (list (nth (1- (get-a-number count)) found))))
    (setq found (car found))
    (when found
	  (let ((input-file (cdr found))
		(type (car found)))
	    (with-open-file
	     (*instream* input-file :direction :input)
	     (do ((item nil (read *instream* nil control-d-char)))
		 ((or (eq item control-d-char) 
		      (and (eq name (cadr item))
			   (eq type (nth 3 item))))
		  (progn
		    (close *instream*)
		    (when (eq item control-d-char)
			  (return (complain "I can't locate " name ".")))
		    (if (string= (cadr (memq :Context item)) "BUG")
			(progn
			  (when (cadr (memq :other-remarks item)) 
				(msg "Looking for library objects: " (cadr (memq :other-remarks item)))
				(reroute-output-append junkfile1 *default-pathname-defaults* 
				  (let ((load-warn-p nil))
				    (dolist (needed (cadr (memq :other-remarks item)))
					    (unless (object-present needed nil)
						    (or (retrieve-libobject needed :type 'abbr :multiple nil
									    :fail-gently t)
							(retrieve-libobject needed :type 'lib-const :multiple nil
									    :fail-gently t)
							(retrieve-libobject needed :type 'gwff :multiple nil
									    :fail-gently t))))))
				(when (remove-if-not #'theorem-p (cadr (memq :other-remarks item)))
				      (msgf "I found the objects: " 
					    (remove-if-not #'theorem-p (cadr (memq :other-remarks item))) t))
				(when (remove-if #'theorem-p (cadr (memq :other-remarks item)))
				      (msgf "I did not find the objects: " 
					    (remove-if #'theorem-p (cadr (memq :other-remarks item))) t t)))
			  (reroute-output-append junkfile1 *default-pathname-defaults* 
						 (dolist (flagpair (cadr (memq :description item)))
						   (set (car flagpair) (cadr flagpair))))
			  (when (probe-file junkfile1) (delete-file junkfile1))
			  (when (cadr (memq :other-attributes item)) (eval (cadr (memq :other-attributes item))))
			  t)
		      (progn (complain "This library object is not a bug report.") nil))))))))))


