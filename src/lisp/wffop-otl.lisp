;;; -*- Mode:LISP; Package:CORE -*-
;;; ******************************************************************* ;;;
;;;         (c) Copyrighted 1988 by Carnegie Mellon University.         ;;;
;;;                        All rights reserved.                         ;;;
;;;         This code was written as part of the TPS project.           ;;;
;;;   If you want to use this code or any part of TPS, please contact   ;;;
;;;               Peter B. Andrews (Andrews@CS.CMU.EDU)                 ;;;
;;; ******************************************************************* ;;;

(in-package :CORE)
(part-of OPS-OTLRULES)

;;;
;;; File: Wffop-Otl
;;;

(deffile wffop-otl
  (part-of ops-otlrules)
  (extension clisp)
  (mhelp "Defines wffops, argument types etc. for use with commands
generated by the rules package."))

(context substitution)

(defwffop s
  (argtypes gwff gvar gwff)
  (wffargtypes "A" "A" "B")
  (resulttype gwff)
  (wffop-type "B")
  (wffop-typelist "A" "B")
  (argnames term var inwff)
  (arghelp "term" "var" "inwff")
  (applicable-p (lambda (term var inwff) (free-for term var inwff)))
  (mhelp
   "Substitute a term for the free occurrences of variable in a gwff."))

(defun s (term var inwff) (substitute-term-var term var inwff))

(defwffop subst-some-occs
  (argtypes gwff gwff gwff gwff)
  (wffargtypes "A" "B" "A" "B")
  (resulttype boolean)
  (wffop-typelist "A" "B")
  (argnames replaced-term in-wff replaced-by-term result-wff)
  (arghelp "Term to be Replaced" "Wff in which to Replace Term"
	   "Term Replacing" "Resulting Wff")
  (applicable-p always-true)
  (mhelp "Tests whether a wff is the result of replacing 0 or more
occurrences of a term by another in a given wff."))

(defun subst-some-occs (replaced-term in-wff replaced-by-term result-wff)
  (subst-some-occurrences replaced-term in-wff replaced-by-term result-wff))

(context wfftst-obj)

(defwffop free-for
  (argtypes gwff gvar gwff)
  (resulttype boolean)
  (argnames term var inwff)
  (arghelp "term" "var" "inwff")
  (applicable-q (lambda (term var inwff) (declare (ignore inwff))
			(type-equal term var)))
  (applicable-p (lambda (term var inwff) (declare (ignore inwff))
			(type-equal term var)))
  (mhelp "Tests whether a term is free for a variable in a wff."))

(defwffop not-free-in
  (argtypes gvar gwff)
  (resulttype boolean)
  (argnames gvar inwff)
  (arghelp "Variable" "Inwff")
  (applicable-p always-true)
  (mhelp "Tests whether a variable is not free in a wff."))

(defun not-free-in (gvar inwff)
  (not (free-in gvar inwff)))


(defwffop not-free-in-wffset
  (argtypes gvar wffset)
  (resulttype boolean)
  (argnames gvar wffset)
  (arghelp "Variable" "Set of Gwffs")
  (applicable-p always-true)
  (mhelp "Tests whether a variable is not free in a set of wffs."))

(defun not-free-in-wffset (gvar wffset)
  (dolist (wff wffset T)
    (when (free-in gvar wff) (return nil))))

(defwffop not-free-in-hyps
  (argtypes gvar)
  (resulttype boolean)
  (argnames gvar)
  (arghelp "Variable")
  (applicable-p always-true)
  (mhelp 
"Tests whether a variable is not free in the set of hypotheses of a rule."))

;;; added defvar's 17Nov88 DAN

(defvar rule-hupper nil)
(defvar rule-hlower nil)
(defvar check-hyps-again nil) ;;will be T if we couldn't find a hyp line on the first time through foo-legal.

(defun not-free-in-hyps (gvar)
  (declare (special rule-hupper check-hyps-again))
  (when (dolist (lnum rule-hupper nil) 
	  (unless (or (numalias lnum)
		      (and (symbolp lnum) (get lnum 'linenumber)))
	    (return t)))
    (setq check-hyps-again t))
  (not-free-in-wffset
   gvar (delete-if #'null
		   (mapcar #'(lambda (lnum)
			       (let ((llab (or (numalias lnum) ;;lnum is an integer
					       (and (symbolp lnum) (get lnum 'linenumber) lnum)))) ;;lnum is a line.
				 (if llab (get llab 'assertion) nil)))
			   rule-hupper))))

(defun free-in-hyps ()
  (declare (special rule-hupper check-hyps-again))
  (when (dolist (lnum rule-hupper nil) 
	  (unless (or (numalias lnum)
		      (and (symbolp lnum) (get lnum 'linenumber)))
	    (return t)))
    (setq check-hyps-again t))
  (let ((fvs nil))
    (dolist (lnum rule-hupper (delete-duplicates fvs))
      (let ((llab (or (numalias lnum)
		      (and (symbolp lnum) (get lnum 'linenumber) lnum)))) ;;lnum is actually a line.
	(if llab
	    (setq fvs (nconc fvs (free-vars-of (get llab 'assertion)))))))))

(defwffop non-atomic
  (argtypes gwff)
  (resulttype boolean)
  (argnames gwff)
  (arghelp "Wff")
  (applicable-p always-true)
  (mhelp "Tests whether a wff is not atomic, that is, negated, quantified or the result of joining two wffs with a binary connective."))

(defun non-atomic (gwff)
  (cond ((label-q gwff) (apply-label gwff (non-atomic gwff)))
	(t (or (ae-bd-wff-p gwff)
	       (not-p gwff) (and-p gwff) (or-p gwff) (implies-p gwff)))))

(defwffop non-atomic-or-truthvalue
  (argtypes gwff)
  (resulttype boolean)
  (argnames gwff)
  (arghelp "Wff")
  (applicable-p always-true)
  (mhelp "Tests whether a wff is not atomic or a truth value, that is, truth, falsehood, negated, 
quantified or the result of joining two wffs with a binary connective."))

(defun non-atomic-or-truthvalue (gwff)
  (cond ((label-q gwff) (apply-label gwff (non-atomic-or-truthvalue gwff)))
	(t (or (eq gwff 'TRUTH) (eq gwff 'FALSEHOOD)
               (ae-bd-wff-p gwff)
	       (not-p gwff) (and-p gwff) (or-p gwff) (implies-p gwff)))))



(defwffop is-variable
  (argnames gwff)
  (argtypes gwff)
  (wffargtypes "A")
  (resulttype boolean)
  (wffop-typelist "A")
  (arghelp "Wff")
  (mhelp "Test whether a wff is a logical variable."))

(defun is-variable (gwff)
  (and (gvar-p gwff) (propsym-p gwff)))

(context abbrev-ops)

(defwffop inst-def
  (argtypes gwff)
  (wffargtypes "A")
  (wffop-type "A")
  (wffop-typelist "A")
  (resulttype gwff)
  (argnames inwff)
  (arghelp "inwff")
  (mhelp "Instantiate the first abbreviation, left-to-right."))

(defun inst-def (inwff)
  (let ((oneflag nil))
    (declare (special oneflag))
    (let ((inst-wff
	   (instantiate-definitions
	    inwff
	    #'(lambda (abbsym chkarg)
		(declare (ignore abbsym chkarg) (special oneflag))
		(prog1 (not oneflag) (setq oneflag t)))
	    nil)))
      (if (not oneflag)
	  (throwfail "No abbreviation found.")
	  inst-wff))))


(context lambda-op)

(defwffop ab-change
  (argtypes gwff gvar)
  (argnames gwff newvar)
  (wffargtypes "B" "A")
  (wffop-typelist "B" "A")
  (wffop-type "B")
  (applicable-q (lambda (gwff newvar)
		  (and (boundwff-q gwff) (type-equal (bindvar gwff) newvar)
		       (not-free-in newvar gwff)
		       (free-for newvar (bindvar gwff) (gdr gwff)))))
  (resulttype gwff)
  (mhelp "Alphabetic change of variable at top-level."))

(defwffop lnorm
  (argtypes gwff)
  (argnames gwff)
  (resulttype gwff)
  (wffargtypes "A")
  (wffop-typelist "A")
  (wffop-type "A")
  (mhelp "Put a wff into lambda-normal form, using beta or beta-eta conversion 
according to the value of flag LAMBDA-CONV. Compare LNORM-BETA and LNORM-ETA."))

(defun lnorm (gwff)
  (declare (special lambda-conv))
  (case lambda-conv
    ((beta-only beta-eta-separate) (lambda-norm gwff))
    (beta-eta-together (etanorm (lambda-norm gwff)))))

(defflag lambda-conv
  (flagtype symbol)
  (default 'BETA-ETA-TOGETHER)
  (change-fn (lambda (flag value pvalue) 
                     (unless (memq value '(beta-eta-together beta-eta-separate beta-only)) 
                         (set flag pvalue)
                         (msg "Sorry, the value of the flag must be one of the followings:" T
                              "1)BETA-ETA-TOGETHER;" T
                              "2)BETA-ETA-SEPARATE;" T
                              "3)BETA-ONLY." T))))

  (subjects auto::etrees etr-nat tactics transmit)
  (mhelp "BETA-ETA-TOGETHER means that BETA and ETA rules are used together; 
BETA-ETA-SEPARATE means BETA and ETA rules are used separately; BETA-ONLY 
means that only BETA rule is allowed."))

(definfo beta-eta-together
  (mhelp "A flag setting for LAMBDA-CONV.
When doing lambda-conversion, use beta and eta rules together (for example,
when translating an eproof into ND style)."))

(definfo beta-eta-only
  (mhelp "A flag setting for LAMBDA-CONV.
When doing lambda-conversion, only use beta rule, not eta rule (for example,
when translating an eproof into ND style)."))

(definfo beta-eta-separate
  (mhelp "A flag setting for LAMBDA-CONV.
When doing lambda-conversion, use beta and eta rules together (for example,
when translating an eproof into ND style)."))

(defwffop lnorm-beta
  (argtypes gwff)
  (argnames gwff)
  (resulttype gwff)
  (wffargtypes "A")
  (wffop-typelist "A")
  (wffop-type "A")
  (mhelp "Put a wff into beta-normal form, not using eta 
conversion. Compare LNORM and LNORM-ETA."))

(defun lnorm-beta (gwff)
  (lambda-norm gwff))

(defwffop lnorm-eta
  (argtypes gwff)
  (argnames gwff)
  (resulttype gwff)
  (wffargtypes "A")
  (wffop-typelist "A")
  (wffop-type "A")
  (mhelp "Put a wff into eta-normal form, not using beta
conversion. Compare LNORM-BETA and LNORM."))

(defun lnorm-eta (gwff)
  (etanorm gwff))

