\chapter{Mating-Search}

The top level files for matingsearch are:
{\it mating-dir.lisp} for ms88, 
{\it ms90-3-top.lisp} for ms90-3,
{\it option-tree-search.lisp} for ms89 and ms90-9, {\it ms91-search.lisp} for
ms91-6 and ms91-7, and {\it ms92-9-top.lisp} for ms92-9 and {\it ms93-1.lisp} 
for ms93-1.  The lisp files with prefix {\it ms98} are those used by ms98-1.
The code for \indexcommand{GO} in {\it mating-top.lisp} shows 
what the main functions are.

There are a lot of comments about the workings of the code embedded in the
lisp files; in particular there is an outline of ms90-3 at the top of
{\it ms90-3-top.lisp}.

\section{Data Structures}

See the section on flavors and labels (section ~\ref{labels}) for a discussion
of some relevant information about the data structures below. Among other things, 
that section has the definition of the flavor "etree".

\subsection{Expansion Tree}
\label{etrees}

The data structure \indexData{etree}, defined in 
\indexfile{etrees-labels.lisp}, has the following properties:

\begin{enumerate}
\item \indexother{name}: the name of the etree. We can use this attribute to identify
which kind of structure an etree is.

\item \indexother{components}: is a list which contains all children of the etree. 
The children of an etree are also etrees. We could use this attribute to check whether an 
etree is a leaf, true, or false. 

\item \indexother{positive}: 
tells us whether the formula which an etree represents (which is the formula 
given by \indexfunction{get-shallow}) appears positively or negatively in the 
whole formula. This will be used to compute the vpform of the whole formula.
(The vpform of a subformula may be not the same as the corresponding part of it 
in the whole formula because the "positive" property
of the subformula is dependent on the context.)

\item \indexother{junctive}: can be used for printing the vpform. 
This attribute is linked tightly with the "positive" attribute, and has to do with
whether the node acts as neutral, conjunction or disjunction.

\item \indexother{free-vars}: is a list, containing the free variables in whose scope 
the node appears. When you skolemize a formula, you should use this attribute.
 
\item \indexother{parent}: is the parent of this etree.

\item \indexother{predecessor}: this slot tells you the leaf name from which the current
etree was deepened. It is mainly used for handling skolem constants.

\item \indexother{status}: has little to do with the system as currently 
implemented, but you should be
careful when you are creating commands which will change the variable 
{\tt current-topnode}. You have two choices:
\begin{enumerate}
\item Change the value of {\tt *ignore-statuses*} to T. Then you need
not worry about this attribute. Of course,
what you are doing may then not be compatible with the future versions
of the system. This is highly discouraged.

\item When you want to create new nodes or change some nodes in the {\tt current-topnode}
make the corresponding changes in the attribute {\tt statuses} of {\tt current-eproof}, 
which is a hash-table. Don't forget this, otherwise your new commands won't work.
\end{enumerate}
\end{enumerate}

Actually, according to an old \index{email from Dan Nesmith about status},
the status of etrees
is {\it not} stored in the status slot of an etree.  Instead the status
of an etree is in a hash table associated with the current-eproof.
(So, update-statuses depends on the value of current-eproof.)

The same email contains information on the predecessor slot.
For reference, here is the email:\label{dans-mail}

\begin{verbatim}
To: Peter.Andrews@K.GP.CS.CMU.EDU
Cc: issar@K.GP.CS.CMU.EDU, hwxi@K.GP.CS.CMU.EDU, mbishop@K.GP.CS.CMU.EDU
Subject: Re: STATUS and PREDECESSOR 
In-Reply-To: Your message of "Fri, 25 Sep 92 16:05:44 EDT."
             <1992.9.25.20.0.41.Peter.Andrews@K.GP.CS.CMU.EDU> 
Date: Tue, 29 Sep 92 16:34:36 +0100
Message-Id: <29531.717780876@js-sfbslc10.cs.uni-sb.de>
From: "Dan Nesmith" <nesmith@cs.uni-sb.de>

Your message dated: Fri, 25 Sep 92 16:05:44 EDT
>	Can you please explain what the slots STATUS and PREDECESSOR
>in the structure current-topnode are for? (Of course, maybe we should
>have a meeting with Sunil to have a discussion about this.)

Sorry it took so long to reply.  At first glance, I thought this was
something to do with unification.

current-topnode is a variable whose value, while you are in
the mating-search top-level, is the node of the expansion tree that you
are currently looking at.  Commands like D (down), UP, ^ (move to root),
use and change the value of this variable (see etrees-wffops, mating-top, 
mating-move).  

Actually, the unification top-level uses this same variable name, of course
rebinding it during the duration of the top-level (so there's no real
conflict).

Now, STATUS and PREDECESSOR are actually slots in every expansion tree
node (defined in etrees-labels).  

Each etree node has a status, which is a nonnegative integer.  0 means
that the etree node should be ignored (as if it and its descendants
were not in the tree), while positive values indicate the node is active,
and (potentially) the higher the value, the more important it is.  
By the etree's status, you could rank certain expansions as more interesting
than others.  I don't think that is now being used anywhere.
Originally, this status was kept in a slot in each etree node.  I didn't 
really like this, because then you can't share etree nodes among different
"virtual" expansion trees.  For example, during the MS90-9 search procedures,
there is really just one expansion tree, which contains all of the 
expansions.  There are, however, many "virtual" expansion trees, that is,
expansion trees with the same root, but with different subsets of the
expansions "turned on".  Each one of these virtual trees is kept in a
separate eproof structure.  For this reason, the statuses are actually
kept in a hashtable in the eproof structure as well, so changing the status
of a node in one virtual tree doesn't affect its status in other trees. 
E.g.,
Assume we have a tree with root expansion node EXP0, and children LEAF1, LEAF2.
Then we have potentially 3 virtual trees: one where LEAF1 has positive status
and LEAF2 has 0 (is not there); one where LEAF2 positive status and LEAF1 has 0;
and one where both LEAF1 and LEAF2 have positive status (are thus both
considered in the proof process).  Functions that do things like create the
jform use the status to decide which nodes belong and which don't.

Because statuses are now kept separate from the nodes themselves, the STATUS 
slot is an anachronism, and actually can now be removed (delete the form
"(status 1)" from the file etrees-labels.lisp).

PREDECESSOR is related.  This is a symbol, the name of the etree node from
which this node originated.  For example, suppose we have a leaf node LEAF0.
If we deepen this node, then we will get something like EXP0 as a result.  Its
PREDECESSOR slot will be LEAF0. If we then change the status of all its 
expansions to 0, then this node is effectively a leaf node again, and it 
will be printed out with the name LEAF0 as before.  E.g.
<34>mate "exists y P y" 

DEEPEN (YESNO): Deepen? [Yes]>no

<Mate35>etd

LEAF0   EXISTS y(I) P(OI) y

<Mate36>dp

EXP0
<Mate37>etd

EXP0   LEAF1    y^0(I)
LEAF1   P(OI) y^0(I)

<Mate38>1

LEAF1
<Mate39>mod-status 0


<Mate40>up

LEAF0
<Mate41>etd

LEAF0   EXISTS y(I) P(OI) y


PREDECESSOR is also used in case a node's name is not found in the
statuses hashtable; so effectively a node can inherit the status of the
node from which it was created.

Dan
\end{verbatim}

The file \indexfile{etrees-debug} contains functions useful for debugging
code dealing with etrees.  
The function \indexfunction{check-etree-structure}
recursively checks structural properties of an etree,
and the function \indexfunction{check-etree-structure-break}
calls \indexfunction{check-etree-structure} and calls a break
if the etree fails the structural test.
The idea is that one can temporarily insert 
\begin{verbatim}
(check-etree-structure-break <etree>) 
\end{verbatim}
in suspicious parts of the code
to find out when an etree loses its integrity.  If the etree does not
have structural integrity, a break is called, sending the user (programmer)
to the debugger.  If one wants to insert this in several places in the code,
one may want to include a message as in
\begin{verbatim}
(check-etree-structure-break <etree> "unique identifying message")
\end{verbatim}
to identify which caused the break.

\subsection{The Expansion Proof}
In the mate toplevel, we have an \indexother{expansion proof} stored in the 
special variable
\indexother{current-eproof}, which is an \indexData{eproof}-structure. 
\indexother{current-eproof}
has a attribute \indexData{etree}, whose value is often used to update
variable \indexother{current-topnode}.

Actually, a whole formula is represented by a tree, each node of which is an 
\indexData{etree}.
At first, \indexother{current-topnode} is the root of the tree. 
Each node in the tree can be one of the following structures,
all of which are derived from the structure \indexData{etree}, described 
above. We note only the differences between these structures and etrees.

\begin{enumerate}
\item \indexother{econjunction} is just an etree without 
any additional new attributes. \indexother{components} is a list containing two 
elements, and \indexother{junctive} should be {\tt dis} or {\tt con}.

\item \indexother{edisjunction} is like \indexother{econjunction}.

\item \indexother{implication} is like \indexother{econjunction}

\item \indexother{negation} is just an etree. \indexother{components} contains one element
and \indexother{junctive} is {\tt neutral}.

\item \indexother{skolem} is an etree with two additional attributes:
\begin{enumerate}
\item \indexother{shallow}: contains the shallow formula that the attribute 
\indexother{skolem} represents.
Never forget to make the corresponding changes in it if you have changed some 
other parts of this node; otherwise the proof cannot be transformed into natural 
deduction style by \indexcommand{etree-nat}
since the function \indexfunction{get-shallow} would not work normally.

\item \indexother{terms}: is a \indexData{skolem-term} structure, containing
a term replacing the original variable, and something else.
\end{enumerate}

\item \indexother{selection} is also an etree with attributes \indexother{shallow}
and \indexother{terms}, just as \indexother{skolem} etree nodes.  Whether the
etree contains \indexother{selection} or \indexother{skolem} nodes depends on
the values of \indexflag{SKOLEM-DEFAULT}.

\item \indexother{expansion} is an etree with three additional properties:
\begin{enumerate}
\item \indexother{shallow}: is the same as in \indexother{skolem}.
\item \indexother{terms}: is an \indexData{exp-var} structure, containing the 
expansion variable for this expansion.
\item \indexother{prim-vars}
\end{enumerate}

\item \indexother{rewrite} is an etree that rewrites the wff in some way.
Rewrite nodes have the following four additional attributes:
\indexother{shallow}, \indexother{justification}, \indexother{ruleq-shallow},
and \indexother{reverse}.  The \indexother{justification} attribute is
a symbol which can currently be one of the following values (this list may not be exhaustive):
\begin{enumerate}
\item \indexother{EQUIVWFFS}:  Usually means there have been some definition expansions.
In case dual instantiation is being used, it may mean the wff has been rewritten to
a conjunction or disjunction of the wff and the instantiated form.
\item \indexother{LAMBDA}, \indexother{BETA}, \indexother{ETA}:  The wff is the result of the appropriate normalization.
\item \indexother{EQUIV-IMPLICS}, \indexother{EQUIV-DISJS}:  An equivalence was expanded.
\item \indexother{LEIBNIZ=}:  Rewrites an equational wff using the Leibniz definition of equality.
\item \indexother{EXT=}:  Rewrites an equational wff between terms of functional type using extensionality.
\item \indexother{REFL=}: Rewrites an equational wff of the form ``a = a'' to TRUTH.
\item \indexother{RULEQ}:  The only time this appears to be used is when \indexflag{MIN-QUANTIFIER-SCOPE}
is set to T, in which case the quantifiers in the wff are pushed in as far as possible.
\item \indexother{ADD-TRUTH}, \indexother{TRUTHP}:  May conjoin the wff with TRUTH, or disjoin the wff with (NOT . TRUTH).
See the flags \indexflag{ADD-TRUTH} and \indexflag{TRUTHVALUES-HACK}.
\end{enumerate}

\item \indexother{leaf} is an etree with the additional attribute \indexother{shallow},
as in \indexother{skolem}, above. The \indexother{components}, \indexother{junctive}
and \indexother{predecessor} attributes of \indexother{leaf} are all {\tt nil}.

\item \indexother{true}

\item \indexother{false}

\item \indexother{empty-dup-info}  is an etree used by the \indexcommand{NAT-ETREE}
translation code, not by the mating search.

\end{enumerate}

There is also an eproof stored in the global variable \indexother{master-eproof}.
In my experience, this has been set to the same value as \indexother{current-eproof}.
The only place I can find in the code where
it may have a different value is when using option sets (search procedures \indexother{MS91-6}
and \indexother{MS91-7},
see the files \indexfile{ms91-basic.lisp} and \indexfile{ms91-search.lisp}).
In particular, there are \indexother{option-set} structures which have an \indexother{eproof} slot.
These are set to {\it copies} of the eproof structure (as opposed to the identical
structure) in \indexother{master-eproof}.  Then, in \indexfunction{finish-up-option-search},
\indexother{current-eproof} is set to the value of such an \indexother{eproof} slot.

In addition to the etree slot,
there are numerous other slots associated with an eproof:
\begin{enumerate}
\item \indexother{jform}:  Contains the jform associated with the etree (see section~\ref{etree-to-jform}).

\item \indexother{all-banned}: A list of expansion
vars and a list of selected vars whose selection node occurs beneath the expansion term.
This is needed to check acyclicity condition.  The value is set by the function \indexfunction{fill-selected}.

\item \indexother{inst-exp-vars-params}:  An association list of expansion variables that occur instantiated in the etree
and the selected variables that occur in the term.  This is needed to check the acyclicity condition when
there are substitutions (e.g., set variable substitutions made in a preprocessing stage) that have
contain selected variables.  (See section ~\ref{acyclicity}.)

\item \indexother{dissolve}:  An alist of symbols representing connections between nodes in the etree
which we assume will be in the final solution.  The code for building jforms from etrees (\indexfunction{etree-to-jform},
\indexfunction{etree-to-prop-jform}) will use this, as well as the flag \indexflag{DISSOLVE}, to
dissolve vertical paths from the jform.  (Dissolution is described in~\cite{Murray93}.  The current
dissolution code dissolves one connection at a time, iterating the procedure for each connection.)

\item \indexother{free-vars-in-etree}:  This is an association list between free expansion variables
which occur in the eproof (i.e., those which have not be instantiated), and the corresponding expansion
node in which the variable was introduced.  Note that if expansion variables are \indexother{EXP-VAR}
structures.  An expansion variable is uninstantiated with the \indexother{VAR} slot is the same as
its \indexother{SUBST} slot.  When an expansion variable $p$ (introduced in expansion node $EXP_j$)
is instantiated with a term which introduces
new expansion variables $\{q_i\}$ (e.g., a PRIMSUB), the pair ($p$ . $EXP_j$) is removed from this slot
and the pairs ($q_i$ . $EXP_j$) is included in the list.  (Also, in such a case, the value of
the slots \indexother{substitution-list}, \indexother{inst-exp-vars-params}, 
\indexother{all-banned} may change to reflect this instantiation.)

\item \indexother{skolem-constants}:  An association list of skolem constants and integers representing their arities.
(Note: If \indexflag{SKOLEM-DEFAULT} is set to NIL, then all skolem constants will have arity 0.)

\item \indexother{substitution-list}:  A list of expansion variables which have been instantiated.

\item \indexother{leaf-list}:  A list of the leaf nodes occurring in the etree.

\item \indexother{skolem-method}:  Corresponds to the value of \indexflag{SKOLEM-DEFAULT}.

\item \indexother{max-cgraph-counter}

\item \indexother{bktrack-limit}

\item \indexother{connections-array}

\item \indexother{incomp-clists-wrt-etree}

\item \indexother{mating-list}

\item \indexother{incomp-clists}

\item \indexother{cgraph}

\item \indexother{skolem-node-list}:  A list of the skolem nodes which occur in the etree.

\item \indexother{stats}

\item \indexother{max-incomp-clists-wrt-etree}

\item \indexother{symmetry}:  A hash table with etree nodes as keys
and \indexother{symmetry-holder} structures as values.  This information
is built when the etree is deepened, but does not appear to be used
anywhere in the code.

\item \indexother{merged}:  This is true if the etree has been merged.

\item \indexother{statuses}:  A hashtable of nodes in the etree and their statuses.
See the discussion above, and Dan's email in section~\ref{dans-mail}.

\item \indexother{name}:  This symbol is the name of the eproof.
\end{enumerate}

\subsection{Relevant Global Variables}

In addition to the eproof slots, there are some global variables 
which store information relevant to the current etree.

The following global variables are used by dual instantiation
(when
\indexflag{REWRITE-DEFNS} or \indexflag{REWRITE-EQUALITIES}
is set to \indexother{LAZY2} or, equivalently, \indexother{DUAL}).
\begin{enumerate}
\item \indexother{*instantiated-defs-list*}
The value is an association list of symbols and the shallow formula of the
rewrite in which the dual instantiation was performed.  For example,
the value might be
\begin{verbatim}
((#:G162733 ((SUBSET<O<OI><OI>> . c<OI>) . d<OI) 
(#:G162731 . ((=<OII> . a<I>) . b<I>)))
\end{verbatim}
The symbols have no apparent meaning, but are used internally as an identifier.
Note that this list contains both abbreviations and equations which have been
instantiated using dual instantiation.  The value of this global is built during
deepening (see section~\ref{deepening})
\item \indexother{*instantiated-eqs-list*}  
This global's value during deepening is an association list of symbols and the shallow
formula of the equation being rewritten (so its elements are a subset of the
elements of *instantiated-defs-list*).
However, the elements of this list are removed during deepening so that
the final value after deepening an etree to literals seems to always be NIL.
\item \indexother{*hacked-rewrites-list*}
Its value is a list of elements of the form 
\begin{verbatim}
(<rewrite node> . 
    (<instantiated wff> . <leaf with uninstantiated form>))
\end{verbatim}
\item \indexother{*banned-conns-list*}  This is an association list of leaves which are not to be mated, e.g.,
\begin{verbatim}
((L4 . L8) (L4 . L9) (L11 . L14) (L11 . L15))
\end{verbatim}
The value appears to be leaves which correspond to an uninstantiated definition and the leaves which
appear beneath the instantiated form.  Since these leaves share a vertical path, they could be mated.
Apparently, the intuition is that we never want to mate a wff with an uninstantiated defn with a subformula
of the instantiated form.  However, it is not clear that we {\it can} really rule out such connections,
since higher order quantifiers might cause a wff to be the negation of a subformula of itself.
However, we can legally ban these connections if only for the reason that we do not {\it need} to use
dual instantiation at all.
The value of this flag is used by \indexfunction{quick-unification-connection} to rule out some connections.
\item \indexother{*ho-banned-conns-list*}  Similar to *banned-conns-list*, but with a slightly different
representation.  Instead of pairs of leaves, each leaf corresponding to an uninstantiated definition
is associated with a list of the leaves that occur beneath the instantiated form.  For example,
\begin{verbatim}
((L4 . (L9 L8)) (L11 . (L15 L14)))
\end{verbatim}
\item \indexother{*unsubst-exp-vars*}  This is a list of the expansion variables in the etree
which are not instantiated.  This should usually be a list of the car's from the \indexother{current-eproof}
eproof slot \indexother{free-vars-in-etree}.  Note that this variable is only set if some node
was rewritten using dual instantiation.  Otherwise its value will be whatever it was the last time
an etree was deepened using dual instantiation.
\item \indexother{*rew-unsubst-exps*}  This is a list of expansion variables which occur free
in some leaf corresponding to an uninstantiated definition.
\end{enumerate}

These are some other global variables.
\begin{enumerate}
\item \indexother{*leibniz-var-list*}  An association list of variables and rewrite nodes.
The variables are expansion variables (actually, only
the symbol for the variable is used) introduced by the Leibniz definition of equality (i.e., the
$q$ in $\forall q \, . \, q \, A \, \supset \, q \, B$).  The rewrite node is the
rewrite node in which the equality was rewritten using the Leibniz definition.
Note that the $q$ is only an expansion variable if the rewrite node is positive.
\item \indexother{*after-primsub*}  This is just a toggle that is temporarily set to T
after a primsub has been done, so that it will be T while the new etree is deepened.
\end{enumerate}

There may be other global variables.  Needless to say, it is difficult to build an
expansion tree in any way other than using the deepening code that is already written
(see the file \indexfile{etrees-wffops.lisp} and section~\ref{deepening} of this chapter)
because all these global variables
and eproof slots need to be maintained.

\subsection{Other Structures}
\begin{itemize}
\item A \indexData{mating} has certain attributes:
\begin{enumerate}
\item A set of connections

\item A unification tree
\end{enumerate}

\item A \indexData{unification tree} is a tree of nodes.

\item A \indexData{uni-term} is an attribute of a node (which is a structure); it is 
a set of disagreement pairs.

\item A \indexData{failure record} is a hashtable. 
MS88 (and the other non-path-focused procedures) uses the failure 
record.  MS90-3 (and the other path-focused procedures) does not use it (this is one reason
why, when \TPS abandons a mating and later returns to the partially completed 
eproof, ms91-6 continues approximately where it left off and ms91-7 does not).
Links (which all occur in the connection graph) are represented as numbers,
so sets of links are just ordered lists of numbers, and one can
efficiently test for subsets. 
Given a new partial mating M, \TPS just
looks at all the entries in the failure record to see if any of them
are subsets of M. 

\end{itemize}

\section{Operations on Expansion Trees}

\subsection{Deepening}\label{deepening}

The code for deepening an expansion tree is in the file \indexfile{etrees-wffops.lisp}.
The idea behind deepening an expansion tree is to find the leaves,
then destructively replace the leaves with a new node depending on the
structure of the shallow formula and the setting of many, many flags.
The key function to try to understand is \indexfunction{deepen-leaf-node-real}.
Suppose $A$ is the shallow wff of the leaf in question.
Here is a quick outline of what this function does:
\begin{enumerate}
\item If $A$ can be $\lambda$-reduced, create a rewrite node with a leaf of
the reduced form as its child.
\item If $A$ is $\lnot B$, then create a negation node with a leaf of $B$ as its child
(except sometimes when \indexflag{ADD-TRUTH} is set to T).
\item If $A$ is $B \land C$, then create an econjunction node with leaves for $B$ and $C$ as children.
\item If $A$ is $B \lor C$, then create an edisjunction node with leaves for $B$ and $C$ as children.
\item If $A$ is $B \limplies C$, then create an implication node with leaves for $B$ and $C$ as children.
\item If $A$ is $B \equiv C$, then create a rewrite node, rewriting the equivalence either as a conjunction
of implications or disjunction of conjunctions (depending on the values of \indexflag{MIN-QUANTIFIER-SCOPE}
and \indexflag{REWRITE-EQUIVS}
and the parity of the leaf).
\item If $A$ is a positive existential formula or negative universal formula,
create a skolem node or selection node (depends on the value of \indexflag{SKOLEM-DEFAULT})
with a leaf of the scope of the quantifier as its child.
\item If $A$ is a positive universal formula or negative existential formula,
create an expansion node with a leaf of the scope of the quantifier as its child.
\item If $A$ is an equation of the form $t = t$, 
and \indexflag{REWRITE-EQUALITIES} is not set to \indexother{NONE}, then 
create a rewrite node with a leaf of TRUTH as its child.
\item If $A$ is an equation,
and \indexflag{REWRITE-EQUALITIES} is not set to \indexother{NONE}, then 
rewrite the equation (depending on \indexflag{REWRITE-EQUALITIES}) and
create an appropriate rewrite node.
\item If $A$ is a symbol introduced by dual instantiation of an equality, replace it
with the instantiated formula.
\item Finally, if there is a definition, then there is a very complicated
case which creates an appropriate rewrite node.  Anyone trying to figure out
this part of the code needs to pay close attention to the value of
\indexother{REWRITE-DEFNS}.  Ordinarily, \indexother{REWRITE-DEFNS} is a flag
whose value is a list of a form such as 
\begin{verbatim}
(DUAL (EAGER TRANSITIVE) (NONE INJECTIVE SURJECTIVE))
\end{verbatim}
However, at the beginning of \indexfunction{deepen-leaf-node-real},
the value of \indexother{REWRITE-DEFNS} is dynamically set to
a form
\begin{verbatim}
((DUAL SUBSET REFLEXIVE) (EAGER TRANSITIVE) (NONE INJECTIVE))
\end{verbatim}
where all the abbreviations appearing the $A$ are explicitly in the list,
and those not appearing in $A$ are removed.
To make matters more confusing, rewrite-defns is dynamically set in this
case to a simple list of abbreviations which may be rewritten, before
calling the function \indexfunction{contains-some-defn}.  This would be a value
such as
\begin{verbatim}
(SUBSET REFLEXIVE TRANSITIVE)
\end{verbatim}
\end{enumerate}
The deepening code also sets many global variables as well as eproof slots
in current-eproof.  The code really assumes we are deepening the etree
in the etree slot of \indexother{current-eproof}.

\section{Skolemization}

There are three \indexother{skolemization} procedures in \TPS; SK1, SK3 and NIL.
(Actually, the latter is not skolemization at all, but the selection nodes method from Miller's thesis. 
However, it still uses skolem constants internally.) 
The flag \indexflag{SKOLEM-DEFAULT} decides which one will be used in a proof, and
the help message for that flag explains the difference.

We assume familiarity with the way that SK1 is handled in TPS. SK3 is broadly 
similar; the only difference between the two is in the function \indexfunction{create-skolem-node}, where
the skolem variables are chosen differently.

NIL, the selection node method, is very different. Selections are represented as Skolem
constants with no arguments, and we now describe the additional machinery needed to make the search 
procedure work in this case.

During simplification (in unification), the requirement that a certain relation should be acyclic
is checked. The exact statement of this relation is given in Miller's thesis; we implement it
(roughly speaking) as a requirement that no substitution term for an expansion variable should 
contain any of the selections which occur below that variable.

Extra slots, called {\tt exp-var-selected} on expansion variables and {\tt universal-selected} on 
universal jforms, are used to record all of the 
selections below each quantifier. This is used in the unification check, and more crucially
in path-focused duplication (since skolem terms are stripped out of the jform, this is our only 
way to remember where they were).  See the section on selected variables for more information
about checking acyclicity of the dependency relation.

In SK1 and SK3, duplicating a quantifier above a skolem term produces a new skolem term 
consisting of the same skolem constant applied to different variables. In NIL, we obviously 
can't use the same skolem constant everywhere (consider EXISTS X FORALL Y . P X IMPLIES P Y ; 
if we persistently select the same Y every time we duplicate X, the proof will fail). This 
has two major consequences:

\begin{itemize}
\item Path-focused duplication has to be changed. We can no longer duplicate implicitly by changing the
name of the quantified variable; we must now make a copy of the entire scope of the 
quantifier and descend into it, renaming all the selections as we go. These copies are stored
in a chain using the universal-dup slot of the jform (so the universal-dup of the top jform
contains the first copy, whose universal-dup contains the second copy, and so on). These
duplications are preserved during backtracking, in case they are needed again later; we 
use universal-dup-mark to remember how many of them are "really" there.

\item The procedure for expanding the etree after ms90-3 finishes a search has to be completely
replaced. The old procedure relied on the fact that the names of skolem constants never changed,
and so it was possible to attach all of the expansion terms to the jform and then duplicate and
deepen the etree while applying the appropriate substitutions. The names of selections {\it do}
change; this makes the substitutions incorrect (because they will contain the names of old selections).
So we use ms90-3-mating and dup-record to duplicate the etree directly, and then add the
correct connections to it using ADD-CONN. This procedure is probably still buggy.
\end{itemize}

\section{Checking Acyclicity of the Dependency Relation}\label{acyclicity}

\subsection{The Dependency Relation}

An expansion proof is given by an expansion tree and a mating.
One of the conditions on the expansion tree is that the
so-called ``dependency relation'' is acyclic (irreflexive).
For an expansion tree $Q$, let $S_Q$ be the set of selected
variables in $Q$ and let $\Theta_Q$ be the set of occurrences of expansion terms.
The following definition can be found in Miller's thesis.

{\bf Definition.}  Let $Q$ be an expansion tree.  Let $<^0_Q$ be the binary
relation on $\Theta_Q$ such that $t<^0_Q s$ if there exists $y\in S_Q$
so that $y$ is selected in a node dominated by $t$ and $y$ is free in $s$.
The transitive closure
$<_Q$ of $<^0_Q$ is called the {\it dependency relation}.

While the relation above is defined in terms of expansion terms,
the way TPS actually searches for a proof is as follows.
Expansion variables are used in place of expansion terms,
and TPS finds instantiations for these variables.  These
instantiations arise from two sources: pre-processing (usually
giving set variable instantiations)
and unification.  The instantiations made during pre-processing may contain expansion
variables which will later be instantiated by unification.

% In procedures designed before 2000 . . .
During the mating search, unification constructs substitutions for
expansion variables, and checks the acyclicity condition for those 
% ******* clarify this, the acyclicity condition is on etree's 
substitutions.  To be sound, TPS should include the substitutions
made in pre-processing as well.  Until now, TPS did not include these
substitutions in the check.  This did not cause a problem with soundness
because the omitted substitutions (all PRIMSUBS/GENSUBS) did not
contain any selected variables.

The most obvious way to ensure soundness is to include all the
substitutions in the acyclicity check, not only those arising from
unification.  However, since the instantiations made before search
begins will not change during search, we should be able to find a more efficient
method.  The idea is to start with an expansion tree obtained after pre-processing, i.e.,
after instantiations have been made and the resulting tree has been deepened.

{\bf Definitions.}  Let $Q$ be a given expansion tree.  
\begin{itemize}
\item Let $\Sigma_Q\subseteq \Theta_Q$ be the set of occurrences of expansion terms in $Q$
which are {\it not} expansion variables.
\item Let $V_Q$ be the set of expansion variables
that occur in $Q$.  Note that $V_Q$ and $\Sigma_Q$ are disjoint sets.
\item For each expansion variable $v$, let $T_v \subseteq \Theta_Q$ be the set
of expansion terms in which $v$ occurs free.  Note that $T_v$ is always nonempty.
\item For each $t\in \Sigma_Q$, let $T_t = \{t\} \subseteq \Theta_Q$.
\item For each $q\in\Sigma_Q \cup V_Q$, let $B(q)$ be the set of selected variables
$y$ whose selection node is dominated by the arc corresponding to $t$ for some $t\in T_q$.  
\item For each $t\in\Sigma_Q$, let $S(t)$ be the set of selected variables which
occur free in $t$.
\end{itemize}

The set $B(t)$ is the set of ``banned'' selection variables for $t\in\Sigma_Q\cup V_Q$.

The following definitions depend upon a substitution $\theta$.  This corresponds
to the substitution found by unification during mating search.

{\bf Definitions.} Let $\theta$ be a given substitution for the expansion variables in $V_Q$.
(Note that we allow $\theta(v) = v$ for some $v\in V_Q$ in order to make $dom(\theta) = V_Q$.)
\begin{itemize}
\item For each $v\in V_Q$, let $S(v)$ be the set of selected variables which occur
free in $\theta(v)$.
\item Define a relation $<^0_{Q,\theta}$ on $\Sigma_Q\cup V_Q$ by
$q <^0_{Q,\theta} r$ iff there exists a $y\in B(q)\cap S(r)$.
\item Let $<_{Q,\theta}$ be the transitive closure of $<^0_{Q,\theta}$.
\item The substitution $\theta$ is acyclic with respect to $Q$ if
the relation $<_{Q,\theta}$ is acyclic
(irreflexive).
\end{itemize}

{\bf Remark 1.}  It is important to note that $\theta$ is a substitution which does not create
any new nodes in $Q$.  (This is in contrast to substituting and then deepening the tree.)
In particular, the set of selected variables is the same, i. e., $S_Q = S_{\theta(Q)}$.  
Also, for the same reason, for each $t\in\Sigma_Q$, $B(t)$ is the set of selected variables $y$
whose selection node is dominated in $\theta(Q)$ by the expansion term occurrence $\theta(t)$.  
Similarly, for $v\in V_Q$, $y\in B(v)$ means there is some expansion term $t\in\Theta_Q$
such that $v$ occurs free in $t$ and $y$ is dominated in $\theta(Q)$
by $\theta(t)$.

{\bf Remark 2.}  Note that we do not consider $\lambda$-terms equivalent up to $\lambda$-conversion.
The expansion tree must have explicit rewrite nodes to $\lambda$-normalize formulas.
For this reason, if $y$ is free in a term $t$ in $Q$, it will also be free in $\theta(t)$ in $\theta(Q)$.
(That is, we can never project the $y$ away because this would require not just substitution,
but also deepening $\theta(Q)$.)

{\bf Lemma 1.}  Let an expansion tree $Q$ and a substitution $\theta$ for $V_Q$ be given.
Suppose $q <_{Q,\theta} q'$.
Then there exists a $t\in T_q$ such that for every $t'\in T_{q'}$
$$\theta(t) <_{\theta(Q)} \theta(t').$$

{\bf Proof.}  By induction on the number of transitivity steps.

For the base case, suppose $q <^0_{Q,\theta} q'$.  Then, there is some
$y\in B(q) \cap S(q')$.  Since $y\in B(q)$, there is some $t\in T_q$
such that $y$ is dominated by $t$ in $Q$.  So, $y$ is dominated by $\theta(t)$
in $\theta(Q)$.  Now, suppose $t'\in T_{q'}$.  We consider two cases.

If $q'\in \Sigma_Q$, then $t' = q'$ and $y\in S(q')$.  So, $y$ is free in $t'$.
By Remark 2, $y$ is free in $\theta(t')$ and we are done.

If $q' \in V_Q$, then $q'$ is free in $t'$.
Also, $y\in S(q')$ implies $y$ is free in $\theta(q')$.
From this we have $y$ is free in $\theta(t')$ and we are done.

For the induction step, suppose we have $q <_{Q,\theta} q_1 <_{Q,\theta} q'$.
By induction, we have some $t \in T_q$ such that for any $t_0 \in T_{q_1}$, $\theta(t) <_{\theta(Q)} \theta(t_0)$.
Also, we have some $t_1 \in T_{q_1}$ such that for any $t' \in T_{q'}$, $\theta(t_1) <_{\theta(Q)} \theta(t')$.
In particular, we have $\theta(t) <_{\theta(Q)} \theta(t_1) <_{\theta(Q)} \theta(t')$
for any $t'\in T_{q'}$. $\Box$

{\bf Lemma 2.}  Let an expansion tree $Q$ and a substitution $\theta$ for $V_Q$ be given.
Suppose we have $t, t'\in \Theta_Q$ with $\theta(t) <_{\theta(Q)} \theta(t')$.
There is a $q'\in \Sigma_Q \cup V_Q$ with $t' \in T_{q'}$ such that for any 
$q\in \Sigma_Q \cup V_Q$ with $t \in T_{q}$ 
we have $q <_{Q,\theta} q'$.

{\bf Proof.}  By induction on the number of transitivity steps.

For the base case, suppose $\theta(t) <^0_{\theta(Q)} \theta(t')$.
Let $y$ be a selected variable dominated by $\theta(t)$ and free in $\theta(t')$.
Since $y$ is free in $\theta(t')$, we must either have $y$ free in $t'$
or $y$ free in $\theta(v)$ for some $v\in V_Q$ free in $t'$.
In the first case, let $q' = t'$.  In the second case, let $q'$ be some $v \in V_Q$
where $y$ is free in $\theta(v)$ and $v$ is free in $t'$.
So, we have $y\in S(q')$.  Suppose we have any $q$ with $t\in T_q$.
Since $y$ is dominated by $t$, we have $y\in B(q)$ and we are done.

For the induction step, suppose $\theta(t) <^0_{\theta(Q)} \theta(t_1) <^0_{\theta(Q)} \theta(t')$.
By induction there is a $q'$ with $t'\in T_{q'}$ such that for any $q_0$ with $t_1\in T_{q_0}$,
we have $q_0 <_{Q,\theta} q'$.
Also by induction there is a $q_1$ with $t_1\in T_{q_1}$ such that for any $q$ with $t\in T_q$,
we have $q <_{Q,\theta} q_1$.
Together we have $q <_{Q,\theta} q_1 <_{Q,\theta} q'$ for any $q$ with $t\in T_q$. $\Box$

{\bf Proposition.}  Given an expansion tree $Q$ and a substitution $\theta$ for $V_Q$,
the dependency relation for $\theta(Q)$ is acyclic iff $\theta$ is acyclic with respect to $Q$.

{\bf Proof.}  Suppose we have $q <_{Q,\theta} q$ for some $q\in \Sigma_Q \cup V_Q$.
By Lemma 1, there is a $t\in T_q$ such that for any $t'\in T_q$, $\theta(t) <_\theta(Q) \theta(t')$.
In particular, $\theta(t) <_\theta(Q) \theta(t)$.

Suppose we have $s <_{\theta(Q)} s$ for some expansion term $s$ in $\theta(Q)$.
Since $\theta(Q)$ is obtained from $Q$ by substitution (and no deepening), there
is a unique expansion term occurrence $t\in \Theta_Q$ such that $s = \theta(t)$.
By Lemma 2, there is a $q'\in \Sigma_Q \cup V_Q$ with $t\in T_{q'}$ such that for 
any $q\in \Sigma_Q \cup V_Q$ with $t\in T_q$ we have $q <_{Q,\theta} q'$.
In particular, $q' <_{Q,\theta} q'$. $\Box$

After pre-processing, we can compute the set $\Sigma(Q)$ and $V_Q$, as well as
the sets $B(t)$, $B(v)$, and $S(t)$ for each $t\in\Sigma(Q)$ and $v\in V_Q$.
So, to check that the
acyclicity condition is satisfied when unification generates
a substitution $\theta$, it suffices to compute $S(v)$ for each $v\in V_Q$
with respect to $\theta$, and check for a $<^0_{Q,\theta}$-cycle. 

{\bf Efficiency Refinement.}  Clearly, if for some $s\in \Sigma(Q)$, either $B(s)$ or
$S(s)$ is empty, then $s$ cannot be part of a cycle with respect to any substitution
$\theta$, so we may disregard any such term.

\section{Expansion Tree to Jform Conversion}\label{etree-to-jform}
In {\it ms90-3-node}, the jform is computed directly from the etree without using 
the jform which may be stored with the etree. (It is not clear where or whether
that jform is used; it might be part of the interactive system.)

\indexfunction{msearch} does the search. It returns 
{\tt (dup-record ms90-3-mating unif-prob)}.
{\tt unif-prob} represents the solution to the unification problem, perhaps
as a substitution stack.
This triple is then handed to the processes that translate things back to
an expansion proof, call merging, and then translate to 
a natural deduction proof.
\indexfunction{msearch} looks at the flag \indexflag{order-components}; read
the help message for this flag for more information.

Each literal is a jform. One of its attributes is a counter
which gets adjusted to count how many mates that literal has; this is
compared with \indexflag{max-mates}.
The current jform being worked on is
essentially represented as a stack which is passed around as an 
argument. Indices are associated
with outermost variables which are implicitly duplicated. These
indices are also associated with literals in the scope of these
quantifiers to keep track of what copy of the literal is being mated.
It is only when unification is called that these indices are actually
attached to the variables to construct the terms unification must work
on.  (The functions \indexfunction{check-conn} and \indexfunction{conn-unif-p} in 
the file {\it ms90-3-path-enum}, and
related functions in that file, may be relevant here.)

The original code only created literals for leaves of the etree.
However, it is possible to mate arbitrary nodes of an etree (that share a vertical path)
if we include literals corresponding to these nodes.
Currently, the user may use the flag \indexflag{ALLOW-NONLEAF-CONNS} to specify
which nodes to include in the jform.  The flag \indexflag{ALLOW-NONLEAF-CONNS} takes
a list of symbols as its value.  If this list contains the symbol \indexother{ALL},
then every node will have a literal in the jform.  If this list the symbol \indexflag{REWRITES}
is in the list, then every rewrite node will have a literal in the jform (giving a jform
similar to the one dual instantiation produces, though dual instantiation affects the
structure of the etree).  If the name of any particular etree node is in the list, then
that etree node will have a literal in the jform.
The code also uses the slot \indexother{allow-nonleaf-conns} in the \indexother{current-eproof}
to decide which nonleaf etree nodes to include as literals in the jform.

After converting an etree into a jform, \TPS will perform dissolution (see~\cite{Murray93}) iteratively
on each connection in the flag \indexflag{DISSOLVE} and in the \indexother{dissolve} slot
of the \indexother{current-eproof}.  The resulting jform will not have any vertical paths
that pass through these connections.

\section{Path-Enumerator}

\subsection{Duplication Order}
Along a path the procedure stops at the first eligible universal
jform. A slot {\it dup-t} in a universal jform tells whether it is
eligible. Then it starts from there to find the innermost
universal jform on the path under the currently picked one, and 
uses the innermost one as its candidate for next duplication. This
is fulfilled by calling function {\it find-next-dup}.

When testing, please set flag max-dup-paths to an appropriate value
so that you can suppress some unnecessary quantifier duplications.
It may save a lot of your searching time and make you aware if
you are on the right track. Always duplicating innermost quantifiers
has the following advantages.
1) producing shorter and clearer proofs, and
2) lowering the values of flags max-search-depth, max-mates, and num-of-dups,
sometimes.

\subsection{Backtracking}
When bactracking starts, the search procedure removes the
last added connection. A path attached to the connection tells
the procedure where it should pick up the search. This works
efficiently since the following claim is almost always true:
With the help of disjunction heuristic, the number of paths
used to block jform is often a very small fraction of the
whole paths in the jform. This means that it is not a big
burden to carry the paths around all the time during searching.
The advantage is that the procedure knows exactly where it is
without having to do heavy computation by using the information
given by the current mating. To make this work, also carried with a path
is an environment, which stores the indices and (partial) substitutions
for the variables in the path.

\section{Propositional Case}
In the file {\it mating-dir.lisp}, you can see that the function 
\indexfunction{ms-director}
checks whether there are any free variables in \indexother{current-eproof}
(seealso eproof, current-eproof)
in order to decide whether to call \indexfunction{ms} or 
\indexfunction{ms-propositional};
if there are no free variables in \indexother{current-eproof}, ms-propositional is
called.

\subsection{Sunil's Propositional Theorem Prover}

The original files for Sunil's fast propositional calculus theorem-prover
are in \\
{\it /home/theorem/project/tps-variants/si-prop/}. {\tt qload} these files, go into the
editor, and make the edwff the example you wish to run. Within the editor
{\tt (test)} runs the program using edwff as argument. When it is done,
{\tt (test1)} shows the mating it found.

Most of the code in the above directory is now a permanent part of \TPS;
the function \indexfunction{prop-msearch} can be called from the {\tt mate} top 
level, and will display a correct mating for propositional jforms. The 
way to call it is: {\tt (auto::prop-msearch (auto::cr-eproof-jform))} (the latter
function is the internal name for \indexcommand{CJFORM}). For some reason, 
the propositional theorem prover is never used, except to reconstruct the 
mating after a path-focused duplication procedure has found it.

\section{Control Structure and Interface to Unification}

The non-path-focused-duplication (npfd) search procedures have
a \indexother{connection graph}, but the pfd procedures do not; the latter just
apply simpl to decide whether literals may be mated.
Sunil's disjunction heuristic (see below) is implemented for pfd search
procedures, but not for npfd.

The non-path-focused-duplication search procedures break a
jform with top-level disjuncts into separate problems, but the
path-focused-duplication search procedures do not.

When searching for a way to span a path, \TPS runs down the path
from the top, and considers each literal. As a mate for that literal, it
considers each literal which precedes it on the path.

When \TPS considers adding an essentially ffpair (pair of
literals which each start with a variable when one ignores any
negations) to the mating, it simultaneously considers both
orientations (choices for which literal will be negative and which
positive) of the ffpair.  Roughly speaking, it does this by putting a
disagreement pair corresponding to the ffpair into the leaves of the
unification tree, and proceeding with the unification process.  If
this process encounters a disagreement pair of the form <{\bf A},
\verb+~+{\bf B}>, where {\bf A} starts with a constant but {\bf B} does not, it
replaces this pair with {\w <\verb+~+{\bf A}, {\bf B}>} and continues. In this
way it finds whichever substitution works in a very economical
fashion.  When a success node is found for a complete mating, the
associated substitution determines the orientation of the ffpair in
the mating.

Here is some more detail about how this is actually implemented.
When TPS decides to mate a pair {L, K} of literals (which it considers	
as an unordered pair), it seeks to unify $\verb+~+\;$L with K, where L 
occurred before K on the path. Whenever the unification process
encounters a double negation, it deletes it. (Thus, in the case of a
first-order problem, TPS quickly starts to unify the atoms of the mated
literals.)

When the unification process encounters a flexible-rigid pair
(which we designate by <...f... , ...$\verb+~+\;$H...>)
where the flexible term has head variable f and the rigid term has
a head of the form $\verb+~+\;$H, the following substitutions for f are
generated:

\begin{enumerate}
\item Projections

\item $\lambda w^{1}\cdots\lambda w^{k}. \verb+~+ f^{1} \ldots$, where information is attached
to $f^{1}$ which does not permit a substitution of this same type (i.e.,
introducing a negation) to be applied to $f^{1}$.

\item $\lambda w^{1}\cdots \lambda w^{k}. f^{2} \ldots$, where information is attached
to $f^{2}$ which does not permit the first two of these types of substitution
to be applied to it. 
\end{enumerate}

(The information is stored by putting the variables into the lists
neg-h-var-list and  imitation-h-var-list.)
The restrictions on $f^{2}$ assure that the dpair which is essentially
<...$f^{2}$... , ...\verb+~+ H...> can only be used to generate new substitutions
for $f^{2}$ if other substitutions reduce \verb+~+H to a form which does not
start with a negation. 

\subsection{Sunil's Disjunction Heuristic}

\begin{enumerate}
\item If a matrix contains $[A \lor B]$, and $A$ has no mate, then no
mate for $B$ will be sought.

\item If a matrix contains  $[A \lor B]$, and $A$ has a mate, but no
mate for $B$ can be found, then the search will backtrack,
throwing out the mate for A and all links which were subsequently
added to the mating.
\end{enumerate}

{\bf Remark:}  This heuristic is also used by Matt Bishop's search
procedure ms98-1.  See his thesis~\cite{Bishop99a} for more details.

\section{After a Mating is Found}

Here is the sequence of events for pfd:

\begin{enumerate}
\item An expansion proof has been found.
A record (probably called DUP-RECORD) of indices for duplicated
variables, leaves, and connections is maintained by the search process.
The unification tree associated with the mating has a record of the
substitutions for variables.

\item Construct jform with final substitutions applied.
This uses all copies of variables needed for the final mating.

\item Duplicate expansion tree from the jform

\item Attach expansion terms to the expansion tree

\item Call propositional search to reconstruct the mating

\item Reorganize mating in ms88 form

\item Merge expansion proof

\item Translate expansion proof
\end{enumerate}

\section{How MIN-QUANT-ETREE Works}

After a proof is found, \TPS constructs an expansion proof tree.
The implementation of flag \indexflag{MIN-QUANT-ETREE} consists of the
following steps.


\begin{enumerate}
\item \TPS searches through the expansion proof tree to find if
there are primsubs which are not in minimized-scope form.
If \TPS finds some, it goes to step (2).

\item First, \TPS transform all the primsubs into their minimized-scope 
forms. In order to make sure that the expansion proof
tree is still a correct one, \TPS has to modify it. This is
done by calling two functions, namely, \indexfunction{one-step-mqe-bd} and
\indexfunction{one-step-mqe-infix}. Now \TPS goes to step (3).

\item Since the expansion proof tree is still a correct one, \TPS
can use a propositional proof checker to search for a mating.
This mating will be used to construct a proof in natural
deduction style.
\end{enumerate}

There are still potential bugs in the procedure, since
various rewrite nodes in an expansion proof can interfere with
flag \indexflag{MIN-QUANT-ETREE}. This has to be dealt with case by case.

\section{Merging}

Note: merging still contains bugs, although not very many. If a correct mating
is merged and produces a translation error, or a message of the form "The formula is not provable
as there's no connection on the following path: <path>", then it's likely that a bug in merging is
the culprit. Within merging, the routines for REMOVE-LEIBNIZ and PRETTIFY are the most likely 
causes of problems. The former only applies for formulae with equality, and can be checked by
trying again with the flag REMOVE-LEIBNIZ set to NIL. For the latter, you need to use \indexother{merge-debug}; 
type {\tt setq auto::merge-debug t} before calling merging, and you can step 
through the process, inspecting the etree at each step and omitting the optional steps. 
This can be a great help in discovering which part of the merging process is causing the bug.

Once a complete mating is found, we enter a merging process, in which
each expansion is checked to see
if it is really needed in the proof.  That is, it is temporarily removed
from the etree, and the resulting etree is checked to see if the mating still
spans all its paths.  This begins in \indexfunction{PRUNE-UNMATED-BRANCHES} (a misleading name),
which calls \indexfunction{UNNEEDED-NODE-P}, which calls \indexfunction{SPANS}, which calls
\indexfunction{SPANNING-CLIST-PATH}, which calls \indexfunction{FIND-CHEAPEST-CLIST-SPANNING-PATH}, which
\indexfunction{FIND-ALT-CHEAPEST-CLIST-SPANNING-PATH}.   Note that even in x5207, which is
relatively small, 12 calls to \indexfunction{UNNEEDED-NODE-P} result in 295 calls to
\indexfunction{FIND-CHEAPEST-CLIST-SPANNING-PATH}; these functions are the main reason why 
merging can be so slow, especially in proofs created 
by MS90-3 or MS90-9.

You could possibly (as was done at one time) not test this spanning 
condition, and just check to see if every expansion actually has a connection 
below it.  The problem here is that in ms90-3, by the time we get to the merging
process, we have mated every possible pair in the tree, whether the connection
is necessary or not.  That is why unneeded-node-p was modified to be more 
rigorous, because otherwise it was almost useless.  Additionally, there may be
embedded falsehood nodes below it, which are required to close some paths,
even if there are no mated nodes below it. 

A better spanning function should be used, though actually the one used
is already propositional, but of an earlier generation than Sunil's
propositional search function.  One should
realize, however, that the procedure should use the mating provided (and not 
the eager "mate-everything", because our mating might {\it not} be that big).  
In fact, Dan wrote such a \indexfunction{SPANS} that uses a variant of \indexfunction{PROP-MSEARCH},
and the time used in X5207 by \indexfunction{SPANS} went from 1 second to about .3 sec. 
Unfortunately, \indexfunction{PROP-MSEARCH} (or rather, \indexfunction{PROP-FIND-CHEAPEST-PATH}) appears to 
have the "empty disjunction causes confusion" bug.  (Try MS90-3 on
the formula "falsehood implies A"). 

More drastic changes were tougher to implement. There were a few suggestions:
\begin{itemize}
\item What this is doing is a lot of duplicated effort, so perhaps it would be possible to cache some results.
This would be pretty space-intensive; e.g. THM131 has an astronomical number of vpaths
when it begins merging. It turned out that attempts to make SPANS better by caching the results were pretty silly, 
because the way it is invoked, you can't tell the difference between
sets of arguments.  The differences are made by changing the status of
various lower-level expansion nodes.  So that attempt was abandoned.

\item Perhaps it would be possible to check the paths which the suspect node was on.
It's not clear how to do this.

\item Of course, it might be possible to avoid some of the calls to spans
in the first place (though possibly not with MS90-3), but even eliminating 
half would only save 3 days in the wolf-goat-cabbage problem, without changing what it does. 
\end{itemize}

In the end, the solution used was as follows: when path-focused duplication has been
used, the expansion proof will often have a great deal of redundancy
in the sense that the same expansion term will be used for a given variable
many times. More precisely, if one defines an expansion branch by
looking at sequences of nested expansion nodes, attaching one expansion
term to each expansion node in the sequence, there will be many identical
expansion branches. So one can start by merging the tree in the
sense of eliminating this redundancy, and then apply to this much simpler
tree the procedure for deleting unnecessary expansion terms which
we think is using so much time. It turned out to be easiest to do this
by throwing away the mating, and reconstructing it by propositional search
after the tree has been cut down to size. Of course, one could also
preserve the original mating by "merging" it appropriately as one collapsed
the tree.

The precise way in which this was done, in the file {\it mating-merge.lisp}, was:
\begin{enumerate}
\item Don't do pruning of unnecessary nodes at the beginning of the merge,
when the tree is its greatest size. 

\item Instead, {\it do} prune all branches that couldn't possibly have been used 
They are those that have a zero status. This is probably not necessary,
but certainly makes debugging easier and doesn't cost much.

\item After merging of identical expansions has been done, call the original
pruning function.
\end{enumerate}

Note that the merge process does (or should, anyway) merge the mating 
appropriately as the tree collapses.
On THM131 this takes the time spent on merging from 7 days down to 12 minutes.
This is not so surprising, because it begins with 113 million paths, and after
the merging of duplicate expansions, it's down to around 442 thousand. 

The matingstree top level has its own approach to merging, which is essentially
step (2) above, in which all unused 
expansions are simply thrown away, followed by a regular merge as detailed above. 
Putting step (2) first here 
is necessary because the master expansion tree has many nodes which are irrelevant to any particular proof.

\section{Printing}
